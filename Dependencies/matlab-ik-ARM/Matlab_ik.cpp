//
// Academic License - for use in teaching, academic research, and meeting
// course requirements at degree granting institutions only.  Not for
// government, commercial, or other organizational use.
// File: Matlab_ik.cpp
//
// MATLAB Coder version            : 24.2
// C/C++ source code generated on  : 03-Apr-2025 13:21:22
//

// Include Files
#include "Matlab_ik.h"
#include "Matlab_ik_types.h"
#include "rt_nonfinite.h"
#include "coder_array.h"
#include "coder_bounded_array.h"
#include "coder_posix_time.h"
#include "collisioncodegen_api.hpp"
#include "rt_defines.h"
#include <algorithm>
#include <cmath>
#include <cstring>

// Type Declarations
namespace coder
{
  namespace robotics
  {
    namespace manip
    {
      namespace internal
      {
        class GIKProblem;
      }
    }
  }

  class anonymous_function;
}

// Type Definitions
namespace coder
{
  namespace robotics
  {
    namespace core
    {
      namespace internal
      {
        enum class NLPSolverExitFlags
          : int {
          LocalMinimumFound = 1,       // Default value
          IterationLimitExceeded,
          TimeLimitExceeded,
          StepSizeBelowMinimum,
          ChangeInErrorBelowMinimum,
          SearchDirectionInvalid,
          HessianNotPositiveSemidefinite,
          TrustRegionRadiusBelowMinimum
        };
      }
    }
  }
}

struct cell_wrap_41
{
  double f1[16];
};

struct cell_wrap_58
{
  coder::array<double, 2U> f1;
};

struct cell_wrap_59
{
  coder::array<bool, 2U> f1;
};

struct cell_61
{
  double f2[3];
  double f3;
  double f4;
};

struct cell_63
{
  double f2[4];
  double f3;
  double f4;
};

namespace coder
{
  namespace robotics
  {
    namespace manip
    {
      namespace internal
      {
        class CharacterVector
        {
         public:
          double Length;
          char Vector[200];
        };
      }
    }
  }

  class rigidBodyJoint
  {
   public:
    rigidBodyJoint *init();
    void set_MotionSubspace(const double msubspace_data[]);
    rigidBodyJoint *init(const char jname[14]);
    rigidBodyJoint *b_init();
    void setFixedTransform();
    rigidBodyJoint *copy(rigidBodyJoint &iobj_0) const;
    void get_MotionSubspace(double msubspace_data[], int msubspace_size[2])
      const;
    rigidBodyJoint *c_init();
    void b_setFixedTransform();
    void set_PositionLimits();
    void resetHomePosition();
    void set_JointAxis();
    void b_set_MotionSubspace(const double msubspace[6]);
    void set_HomePosition();
    rigidBodyJoint *d_init();
    void c_setFixedTransform();
    void b_set_PositionLimits();
    void b_set_JointAxis();
    void b_set_HomePosition();
    rigidBodyJoint *e_init();
    void d_setFixedTransform();
    void c_set_PositionLimits();
    rigidBodyJoint *f_init();
    void e_setFixedTransform();
    void d_set_PositionLimits();
    void c_set_JointAxis();
    rigidBodyJoint *g_init();
    void f_setFixedTransform();
    void e_set_PositionLimits();
    rigidBodyJoint *h_init();
    void g_setFixedTransform();
    void f_set_PositionLimits();
    rigidBodyJoint *i_init();
    void h_setFixedTransform();
    rigidBodyJoint *j_init();
    rigidBodyJoint *k_init();
    void i_setFixedTransform();
    void get_JointAxis(double ax[3]) const;
    void transformBodyToParent(const array<double, 1U> &q, double T[16]) const;
    void setFixedTransform(const double input[16]);
    static void randomConfig(robotics::manip::internal::GIKProblem *problem,
      array<double, 1U> &rc);
    double VelocityNumber;
    double PositionNumber;
    bool InTree;
    double JointToParentTransform[16];
    double ChildToJointTransform[16];
    robotics::manip::internal::CharacterVector NameInternal;
    double PositionLimitsInternal[14];
    double HomePositionInternal[7];
    double JointAxisInternal[3];
    double MotionSubspaceInternal[36];
    robotics::manip::internal::CharacterVector TypeInternal;
  };

  namespace robotics
  {
    namespace manip
    {
      namespace internal
      {
        class CollisionGeometry
        {
         public:
          void *CollisionPrimitive;
          double LocalPose[16];
          double WorldPose[16];
          double MeshScale[3];
        };

        class CollisionSet
        {
         public:
          CollisionSet *init(double maxElements);
          bool checkCollision(CollisionSet *querySet, double &minSepDist, double
                              witnessPts[6]);
          void matlabCodegenDestructor();
          ~CollisionSet();
          CollisionSet();
          bool matlabCodegenIsDeleted;
          array<CollisionGeometry, 2U> CollisionGeometries;
          double MaxElements;
          double Size;
        };

        class RigidBody
        {
         public:
          RigidBody *init(const char bodyInput[11], CollisionSet &iobj_0,
                          rigidBodyJoint &iobj_1);
          RigidBody *copy(CollisionSet &iobj_0, rigidBodyJoint &iobj_1,
                          RigidBody &iobj_2);
          RigidBody *init(const char bodyInput[10]);
          void matlabCodegenDestructor();
          ~RigidBody();
          RigidBody();
          bool matlabCodegenIsDeleted;
          CharacterVector NameInternal;
          double Index;
          rigidBodyJoint *JointInternal;
          double ParentIndex;
          double MassInternal;
          double CenterOfMassInternal[3];
          double InertiaInternal[9];
          double SpatialInertia[36];
          CollisionSet *CollisionsInternal;
          CollisionSet _pobj0;
          rigidBodyJoint _pobj1;
        };

        class FastVisualizationHelper
        {
        };

        class b_RigidBody
        {
         public:
          void matlabCodegenDestructor();
          ~b_RigidBody();
          b_RigidBody();
          bool matlabCodegenIsDeleted;
          CharacterVector NameInternal;
          rigidBodyJoint JointInternal;
          CollisionSet CollisionsInternal;
        };
      }
    }
  }

  class collisionCapsule
  {
   public:
    collisionCapsule *init();
    collisionCapsule *b_init();
    collisionCapsule *c_init();
    collisionCapsule *d_init();
    collisionCapsule *e_init();
    void matlabCodegenDestructor();
    ~collisionCapsule();
    collisionCapsule();
    bool matlabCodegenIsDeleted;
    double PoseInternal[16];
    void *GeometryInternal;
    double RadiusInternal;
    double LengthInternal;
  };

  namespace robotics
  {
    namespace core
    {
      namespace internal
      {
        class SystemTimeProvider
        {
         public:
          coderTimespec StartTime;
        };
      }
    }
  }

  class se3
  {
   public:
    void init(const double varargin_1[9], const double varargin_2[3]);
    double M[16];
  };

  class constraintPositionTarget
  {
   public:
    constraintPositionTarget *init();
    constraintPositionTarget *b_init();
    char EndEffector[9];
    array<char, 2U> ReferenceBody;
    double TargetPosition[3];
    double PositionTolerance;
    double Weights;
   protected:
    cell_61 ConstructorPropertyDefaultValues;
  };

  class constraintOrientationTarget
  {
   public:
    constraintOrientationTarget *init();
    void set_TargetOrientation(const double b_value[4]);
    char EndEffector[10];
    array<char, 2U> ReferenceBody;
    double TargetOrientation[4];
    double OrientationTolerance;
    double Weights;
   protected:
    cell_63 ConstructorPropertyDefaultValues;
  };

  namespace robotics
  {
    namespace manip
    {
      namespace internal
      {
        class GIKHelpers
        {
         public:
          static double computeCost(const array<double, 1U> &x, GIKProblem
            *problem, array<double, 2U> &W, array<double, 2U> &Jac, GIKProblem **
            b_problem);
          static void computeGradient(const array<double, 1U> &x, GIKProblem
            *problem, array<double, 1U> &grad);
          static double evaluateSolution(const array<double, 1U> &x, GIKProblem *
            problem);
        };
      }
    }
  }

  class string
  {
   public:
    static bool eq(const char obj1_data[], const int obj1_size[2]);
  };
}

class CoderTimeAPI
{
 public:
  static void callCoderClockGettime_init();
};

namespace coder
{
  namespace robotics
  {
    namespace manip
    {
      namespace internal
      {
        class RigidBodyTree
        {
         public:
          RigidBodyTree *init();
          void matlabCodegenDestructor();
          ~RigidBodyTree();
          RigidBodyTree();
          bool matlabCodegenIsDeleted;
          b_RigidBody Base;
          FastVisualizationHelper b_FastVisualizationHelper;
          b_RigidBody *Bodies[1];
          b_RigidBody _pobj0;
        };
      }
    }
  }

  class rigidBody
  {
   public:
    rigidBody *init(robotics::manip::internal::RigidBodyTree &iobj_0, robotics::
                    manip::internal::CollisionSet &iobj_1, rigidBodyJoint
                    &iobj_2, robotics::manip::internal::RigidBody &iobj_3);
    void set_Mass();
    void set_CenterOfMass();
    void set_Inertia();
    void addCollision(const collisionCapsule *varargin_1);
    rigidBody *b_init(robotics::manip::internal::RigidBodyTree &iobj_0, robotics::
                      manip::internal::CollisionSet &iobj_1, rigidBodyJoint
                      &iobj_2, robotics::manip::internal::RigidBody &iobj_3);
    void b_addCollision(const collisionCapsule *varargin_1);
    rigidBody *c_init(robotics::manip::internal::RigidBodyTree &iobj_0, robotics::
                      manip::internal::CollisionSet &iobj_1, rigidBodyJoint
                      &iobj_2, robotics::manip::internal::RigidBody &iobj_3);
    void c_addCollision(const collisionCapsule *varargin_1);
    rigidBody *d_init(robotics::manip::internal::RigidBodyTree &iobj_0, robotics::
                      manip::internal::CollisionSet &iobj_1, rigidBodyJoint
                      &iobj_2, robotics::manip::internal::RigidBody &iobj_3);
    rigidBody *e_init(robotics::manip::internal::RigidBodyTree &iobj_0, robotics::
                      manip::internal::CollisionSet &iobj_1, rigidBodyJoint
                      &iobj_2, robotics::manip::internal::RigidBody &iobj_3);
    void d_addCollision(const collisionCapsule *varargin_1);
    rigidBody *f_init(robotics::manip::internal::RigidBodyTree &iobj_0, robotics::
                      manip::internal::CollisionSet &iobj_1, rigidBodyJoint
                      &iobj_2, robotics::manip::internal::RigidBody &iobj_3);
    rigidBody *g_init(robotics::manip::internal::RigidBodyTree &iobj_0, robotics::
                      manip::internal::CollisionSet &iobj_1, rigidBodyJoint
                      &iobj_2, robotics::manip::internal::RigidBody &iobj_3);
    rigidBody *h_init(robotics::manip::internal::RigidBodyTree &iobj_0, robotics::
                      manip::internal::CollisionSet &iobj_1, rigidBodyJoint
                      &iobj_2, robotics::manip::internal::RigidBody &iobj_3);
    rigidBody *i_init(robotics::manip::internal::RigidBodyTree &iobj_0, robotics::
                      manip::internal::CollisionSet &iobj_1, rigidBodyJoint
                      &iobj_2, robotics::manip::internal::RigidBody &iobj_3);
    void e_addCollision(const collisionCapsule *varargin_1);
    rigidBody *j_init(robotics::manip::internal::RigidBodyTree &iobj_0, robotics::
                      manip::internal::CollisionSet &iobj_1, rigidBodyJoint
                      &iobj_2, robotics::manip::internal::RigidBody &iobj_3);
    rigidBody *k_init(robotics::manip::internal::RigidBodyTree &iobj_0, robotics::
                      manip::internal::CollisionSet &iobj_1, rigidBodyJoint
                      &iobj_2, robotics::manip::internal::RigidBody &iobj_3);
    rigidBody *l_init(robotics::manip::internal::RigidBodyTree &iobj_0, robotics::
                      manip::internal::CollisionSet &iobj_1, rigidBodyJoint
                      &iobj_2, robotics::manip::internal::RigidBody &iobj_3);
    void matlabCodegenDestructor();
    ~rigidBody();
    rigidBody();
    bool matlabCodegenIsDeleted;
    robotics::manip::internal::RigidBody *BodyInternal;
    robotics::manip::internal::RigidBodyTree *TreeInternal;
  };

  namespace robotics
  {
    namespace manip
    {
      namespace internal
      {
        class b_RigidBodyTree
        {
         public:
          b_RigidBodyTree *init();
          double findBodyIndexByName();
          double findBodyIndexByName(const char bodyname_data[], const int
            bodyname_size[2]);
          double findBodyIndexByJointName(const char jointname_data[], const int
            jointname_size[2]);
          double b_findBodyIndexByName();
          double findBodyIndexByName(const char bodyname[8]);
          double b_findBodyIndexByName(const char bodyname[6]);
          double c_findBodyIndexByName(const char bodyname[10]);
          void forwardKinematics(const double qvec[6], cell_wrap_41 Ttree_data[],
            int Ttree_size[2]);
          bool checkSelfCollision(const cell_wrap_41 tTree_data[], const double
            baseTform[16], bool isExhaustive, const double
            skippedSelfCollisionType[24], array<double, 2U> &separationDist,
            array<double, 2U> &witnessPts);
          bool checkSelfCollision_(const cell_wrap_41 tTree_data[], const double
            baseTform[16], bool isExhaustive, const anonymous_function &
            skipCollisionFcn, array<double, 2U> &separationDist, array<double,
            2U> &witnessPts);
          void set_BaseName(const char baseName_data[], const int baseName_size
                            [2]);
          void addBody(RigidBody *bodyin, const char parentName_data[], const
                       int parentName_size[2], CollisionSet &iobj_0,
                       rigidBodyJoint &iobj_1, RigidBody &iobj_2);
          void get_JointPositionLimits(array<double, 2U> &limits);
          void efficientFKAndJacobianForIK(const array<double, 1U> &qv, double
            bid1, double bid2, double T_data[], int T_size[2], array<double, 2U>
            &Jac);
          void kinematicPathInternal(RigidBody *body1, RigidBody *body2, array<
            double, 2U> &indices);
          void ancestorIndices(RigidBody *body, array<double, 2U> &indices);
          void matlabCodegenDestructor();
          ~b_RigidBodyTree();
          b_RigidBodyTree();
         private:
          static bool checkSelfCollision_anonFcn3(const double idxpairs[24],
            double i, double j);
         public:
          bool matlabCodegenIsDeleted;
          double NumBodies;
          RigidBody Base;
          FastVisualizationHelper b_FastVisualizationHelper;
          double Gravity[3];
          RigidBody *Bodies[12];
          double NumNonFixedBodies;
          double PositionNumber;
          double VelocityNumber;
          double PositionDoFMap[24];
          double VelocityDoFMap[24];
          CollisionSet _pobj0[3];
          rigidBodyJoint _pobj1[3];
          RigidBody _pobj2[12];
        };
      }
    }
  }

  class rigidBodyTree
  {
   public:
    rigidBodyTree *init();
    void set_BaseName();
    void addBody(rigidBody &bodyin, robotics::manip::internal::CollisionSet &
                 iobj_0, rigidBodyJoint &iobj_1, robotics::manip::internal::
                 RigidBody &iobj_2);
    void b_addBody(rigidBody &bodyin, robotics::manip::internal::CollisionSet &
                   iobj_0, rigidBodyJoint &iobj_1, robotics::manip::internal::
                   RigidBody &iobj_2);
    void c_addBody(rigidBody &bodyin, robotics::manip::internal::CollisionSet &
                   iobj_0, rigidBodyJoint &iobj_1, robotics::manip::internal::
                   RigidBody &iobj_2);
    void d_addBody(rigidBody &bodyin, robotics::manip::internal::CollisionSet &
                   iobj_0, rigidBodyJoint &iobj_1, robotics::manip::internal::
                   RigidBody &iobj_2);
    void e_addBody(rigidBody &bodyin, robotics::manip::internal::CollisionSet &
                   iobj_0, rigidBodyJoint &iobj_1, robotics::manip::internal::
                   RigidBody &iobj_2);
    void f_addBody(rigidBody &bodyin, robotics::manip::internal::CollisionSet &
                   iobj_0, rigidBodyJoint &iobj_1, robotics::manip::internal::
                   RigidBody &iobj_2);
    void g_addBody(rigidBody &bodyin, robotics::manip::internal::CollisionSet &
                   iobj_0, rigidBodyJoint &iobj_1, robotics::manip::internal::
                   RigidBody &iobj_2);
    void h_addBody(rigidBody &bodyin, robotics::manip::internal::CollisionSet &
                   iobj_0, rigidBodyJoint &iobj_1, robotics::manip::internal::
                   RigidBody &iobj_2);
    void i_addBody(rigidBody &bodyin, robotics::manip::internal::CollisionSet &
                   iobj_0, rigidBodyJoint &iobj_1, robotics::manip::internal::
                   RigidBody &iobj_2);
    bool checkCollision(const double config[6], array<double, 2U>
                        &separationDist);
    void getTransform(const double varargin_1[6], double T[16]);
    void b_getTransform(const double varargin_1[6], double T[16]);
    rigidBodyTree *copy(rigidBodyJoint &iobj_0, robotics::manip::internal::
                        RigidBody &iobj_1, robotics::manip::internal::
                        CollisionSet &iobj_2, robotics::manip::internal::
                        b_RigidBodyTree &iobj_3, rigidBodyTree &iobj_4);
    void matlabCodegenDestructor();
    ~rigidBodyTree();
    rigidBodyTree();
    bool matlabCodegenIsDeleted;
    robotics::manip::internal::b_RigidBodyTree *TreeInternal;
    robotics::manip::internal::CollisionSet _pobj0;
    robotics::manip::internal::b_RigidBodyTree _pobj1;
  };

  namespace robotics
  {
    namespace manip
    {
      namespace internal
      {
        class PositionTarget
        {
         public:
          void get_EndEffector(char value_data[], int value_size[2]);
          void get_ReferenceBody(char value_data[], int value_size[2]);
          void matlabCodegenDestructor();
          ~PositionTarget();
          PositionTarget();
          bool matlabCodegenIsDeleted;
          double NumElements;
          b_RigidBodyTree *Tree;
          array<double, 2U> BoundsInternal;
          array<double, 2U> Weights;
          double ReferenceBodyIndex;
          double EndEffectorIndex;
          double TargetPosition[3];
        };

        class OrientationTarget
        {
         public:
          double evaluateFromTransform(const double T_data[], const int T_size[2],
            double JTwist[6]) const;
          void get_EndEffector(char value_data[], int value_size[2]);
          void get_ReferenceBody(char value_data[], int value_size[2]);
          void matlabCodegenDestructor();
          ~OrientationTarget();
          OrientationTarget();
          bool matlabCodegenIsDeleted;
          double NumElements;
          b_RigidBodyTree *Tree;
          array<double, 2U> BoundsInternal;
          array<double, 2U> Weights;
          double ReferenceBodyIndex;
          double EndEffectorIndex;
          double TargetTransform[16];
        };
      }
    }
  }
}

struct cell_57
{
  coder::robotics::manip::internal::PositionTarget *f1;
  coder::robotics::manip::internal::OrientationTarget *f2;
};

namespace coder
{
  namespace robotics
  {
    namespace manip
    {
      namespace internal
      {
        class GIKProblem
        {
         public:
          void updateDesignVariableBounds();
          void residualsInternal(const array<double, 1U> &x, array<double, 1U>
            &f, array<double, 2U> &J);
          void set_EnforceJointLimits(bool b_value);
          void update(const constraintPositionTarget &varargin_1, const
                      constraintOrientationTarget &varargin_2);
          void residuals(const array<double, 1U> &x, array<double, 1U> &f);
          void residuals(const array<double, 1U> &x, array<double, 1U> &f, array<
                         double, 2U> &J);
          void get_WeightMatrix(array<double, 2U> &b_value) const;
          void get_KinematicPath(double value_data[], int value_size[2]);
          void matlabCodegenDestructor();
          ~GIKProblem();
          GIKProblem();
          bool matlabCodegenIsDeleted;
          array<double, 2U> DesignVariableBoundsInternal;
          array<double, 2U> ConstraintMatrixInternal;
          array<double, 1U> ConstraintBoundInternal;
          b_RigidBodyTree *Tree;
          cell_57 Constraints;
          double NumResiduals;
          double NumSlacks;
          double NumPositions;
          double NumVariables;
          cell_wrap_58 ResidualIndices[2];
          cell_wrap_58 SlackIndices[2];
          bool EnforceJointLimitsInternal;
          cell_wrap_59 EqualityFlags[2];
          array<double, 1U> LastX;
          array<double, 1U> LastF;
          array<double, 2U> LastJ;
          OrientationTarget _pobj0;
          PositionTarget _pobj1;
        };
      }
    }

    namespace core
    {
      namespace internal
      {
        class DampedBFGSwGradientProjection
        {
         public:
          NLPSolverExitFlags solveInternal(array<double, 1U> &xSol, double &err,
            double &iter);
          bool searchDirectionInvalid(const array<double, 1U> &xNew) const;
          void matlabCodegenDestructor();
          ~DampedBFGSwGradientProjection();
          DampedBFGSwGradientProjection();
         private:
          void identifyActiveSet(const array<double, 1U> &x, array<bool, 1U>
            &activeSet, array<double, 2U> &A) const;
         public:
          bool matlabCodegenIsDeleted;
          char Name[22];
          array<double, 2U> ConstraintMatrix;
          array<double, 1U> ConstraintBound;
          bool ConstraintsOn;
          double SolutionTolerance;
          bool RandomRestart;
          manip::internal::GIKProblem *ExtraArgs;
          double MaxNumIteration;
          double MaxTime;
          array<double, 1U> SeedInternal;
          double MaxTimeInternal;
          double MaxNumIterationInternal;
          double StepTolerance;
          SystemTimeProvider TimeObj;
          double GradientTolerance;
          double ArmijoRuleBeta;
          double ArmijoRuleSigma;
          SystemTimeProvider TimeObjInternal;
        };
      }
    }
  }

  class generalizedInverseKinematics
  {
   public:
    generalizedInverseKinematics *init(rigidBodyTree &varargin_2);
    double get_SolverParameters(double &solverparams_MaxTime, double
      &solverparams_GradientTolerance, double &solverparams_SolutionTolerance,
      bool &solverparams_EnforceJointLimits, bool
      &solverparams_AllowRandomRestart, double &solverparams_StepTolerance);
    void set_SolverParameters(double solverparams_MaxIterations, double
      solverparams_MaxTime, double solverparams_GradientTolerance, double
      solverparams_SolutionTolerance, bool solverparams_EnforceJointLimits, bool
      solverparams_AllowRandomRestart, double solverparams_StepTolerance);
    double step(const double varargin_1[6], constraintPositionTarget &varargin_2,
                constraintOrientationTarget &varargin_3, double varargout_1[6],
                struct2_T varargout_2_ConstraintViolations[2], char
                varargout_2_Status_data[], int varargout_2_Status_size[2],
                double &varargout_2_NumRandomRestarts, double
                &varargout_2_ExitFlag);
    void matlabCodegenDestructor();
    ~generalizedInverseKinematics();
    generalizedInverseKinematics();
   protected:
    double stepImpl(const double initialGuess[6], const constraintPositionTarget
                    &varargin_1, const constraintOrientationTarget &varargin_2,
                    double QSol[6], struct2_T solutionInfo_ConstraintViolations
                    [2], char solutionInfo_Status_data[], int
                    solutionInfo_Status_size[2], double
                    &solutionInfo_NumRandomRestarts, double
                    &solutionInfo_ExitFlag);
   public:
    bool matlabCodegenIsDeleted;
    robotics::core::internal::DampedBFGSwGradientProjection *Solver;
    robotics::manip::internal::b_RigidBodyTree *Tree;
    robotics::manip::internal::GIKProblem Problem;
    bool EnforceJointLimits;
    rigidBodyJoint _pobj0[24];
    robotics::manip::internal::RigidBody _pobj1[12];
    robotics::manip::internal::CollisionSet _pobj2[25];
    robotics::manip::internal::b_RigidBodyTree _pobj3;
    robotics::core::internal::DampedBFGSwGradientProjection _pobj4;
   private:
    int isInitialized;
    bool isSetupComplete;
    bool RigidBodyTreeHasBeenSet;
  };
}

struct struct_T
{
  coder::robotics::manip::internal::b_RigidBodyTree *obj;
  double idxpairs[24];
};

namespace coder
{
  class anonymous_function
  {
   public:
    struct_T workspace;
  };
}

// Variable Definitions
static coder::robotics::manip::internal::RigidBody gobj_6[50];
static coder::rigidBodyJoint gobj_5[100];
static coder::robotics::manip::internal::CollisionSet gobj_4[100];
static coder::rigidBodyTree gobj_3[2];
static coder::rigidBodyTree robot;
static bool robot_not_empty;
static unsigned int state[625];
static coder::rigidBodyTree *b_robot;
static bool b_robot_not_empty;
static coder::rigidBodyTree robot_rbt;
static bool robot_rbt_not_empty;
static double freq;
static bool freq_not_empty;
static coder::rigidBodyTree b_robot_rbt;
static bool b_robot_rbt_not_empty;
static const char cv[10]{ 'd', 'u', 'm', 'm', 'y', 'b', 'o', 'd', 'y', '1' };

static const signed char iv[16]{ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1
};

static const char cv1[9]{ 'p', 'r', 'i', 's', 'm', 'a', 't', 'i', 'c' };

static const char cv2[128]{ '\x00', '\x01', '\x02', '\x03', '\x04', '\x05',
  '\x06', '\a', '\b', '\t', '\n', '\v', '\f', '\r', '\x0e', '\x0f', '\x10',
  '\x11', '\x12', '\x13', '\x14', '\x15', '\x16', '\x17', '\x18', '\x19', '\x1a',
  '\x1b', '\x1c', '\x1d', '\x1e', '\x1f', ' ', '!', '\"', '#', '$', '%', '&',
  '\'', '(', ')', '*', '+', ',', '-', '.', '/', '0', '1', '2', '3', '4', '5',
  '6', '7', '8', '9', ':', ';', '<', '=', '>', '?', '@', 'a', 'b', 'c', 'd', 'e',
  'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',
  'v', 'w', 'x', 'y', 'z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd',
  'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
  'u', 'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '\x7f' };

static const signed char iv1[9]{ 1, 0, 0, 0, 1, 0, 0, 0, 1 };

static const char cv3[10]{ 'b', 'o', 'd', 'y', 'T', 'o', 'o', 'l', 'E', 'E' };

static const char cv4[9]{ 't', 'a', 'r', 'g', 'e', 't', 'F', 'i', 'n' };

static const char cv5[9]{ 't', 'a', 'r', 'g', 'e', 't', 'A', 'p', 'r' };

static bool isInitialized_Matlab_ik{ false };

// Function Declarations
static void Matlab_checkCollision_delete();
static void Matlab_checkCollision_init();
static void Matlab_checkCollision_new();
static void Matlab_getForwardKinematics_delete();
static void Matlab_getForwardKinematics_init();
static void Matlab_getForwardKinematics_new();
static void Matlab_getGikCut_delete();
static void Matlab_getGikCut_init();
static void Matlab_getGikCut_new();
static void Matlab_getGikFull_delete();
static void Matlab_getGikFull_init();
static void Matlab_getGikFull_new();
static void binary_expand_op_1(cell_wrap_58 in1[2], const coder::array<double,
  1U> &in3, const coder::array<double, 1U> &in5);
static void binary_expand_op_10(coder::array<double, 1U> &in1, const coder::
  array<double, 1U> &in2, double in3, const coder::array<double, 1U> &in4);
static void binary_expand_op_12(coder::array<double, 1U> &in1, const coder::
  array<double, 1U> &in2, const coder::array<double, 1U> &in3);
static double binary_expand_op_13(const coder::array<double, 1U> &in1, const
  coder::array<double, 1U> &in2, int &out2);
static void binary_expand_op_14(coder::array<int, 1U> &in1, const coder::array<
  double, 1U> &in2, const coder::robotics::core::internal::
  DampedBFGSwGradientProjection *in3);
static void binary_expand_op_15(coder::array<bool, 1U> &in1, const coder::array<
  double, 1U> &in2, const coder::robotics::core::internal::
  DampedBFGSwGradientProjection *in3);
static void binary_expand_op_16(coder::array<double, 1U> &in1, const double
  in2_data[], const int in2_size[2]);
static void binary_expand_op_17(coder::array<double, 1U> &in1, const double
  in2_data[], const int in2_size[2], const coder::array<double, 1U> &in3);
static void binary_expand_op_18(coder::array<double, 1U> &in1, const double
  in2_data[], const int in2_size[2], const coder::array<double, 1U> &in3);
static void binary_expand_op_2(cell_wrap_58 in1[2], const coder::array<double,
  1U> &in3, const coder::array<double, 1U> &in5);
static void binary_expand_op_3(bool in1[6], const double in2[6], const coder::
  array<double, 2U> &in3);
static void binary_expand_op_4(bool in1[6], const double in2[6], const coder::
  array<double, 2U> &in3);
static double binary_expand_op_5(const coder::array<double, 1U> &in1, double in2,
  const coder::array<double, 1U> &in3, coder::robotics::core::internal::
  DampedBFGSwGradientProjection *in4, coder::array<double, 2U> &in5, coder::
  array<double, 2U> &in6, coder::robotics::manip::internal::GIKProblem **out2);
static void binary_expand_op_6(coder::array<double, 2U> &in1, double in2, const
  coder::array<double, 2U> &in3);
static void binary_expand_op_7(coder::array<double, 2U> &in1, const coder::array<
  double, 2U> &in2, const coder::array<double, 1U> &in3, double in4);
static void binary_expand_op_8(coder::array<double, 2U> &in1, const coder::array<
  double, 2U> &in2, const coder::array<double, 1U> &in3, const coder::array<
  double, 1U> &in4, double in5);
static void binary_expand_op_9(coder::array<double, 1U> &in1, double in2, const
  coder::array<double, 1U> &in3);
namespace coder
{
  static void axang2tform(const double axang_data[], double H[16]);
  static int b_eml_find(const bool x[6], int i_data[]);
  static double b_norm(const double x[3]);
  static double b_norm(const array<double, 1U> &x);
  static int b_rand(double varargin_1, double r_data[]);
  static void b_rand(double r[5]);
  static void b_randn(double r[3]);
  static void c_eml_find(const array<bool, 1U> &x, array<int, 1U> &i);
  static void c_rand(double r[3]);
  static void eigStandard(const double A[16], creal_T V[16], creal_T D[4]);
  static void eml_find(const array<bool, 2U> &x, array<int, 1U> &i, array<int,
                       1U> &j);
  static void eml_float_colon(double d, array<double, 2U> &y);
  namespace internal
  {
    static bool b_strcmp(const char a_data[], const int a_size[2], const array<
                         char, 2U> &b);
    static bool b_strcmp(const char a_data[], const int a_size[2], const char
                         b_data[], const int b_size[2]);
    namespace blas
    {
      static void b_mtimes(const array<double, 2U> &A, const array<double, 2U>
                           &B, array<double, 2U> &C);
      static double b_xnrm2(int n, const double x[9], int ix0);
      static void c_mtimes(const array<double, 2U> &A, const array<double, 2U>
                           &B, array<double, 2U> &C);
      static void mtimes(const array<double, 2U> &A, const array<double, 2U> &B,
                         array<double, 2U> &C);
      static void xaxpy(int n, double a, int ix0, array<double, 2U> &y, int iy0);
      static void xaxpy(int n, double a, const double x[16], int ix0, double y
                        [12]);
      static void xaxpy(int n, double a, const array<double, 2U> &x, int ix0,
                        array<double, 1U> &y, int iy0);
      static void xaxpy(int n, double a, const array<double, 1U> &x, int ix0,
                        array<double, 2U> &y, int iy0);
      static void xaxpy(int n, double a, int ix0, double y[9], int iy0);
      static void xaxpy(double a, const double x[3], double y[9], int iy0);
      static void xaxpy(double a, const double x[9], int ix0, double y[3]);
      static double xdotc(int n, const double x[9], int ix0, const double y[9],
                          int iy0);
      static void xgemv(int n, const double x[12], double beta1, double y[16],
                        int iy0);
      static double xnrm2(int n, const double x[3]);
      static double xnrm2(int n, const double x[16], int ix0);
      static double xnrm2(const double x[3]);
      static double xnrm2(int n, const array<double, 1U> &x, int ix0);
      static double xnrm2(int n, const array<double, 2U> &x, int ix0);
      static void xrot(double x[9], int ix0, int iy0, double c, double s);
      static double xrotg(double *a, double &b, double &s);
      static void xswap(double x[9], int ix0, int iy0);
    }

    static void expand_max(const array<double, 1U> &a, const array<double, 1U>
      &b, array<double, 1U> &c);
    static void expand_min(const array<double, 1U> &a, const array<double, 1U>
      &b, array<double, 1U> &c);
    namespace lapack
    {
      static void xgeqp3(array<double, 2U> &A, array<double, 1U> &tau, array<int,
                         2U> &jpvt);
    }

    static double maximum(const array<double, 1U> &x, int &idx);
    static double maximum(const double x[4], int &idx);
    static void merge(array<int, 1U> &idx, array<double, 1U> &x, int offset, int
                      np, int nq, array<int, 1U> &iwork, array<double, 1U>
                      &xwork);
    static void merge(int idx_data[], double x_data[], int offset, int np, int
                      nq, int iwork_data[], double xwork_data[]);
    static void merge_block(array<int, 1U> &idx, array<double, 1U> &x, int
      offset, int n, int preSortLevel, array<int, 1U> &iwork, array<double, 1U>
      &xwork);
    static double minimum(const array<double, 1U> &x, int &idx);
    namespace randfun
    {
      static double b_eml_rand_mt19937ar(unsigned int b_state[625]);
      static void eml_rand_mt19937ar(unsigned int b_state[625]);
      static void genrand_uint32_vector(unsigned int mt[625], unsigned int u[2]);
    }

    namespace reflapack
    {
      static void b_rotateRight(int n, double z[16], int iz0, const double cs[6],
        int ic0, int is0);
      static void b_xzlascl(double cfrom, double cto, double A[9]);
      static void b_xzlascl(double cfrom, double cto, int m, double A[3], int
                            iA0);
      static void rotateRight(int n, double z[16], int iz0, const double cs[6],
        int ic0, int is0);
      static double xdladiv(double a, double b, double c, double d, double &q);
      static double xdlaev2(double a, double b, double c, double &rt2, double
                            &cs1, double &sn1);
      static int xdlahqr(int ilo, int ihi, double h[16], int iloz, int ihiz,
                         double z[16], double wr[4], double wi[4]);
      static double xdlaln2(int na, int nw, double smin, const double A[16], int
                            ia0, const double B[12], int ib0, double wr, double
                            wi, double X[4], double &xnorm);
      static double xdlanv2(double &a, double &b, double &c, double &d, double
                            &rt1i, double &rt2r, double &rt2i, double &cs,
                            double &sn);
      static void xdtrevc3(const double T[16], double vr[16]);
      static int xzgebal(double A[16], int &ihi, double scale[4]);
      static void xzgehrd(double a[16], int ilo, int ihi, double tau[3]);
      static int xzgetrf(int m, int n, array<double, 2U> &A, int lda, array<int,
                         2U> &ipiv);
      static double xzlangeM(const double x[9]);
      static double xzlangeM(const array<double, 2U> &x);
      static void xzlarf(int m, int n, int iv0, double tau, double C[16], int
                         ic0, double work[4]);
      static double xzlarfg(int n, double &alpha1, double x[16], int ix0);
      static double xzlarfg(int n, double &alpha1, double x[3]);
      static double xzlartg(double f, double g, double &sn, double &r);
      static void xzlascl(double cfrom, double cto, double A[16]);
      static void xzlascl(double cfrom, double cto, int m, int n, array<double,
                          2U> &A, int lda);
      static void xzlascl(double cfrom, double cto, int m, array<double, 1U> &A);
      static void xzlascl(double cfrom, double cto, int m, double A[4], int iA0);
      static int xzsteqr(double d[4], double e[3], double z[16]);
      static void xzsvdc(array<double, 2U> &A, array<double, 1U> &S);
      static void xzunghr(int ilo, int ihi, double A[16], const double tau[3]);
    }

    namespace scalar
    {
      static double b_atan2(double y, double x);
      static void b_sqrt(creal_T &x);
    }

    static void sort(array<double, 1U> &x, array<int, 1U> &idx);
    static void sort(double x[24]);
    static void sort(double x_data[], const int x_size[2]);
    static void svd(const double A[9], double U[9], double s[3], double V[9]);
  }

  static void inv(const array<double, 2U> &x, array<double, 2U> &y);
  static void mldivide(const array<double, 2U> &A, const array<double, 2U> &B,
                       array<double, 2U> &Y);
  static void randn(double r[4]);
  static int randn(const double varargin_1[2], double r_data[]);
  static void repmat(const double a[6], double b[18]);
  static void repmat(double varargin_2, cell_wrap_41 b_data[], int b_size[2]);
  namespace robotics
  {
    namespace core
    {
      namespace internal
      {
        static void b_rotm2quat(const double R[9], double q[4]);
        static bool isPositiveDefinite(const array<double, 2U> &B);
      }
    }

    namespace internal
    {
      static void quat2rotm(const double q[4], double R[9]);
    }
  }

  static void rotm2eul(const double R[9], double eul[3]);
  static void rotm2quat(const double R[9], double quat[4]);
  static void sum(const array<double, 2U> &x, array<double, 1U> &y);
  static double tic(double &tstart_tv_nsec);
  static double toc(double tstart_tv_sec, double tstart_tv_nsec);
  static void validatestring(const char str_data[], const int str_size[2], char
    out_data[], int out_size[2]);
  static void validatestring(const char str[3], char out_data[], int out_size[2]);
}

static int div_s32(int numerator, int denominator);
static void eml_rand_mt19937ar_stateful_init();
static void minus(coder::array<double, 2U> &in1, const coder::array<double, 2U>
                  &in2);
static void minus(coder::array<double, 1U> &in1, const coder::array<double, 1U>
                  &in2);
static void plus(coder::array<double, 2U> &in1, const coder::array<double, 2U>
                 &in2);
static coder::rigidBodyTree *rbtForCodegen(coder::robotics::manip::internal::
  CollisionSet &iobj_0, coder::rigidBodyJoint &iobj_1, coder::robotics::manip::
  internal::RigidBody &iobj_2, coder::rigidBodyTree &iobj_3);

// Function Definitions
//
// Arguments    : void
// Return Type  : void
//
void CoderTimeAPI::callCoderClockGettime_init()
{
  freq_not_empty = false;
}

//
// Arguments    : rigidBody &bodyin
//                robotics::manip::internal::CollisionSet &iobj_0
//                rigidBodyJoint &iobj_1
//                robotics::manip::internal::RigidBody &iobj_2
// Return Type  : void
//
namespace coder
{
  void rigidBodyTree::addBody(rigidBody &bodyin, robotics::manip::internal::
    CollisionSet &iobj_0, rigidBodyJoint &iobj_1, robotics::manip::internal::
    RigidBody &iobj_2)
  {
    static const char b_cv[5]{ 'f', 'i', 'x', 'e', 'd' };

    rigidBodyJoint *jnt;
    robotics::manip::internal::CharacterVector b_obj;
    robotics::manip::internal::RigidBody *b_bodyin;
    robotics::manip::internal::RigidBody *body;
    robotics::manip::internal::b_RigidBodyTree *obj;
    double b_index;
    double pid;
    int obj_size[2];
    int loop_ub;
    char obj_data[200];
    bool b_bool;
    obj = TreeInternal;
    b_bodyin = bodyin.BodyInternal;
    b_obj = b_bodyin->NameInternal;
    if (b_obj.Length < 1.0) {
      loop_ub = 0;
    } else {
      loop_ub = static_cast<int>(b_obj.Length);
    }

    obj_size[0] = 1;
    obj_size[1] = loop_ub;
    if (loop_ub - 1 >= 0) {
      ::std::copy(&b_obj.Vector[0], &b_obj.Vector[loop_ub], &obj_data[0]);
    }

    obj->findBodyIndexByName(obj_data, obj_size);
    pid = obj->findBodyIndexByName();
    jnt = b_bodyin->JointInternal;
    b_obj = jnt->NameInternal;
    if (b_obj.Length < 1.0) {
      loop_ub = 0;
    } else {
      loop_ub = static_cast<int>(b_obj.Length);
    }

    obj_size[0] = 1;
    obj_size[1] = loop_ub;
    if (loop_ub - 1 >= 0) {
      ::std::copy(&b_obj.Vector[0], &b_obj.Vector[loop_ub], &obj_data[0]);
    }

    obj->findBodyIndexByJointName(obj_data, obj_size);
    b_index = obj->NumBodies + 1.0;
    body = b_bodyin->copy((&iobj_0)[0], (&iobj_1)[0], iobj_2);
    obj->Bodies[static_cast<int>(b_index) - 1] = body;
    body->Index = b_index;
    body->ParentIndex = pid;
    body->JointInternal->InTree = true;
    obj->NumBodies++;
    jnt = body->JointInternal;
    b_obj = jnt->TypeInternal;
    if (b_obj.Length < 1.0) {
      loop_ub = 0;
    } else {
      loop_ub = static_cast<int>(b_obj.Length);
    }

    b_bool = false;
    if (loop_ub == 5) {
      loop_ub = 0;
      int exitg1;
      do {
        exitg1 = 0;
        if (loop_ub < 5) {
          if (b_obj.Vector[loop_ub] != b_cv[loop_ub]) {
            exitg1 = 1;
          } else {
            loop_ub++;
          }
        } else {
          b_bool = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (!b_bool) {
      obj->NumNonFixedBodies++;
      jnt = body->JointInternal;
      loop_ub = static_cast<int>(body->Index) - 1;
      obj->PositionDoFMap[loop_ub] = obj->PositionNumber + 1.0;
      obj->PositionDoFMap[loop_ub + 12] = obj->PositionNumber +
        jnt->PositionNumber;
      jnt = body->JointInternal;
      loop_ub = static_cast<int>(body->Index) - 1;
      obj->VelocityDoFMap[loop_ub] = obj->VelocityNumber + 1.0;
      obj->VelocityDoFMap[loop_ub + 12] = obj->VelocityNumber +
        jnt->VelocityNumber;
    } else {
      loop_ub = static_cast<int>(body->Index);
      obj->PositionDoFMap[loop_ub - 1] = 0.0;
      obj->PositionDoFMap[loop_ub + 11] = -1.0;
      loop_ub = static_cast<int>(body->Index);
      obj->VelocityDoFMap[loop_ub - 1] = 0.0;
      obj->VelocityDoFMap[loop_ub + 11] = -1.0;
    }

    jnt = body->JointInternal;
    obj->PositionNumber += jnt->PositionNumber;
    jnt = body->JointInternal;
    obj->VelocityNumber += jnt->VelocityNumber;
  }

  //
  // Arguments    : const collisionCapsule *varargin_1
  // Return Type  : void
  //
  void rigidBody::addCollision(const collisionCapsule *varargin_1)
  {
    static const double a[16]{ -0.0175, 0.0, -0.9998, 0.0, 0.0, 1.0, 0.0, 0.0,
      0.9998, 0.0, -0.0175, 0.0, -0.03, 0.0, 0.1, 1.0 };

    void *geometryInternal;
    collisionCapsule lobj_0;
    robotics::manip::internal::CollisionGeometry collisionGeometry;
    robotics::manip::internal::CollisionSet *b_obj;
    robotics::manip::internal::RigidBody *obj;
    double poseTform[16];
    double y[16];
    double length;
    double radius;
    obj = BodyInternal;
    for (int i{0}; i < 16; i++) {
      poseTform[i] = varargin_1->PoseInternal[i];
    }

    for (int i{0}; i < 4; i++) {
      double d;
      double d1;
      radius = a[i];
      length = a[i + 4];
      d = a[i + 8];
      d1 = a[i + 12];
      for (int i1{0}; i1 < 4; i1++) {
        int i2;
        i2 = i1 << 2;
        y[i + i2] = ((radius * poseTform[i2] + length * poseTform[i2 + 1]) + d *
                     poseTform[i2 + 2]) + d1 * poseTform[i2 + 3];
      }
    }

    radius = varargin_1->RadiusInternal;
    length = varargin_1->LengthInternal;
    lobj_0.RadiusInternal = radius;
    lobj_0.LengthInternal = length;
    geometryInternal = collisioncodegen_makeCapsule(radius, length);
    lobj_0.GeometryInternal = geometryInternal;
    lobj_0.matlabCodegenIsDeleted = false;
    for (int i{0}; i < 16; i++) {
      poseTform[i] = varargin_1->PoseInternal[i];
    }

    ::std::copy(&poseTform[0], &poseTform[16], &lobj_0.PoseInternal[0]);
    geometryInternal = collisioncodegen_makeCapsule(radius, length);
    collisionGeometry.CollisionPrimitive = geometryInternal;
    ::std::copy(&y[0], &y[16], &collisionGeometry.LocalPose[0]);
    ::std::copy(&y[0], &y[16], &collisionGeometry.WorldPose[0]);
    collisionGeometry.MeshScale[0] = 1.0;
    collisionGeometry.MeshScale[1] = 1.0;
    collisionGeometry.MeshScale[2] = 1.0;
    b_obj = obj->CollisionsInternal;
    if (b_obj->Size < b_obj->MaxElements) {
      b_obj->Size++;
      b_obj->CollisionGeometries[static_cast<int>(b_obj->Size) - 1] =
        collisionGeometry;
    }
  }

  //
  // Arguments    : rigidBody &bodyin
  //                robotics::manip::internal::CollisionSet &iobj_0
  //                rigidBodyJoint &iobj_1
  //                robotics::manip::internal::RigidBody &iobj_2
  // Return Type  : void
  //
  void rigidBodyTree::b_addBody(rigidBody &bodyin, robotics::manip::internal::
    CollisionSet &iobj_0, rigidBodyJoint &iobj_1, robotics::manip::internal::
    RigidBody &iobj_2)
  {
    static const char b_cv[5]{ 'f', 'i', 'x', 'e', 'd' };

    rigidBodyJoint *jnt;
    robotics::manip::internal::CharacterVector b_obj;
    robotics::manip::internal::RigidBody *b_bodyin;
    robotics::manip::internal::RigidBody *body;
    robotics::manip::internal::b_RigidBodyTree *obj;
    double b_index;
    double pid;
    int obj_size[2];
    int loop_ub;
    char obj_data[200];
    bool b_bool;
    obj = TreeInternal;
    b_bodyin = bodyin.BodyInternal;
    b_obj = b_bodyin->NameInternal;
    if (b_obj.Length < 1.0) {
      loop_ub = 0;
    } else {
      loop_ub = static_cast<int>(b_obj.Length);
    }

    obj_size[0] = 1;
    obj_size[1] = loop_ub;
    if (loop_ub - 1 >= 0) {
      ::std::copy(&b_obj.Vector[0], &b_obj.Vector[loop_ub], &obj_data[0]);
    }

    obj->findBodyIndexByName(obj_data, obj_size);
    pid = obj->b_findBodyIndexByName();
    jnt = b_bodyin->JointInternal;
    b_obj = jnt->NameInternal;
    if (b_obj.Length < 1.0) {
      loop_ub = 0;
    } else {
      loop_ub = static_cast<int>(b_obj.Length);
    }

    obj_size[0] = 1;
    obj_size[1] = loop_ub;
    if (loop_ub - 1 >= 0) {
      ::std::copy(&b_obj.Vector[0], &b_obj.Vector[loop_ub], &obj_data[0]);
    }

    obj->findBodyIndexByJointName(obj_data, obj_size);
    b_index = obj->NumBodies + 1.0;
    body = b_bodyin->copy((&iobj_0)[0], (&iobj_1)[0], iobj_2);
    obj->Bodies[static_cast<int>(b_index) - 1] = body;
    body->Index = b_index;
    body->ParentIndex = pid;
    body->JointInternal->InTree = true;
    obj->NumBodies++;
    jnt = body->JointInternal;
    b_obj = jnt->TypeInternal;
    if (b_obj.Length < 1.0) {
      loop_ub = 0;
    } else {
      loop_ub = static_cast<int>(b_obj.Length);
    }

    b_bool = false;
    if (loop_ub == 5) {
      loop_ub = 0;
      int exitg1;
      do {
        exitg1 = 0;
        if (loop_ub < 5) {
          if (b_obj.Vector[loop_ub] != b_cv[loop_ub]) {
            exitg1 = 1;
          } else {
            loop_ub++;
          }
        } else {
          b_bool = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (!b_bool) {
      obj->NumNonFixedBodies++;
      jnt = body->JointInternal;
      loop_ub = static_cast<int>(body->Index) - 1;
      obj->PositionDoFMap[loop_ub] = obj->PositionNumber + 1.0;
      obj->PositionDoFMap[loop_ub + 12] = obj->PositionNumber +
        jnt->PositionNumber;
      jnt = body->JointInternal;
      loop_ub = static_cast<int>(body->Index) - 1;
      obj->VelocityDoFMap[loop_ub] = obj->VelocityNumber + 1.0;
      obj->VelocityDoFMap[loop_ub + 12] = obj->VelocityNumber +
        jnt->VelocityNumber;
    } else {
      loop_ub = static_cast<int>(body->Index);
      obj->PositionDoFMap[loop_ub - 1] = 0.0;
      obj->PositionDoFMap[loop_ub + 11] = -1.0;
      loop_ub = static_cast<int>(body->Index);
      obj->VelocityDoFMap[loop_ub - 1] = 0.0;
      obj->VelocityDoFMap[loop_ub + 11] = -1.0;
    }

    jnt = body->JointInternal;
    obj->PositionNumber += jnt->PositionNumber;
    jnt = body->JointInternal;
    obj->VelocityNumber += jnt->VelocityNumber;
  }

  //
  // Arguments    : const collisionCapsule *varargin_1
  // Return Type  : void
  //
  void rigidBody::b_addCollision(const collisionCapsule *varargin_1)
  {
    static const double a[16]{ 0.9848, 0.0, -0.1736, 0.0, 0.0, 1.0, 0.0, 0.0,
      0.1736, 0.0, 0.9848, 0.0, 0.02, 0.0, 0.17, 1.0 };

    void *geometryInternal;
    collisionCapsule lobj_0;
    robotics::manip::internal::CollisionGeometry collisionGeometry;
    robotics::manip::internal::CollisionSet *b_obj;
    robotics::manip::internal::RigidBody *obj;
    double poseTform[16];
    double y[16];
    double length;
    double radius;
    obj = BodyInternal;
    for (int i{0}; i < 16; i++) {
      poseTform[i] = varargin_1->PoseInternal[i];
    }

    for (int i{0}; i < 4; i++) {
      double d;
      double d1;
      radius = a[i];
      length = a[i + 4];
      d = a[i + 8];
      d1 = a[i + 12];
      for (int i1{0}; i1 < 4; i1++) {
        int i2;
        i2 = i1 << 2;
        y[i + i2] = ((radius * poseTform[i2] + length * poseTform[i2 + 1]) + d *
                     poseTform[i2 + 2]) + d1 * poseTform[i2 + 3];
      }
    }

    radius = varargin_1->RadiusInternal;
    length = varargin_1->LengthInternal;
    lobj_0.RadiusInternal = radius;
    lobj_0.LengthInternal = length;
    geometryInternal = collisioncodegen_makeCapsule(radius, length);
    lobj_0.GeometryInternal = geometryInternal;
    lobj_0.matlabCodegenIsDeleted = false;
    for (int i{0}; i < 16; i++) {
      poseTform[i] = varargin_1->PoseInternal[i];
    }

    ::std::copy(&poseTform[0], &poseTform[16], &lobj_0.PoseInternal[0]);
    geometryInternal = collisioncodegen_makeCapsule(radius, length);
    collisionGeometry.CollisionPrimitive = geometryInternal;
    ::std::copy(&y[0], &y[16], &collisionGeometry.LocalPose[0]);
    ::std::copy(&y[0], &y[16], &collisionGeometry.WorldPose[0]);
    collisionGeometry.MeshScale[0] = 1.0;
    collisionGeometry.MeshScale[1] = 1.0;
    collisionGeometry.MeshScale[2] = 1.0;
    b_obj = obj->CollisionsInternal;
    if (b_obj->Size < b_obj->MaxElements) {
      b_obj->Size++;
      b_obj->CollisionGeometries[static_cast<int>(b_obj->Size) - 1] =
        collisionGeometry;
    }
  }

  //
  // Arguments    : const double varargin_1[6]
  //                double T[16]
  // Return Type  : void
  //
  void rigidBodyTree::b_getTransform(const double varargin_1[6], double T[16])
  {
    robotics::manip::internal::CharacterVector b_obj;
    robotics::manip::internal::RigidBody *c_obj;
    robotics::manip::internal::b_RigidBodyTree *obj;
    cell_wrap_41 Ttree_data[12];
    double T1[16];
    double T2[16];
    double R[9];
    double b_R[9];
    double c_R[3];
    double bid2;
    int Ttree_size[2];
    int bid1;
    int exitg1;
    int i;
    int kstr;
    bool b_bool;
    obj = TreeInternal;
    obj->forwardKinematics(varargin_1, Ttree_data, Ttree_size);
    bid1 = -2;
    b_obj = obj->Base.NameInternal;
    if (b_obj.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(b_obj.Length);
    }

    b_bool = false;
    if (i == 10) {
      kstr = 0;
      do {
        exitg1 = 0;
        if (kstr < 10) {
          if (b_obj.Vector[kstr] != cv3[kstr]) {
            exitg1 = 1;
          } else {
            kstr++;
          }
        } else {
          b_bool = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (b_bool) {
      bid1 = -1;
    } else {
      int b_i;
      bool exitg2;
      bid2 = obj->NumBodies;
      b_i = 0;
      exitg2 = false;
      while ((!exitg2) && (b_i <= static_cast<int>(bid2) - 1)) {
        c_obj = obj->Bodies[b_i];
        b_obj = c_obj->NameInternal;
        if (b_obj.Length < 1.0) {
          i = 0;
        } else {
          i = static_cast<int>(b_obj.Length);
        }

        b_bool = false;
        if (i == 10) {
          kstr = 0;
          do {
            exitg1 = 0;
            if (kstr < 10) {
              if (b_obj.Vector[kstr] != cv3[kstr]) {
                exitg1 = 1;
              } else {
                kstr++;
              }
            } else {
              b_bool = true;
              exitg1 = 1;
            }
          } while (exitg1 == 0);
        }

        if (b_bool) {
          bid1 = b_i;
          exitg2 = true;
        } else {
          b_i++;
        }
      }
    }

    if (bid1 + 1 == 0) {
      std::memset(&T1[0], 0, 16U * sizeof(double));
      T1[0] = 1.0;
      T1[5] = 1.0;
      T1[10] = 1.0;
      T1[15] = 1.0;
    } else {
      ::std::copy(&Ttree_data[bid1].f1[0], &Ttree_data[bid1].f1[16], &T1[0]);
    }

    bid2 = obj->b_findBodyIndexByName();
    if (bid2 == 0.0) {
      std::memset(&T2[0], 0, 16U * sizeof(double));
      T2[0] = 1.0;
      T2[5] = 1.0;
      T2[10] = 1.0;
      T2[15] = 1.0;
    } else {
      for (i = 0; i < 16; i++) {
        T2[i] = Ttree_data[static_cast<int>(bid2) - 1].f1[i];
      }
    }

    for (i = 0; i < 3; i++) {
      R[3 * i] = T2[i];
      R[3 * i + 1] = T2[i + 4];
      R[3 * i + 2] = T2[i + 8];
    }

    for (i = 0; i < 9; i++) {
      b_R[i] = -R[i];
    }

    for (i = 0; i < 3; i++) {
      bid2 = b_R[i] * T2[12];
      kstr = i << 2;
      T2[kstr] = R[3 * i];
      bid2 += b_R[i + 3] * T2[13];
      T2[kstr + 1] = R[3 * i + 1];
      bid2 += b_R[i + 6] * T2[14];
      T2[kstr + 2] = R[3 * i + 2];
      c_R[i] = bid2;
    }

    T2[12] = c_R[0];
    T2[13] = c_R[1];
    T2[14] = c_R[2];
    T2[3] = 0.0;
    T2[7] = 0.0;
    T2[11] = 0.0;
    T2[15] = 1.0;
    for (i = 0; i < 4; i++) {
      double d;
      double d1;
      double d2;
      bid2 = T2[i];
      d = T2[i + 4];
      d1 = T2[i + 8];
      d2 = T2[i + 12];
      for (bid1 = 0; bid1 < 4; bid1++) {
        kstr = bid1 << 2;
        T[i + kstr] = ((bid2 * T1[kstr] + d * T1[kstr + 1]) + d1 * T1[kstr + 2])
          + d2 * T1[kstr + 3];
      }
    }
  }

  //
  // Arguments    : void
  // Return Type  : constraintPositionTarget *
  //
  constraintPositionTarget *constraintPositionTarget::b_init()
  {
    constraintPositionTarget *obj;
    obj = this;
    obj->ConstructorPropertyDefaultValues.f2[0] = 0.0;
    obj->ConstructorPropertyDefaultValues.f2[1] = 0.0;
    obj->ConstructorPropertyDefaultValues.f2[2] = 0.0;
    obj->ConstructorPropertyDefaultValues.f3 = 0.0;
    obj->ConstructorPropertyDefaultValues.f4 = 1.0;
    for (int i{0}; i < 9; i++) {
      obj->EndEffector[i] = cv5[i];
    }

    double d;
    double defaultValues_f3;
    double defaultValues_f4;
    defaultValues_f3 = obj->ConstructorPropertyDefaultValues.f3;
    defaultValues_f4 = obj->ConstructorPropertyDefaultValues.f4;
    obj->ReferenceBody.set_size(0, 0);
    d = obj->ConstructorPropertyDefaultValues.f2[0];
    obj->TargetPosition[0] = d;
    d = obj->ConstructorPropertyDefaultValues.f2[1];
    obj->TargetPosition[1] = d;
    d = obj->ConstructorPropertyDefaultValues.f2[2];
    obj->TargetPosition[2] = d;
    obj->PositionTolerance = defaultValues_f3;
    obj->Weights = defaultValues_f4;
    return obj;
  }

  //
  // Arguments    : robotics::manip::internal::RigidBodyTree &iobj_0
  //                robotics::manip::internal::CollisionSet &iobj_1
  //                rigidBodyJoint &iobj_2
  //                robotics::manip::internal::RigidBody &iobj_3
  // Return Type  : rigidBody *
  //
  rigidBody *rigidBody::b_init(robotics::manip::internal::RigidBodyTree &iobj_0,
    robotics::manip::internal::CollisionSet &iobj_1, rigidBodyJoint &iobj_2,
    robotics::manip::internal::RigidBody &iobj_3)
  {
    static const char b_cv1[10]{ 'b', 'o', 'd', 'y', 'A', '1', '_', 'j', 'n',
      't' };

    static const char b_cv3[8]{ 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };

    static const char b_cv4[8]{ 'f', 'l', 'o', 'a', 't', 'i', 'n', 'g' };

    static const signed char iv2[7]{ 1, 0, 0, 0, 0, 0, 0 };

    static const char b_cv[6]{ 'b', 'o', 'd', 'y', 'A', '1' };

    static const signed char b_iv[6]{ 0, 0, 1, 0, 0, 0 };

    static const signed char b_iv1[6]{ 0, 0, 0, 0, 0, 1 };

    static const char b_cv2[5]{ 'f', 'i', 'x', 'e', 'd' };

    static const char b_cv5[5]{ 'f', 'i', 'x', 'e', 'd' };

    rigidBody *obj;
    robotics::manip::internal::CharacterVector s;
    robotics::manip::internal::RigidBodyTree *b_default;
    double msubspace_data[36];
    double poslim_data[14];
    int exitg1;
    int homepos_size_idx_1;
    int i;
    int i1;
    int ibmat;
    int poslim_size_idx_0;
    signed char b_I[36];
    signed char c_I[9];
    signed char homepos_data[7];
    bool result;
    obj = this;
    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    iobj_3.NameInternal = s;
    s = iobj_3.NameInternal;
    s.Length = 6.0;
    for (i = 0; i < 6; i++) {
      s.Vector[i] = b_cv[i];
    }

    iobj_3.NameInternal = s;
    iobj_2.InTree = false;
    for (i = 0; i < 16; i++) {
      i1 = iv[i];
      iobj_2.JointToParentTransform[i] = i1;
      iobj_2.ChildToJointTransform[i] = i1;
    }

    for (i = 0; i < 14; i++) {
      iobj_2.PositionLimitsInternal[i] = 0.0;
    }

    for (i = 0; i < 7; i++) {
      iobj_2.HomePositionInternal[i] = 0.0;
    }

    for (i = 0; i < 36; i++) {
      iobj_2.MotionSubspaceInternal[i] = 0.0;
    }

    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    iobj_2.NameInternal = s;
    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    iobj_2.TypeInternal = s;
    s = iobj_2.NameInternal;
    s.Length = 10.0;
    for (i = 0; i < 10; i++) {
      s.Vector[i] = b_cv1[i];
    }

    iobj_2.NameInternal = s;
    s = iobj_2.TypeInternal;
    s.Length = 5.0;
    for (i = 0; i < 5; i++) {
      s.Vector[i] = b_cv2[i];
    }

    iobj_2.TypeInternal = s;
    s = iobj_2.TypeInternal;
    if (s.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(s.Length);
    }

    result = false;
    if (i == 8) {
      ibmat = 0;
      do {
        exitg1 = 0;
        if (ibmat < 8) {
          if (b_cv3[ibmat] != s.Vector[ibmat]) {
            exitg1 = 1;
          } else {
            ibmat++;
          }
        } else {
          result = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (result) {
      ibmat = 0;
    } else {
      result = false;
      if (i == 9) {
        ibmat = 0;
        do {
          exitg1 = 0;
          if (ibmat < 9) {
            if (cv1[ibmat] != s.Vector[ibmat]) {
              exitg1 = 1;
            } else {
              ibmat++;
            }
          } else {
            result = true;
            exitg1 = 1;
          }
        } while (exitg1 == 0);
      }

      if (result) {
        ibmat = 1;
      } else {
        result = false;
        if (i == 8) {
          ibmat = 0;
          do {
            exitg1 = 0;
            if (ibmat < 8) {
              if (b_cv4[ibmat] != s.Vector[ibmat]) {
                exitg1 = 1;
              } else {
                ibmat++;
              }
            } else {
              result = true;
              exitg1 = 1;
            }
          } while (exitg1 == 0);
        }

        if (result) {
          ibmat = 2;
        } else {
          ibmat = -1;
        }
      }
    }

    switch (ibmat) {
     case 0:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = b_iv[i];
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = -3.1415926535897931;
      poslim_data[1] = 3.1415926535897931;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      iobj_2.VelocityNumber = 1.0;
      iobj_2.PositionNumber = 1.0;
      iobj_2.JointAxisInternal[0] = 0.0;
      iobj_2.JointAxisInternal[1] = 0.0;
      iobj_2.JointAxisInternal[2] = 1.0;
      break;

     case 1:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = b_iv1[i];
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = -0.5;
      poslim_data[1] = 0.5;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      iobj_2.VelocityNumber = 1.0;
      iobj_2.PositionNumber = 1.0;
      iobj_2.JointAxisInternal[0] = 0.0;
      iobj_2.JointAxisInternal[1] = 0.0;
      iobj_2.JointAxisInternal[2] = 1.0;
      break;

     case 2:
      {
        signed char b[6];
        for (i = 0; i < 36; i++) {
          b_I[i] = 0;
        }

        for (ibmat = 0; ibmat < 6; ibmat++) {
          b_I[ibmat + 6 * ibmat] = 1;
        }

        for (i = 0; i < 36; i++) {
          msubspace_data[i] = b_I[i];
        }

        poslim_size_idx_0 = 7;
        for (homepos_size_idx_1 = 0; homepos_size_idx_1 < 2; homepos_size_idx_1
             ++) {
          signed char b_tmp;
          ibmat = homepos_size_idx_1 * 3;
          b_tmp = static_cast<signed char>(10 * homepos_size_idx_1 - 5);
          b[ibmat] = b_tmp;
          b[ibmat + 1] = b_tmp;
          b[ibmat + 2] = b_tmp;
          poslim_data[7 * homepos_size_idx_1] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 1] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 2] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 3] = rtNaN;
        }

        for (i = 0; i < 2; i++) {
          poslim_data[7 * i + 4] = b[3 * i];
          poslim_data[7 * i + 5] = b[3 * i + 1];
          poslim_data[7 * i + 6] = b[3 * i + 2];
        }

        homepos_size_idx_1 = 7;
        for (i = 0; i < 7; i++) {
          homepos_data[i] = iv2[i];
        }

        iobj_2.VelocityNumber = 6.0;
        iobj_2.PositionNumber = 7.0;
        iobj_2.JointAxisInternal[0] = rtNaN;
        iobj_2.JointAxisInternal[1] = rtNaN;
        iobj_2.JointAxisInternal[2] = rtNaN;
      }
      break;

     default:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = 0.0;
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = 0.0;
      poslim_data[1] = 0.0;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      iobj_2.VelocityNumber = 0.0;
      iobj_2.PositionNumber = 0.0;
      iobj_2.JointAxisInternal[0] = 0.0;
      iobj_2.JointAxisInternal[1] = 0.0;
      iobj_2.JointAxisInternal[2] = 0.0;
      break;
    }

    iobj_2.set_MotionSubspace(msubspace_data);
    s = iobj_2.TypeInternal;
    if (s.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(s.Length);
    }

    result = false;
    if (i == 5) {
      ibmat = 0;
      do {
        exitg1 = 0;
        if (ibmat < 5) {
          if (s.Vector[ibmat] != b_cv5[ibmat]) {
            exitg1 = 1;
          } else {
            ibmat++;
          }
        } else {
          result = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (!result) {
      double d;
      d = iobj_2.PositionNumber;
      if (d < 1.0) {
        ibmat = 0;
      } else {
        ibmat = static_cast<int>(d);
      }

      for (i = 0; i < 2; i++) {
        for (i1 = 0; i1 < ibmat; i1++) {
          iobj_2.PositionLimitsInternal[i1 + 7 * i] = poslim_data[i1 +
            poslim_size_idx_0 * i];
        }
      }

      for (i = 0; i < homepos_size_idx_1; i++) {
        iobj_2.HomePositionInternal[i] = homepos_data[i];
      }
    } else {
      iobj_2.PositionLimitsInternal[0] = poslim_data[0];
      iobj_2.PositionLimitsInternal[7] = poslim_data[1];
      iobj_2.HomePositionInternal[0] = homepos_data[0];
    }

    iobj_3.JointInternal = &iobj_2;
    iobj_3.Index = -1.0;
    iobj_3.ParentIndex = -1.0;
    iobj_3.MassInternal = 1.0;
    iobj_3.CenterOfMassInternal[0] = 0.0;
    iobj_3.CenterOfMassInternal[1] = 0.0;
    iobj_3.CenterOfMassInternal[2] = 0.0;
    for (i = 0; i < 9; i++) {
      c_I[i] = 0;
    }

    c_I[0] = 1;
    c_I[4] = 1;
    c_I[8] = 1;
    for (i = 0; i < 9; i++) {
      iobj_3.InertiaInternal[i] = c_I[i];
    }

    for (i = 0; i < 36; i++) {
      b_I[i] = 0;
    }

    for (ibmat = 0; ibmat < 6; ibmat++) {
      b_I[ibmat + 6 * ibmat] = 1;
    }

    for (i = 0; i < 36; i++) {
      iobj_3.SpatialInertia[i] = b_I[i];
    }

    iobj_3.CollisionsInternal = (&iobj_1)[0].init(static_cast<double>(0.0));
    iobj_3.matlabCodegenIsDeleted = false;
    b_default = iobj_0.init();
    iobj_3.CollisionsInternal = (&iobj_1)[1].init(1.0);
    obj->BodyInternal = &iobj_3;
    obj->TreeInternal = b_default;
    obj->matlabCodegenIsDeleted = false;
    return obj;
  }

  //
  // Arguments    : void
  // Return Type  : collisionCapsule *
  //
  collisionCapsule *collisionCapsule::b_init()
  {
    void *geometryInternal;
    collisionCapsule *obj;
    obj = this;
    for (int i{0}; i < 16; i++) {
      obj->PoseInternal[i] = iv[i];
    }

    obj->RadiusInternal = 0.15;
    obj->LengthInternal = 0.13;
    geometryInternal = collisioncodegen_makeCapsule(0.15, 0.13);
    obj->GeometryInternal = geometryInternal;
    obj->matlabCodegenIsDeleted = false;
    return obj;
  }

  //
  // Arguments    : void
  // Return Type  : rigidBodyJoint *
  //
  rigidBodyJoint *rigidBodyJoint::b_init()
  {
    static const char b_cv2[8]{ 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };

    static const char b_cv3[8]{ 'f', 'l', 'o', 'a', 't', 'i', 'n', 'g' };

    static const char b_cv[7]{ 'j', 'n', 't', 'B', 'a', 's', 'e' };

    static const signed char iv2[7]{ 1, 0, 0, 0, 0, 0, 0 };

    static const signed char b_iv[6]{ 0, 0, 1, 0, 0, 0 };

    static const signed char b_iv1[6]{ 0, 0, 0, 0, 0, 1 };

    static const char b_cv1[5]{ 'f', 'i', 'x', 'e', 'd' };

    static const char b_cv4[5]{ 'f', 'i', 'x', 'e', 'd' };

    rigidBodyJoint *obj;
    robotics::manip::internal::CharacterVector s;
    double msubspace_data[36];
    double poslim_data[14];
    int exitg1;
    int homepos_size_idx_1;
    int i;
    int ibmat;
    int poslim_size_idx_0;
    signed char homepos_data[7];
    signed char b_tmp;
    bool result;
    obj = this;
    obj->InTree = false;
    for (i = 0; i < 16; i++) {
      b_tmp = iv[i];
      obj->JointToParentTransform[i] = b_tmp;
      obj->ChildToJointTransform[i] = b_tmp;
    }

    for (i = 0; i < 14; i++) {
      obj->PositionLimitsInternal[i] = 0.0;
    }

    for (i = 0; i < 7; i++) {
      obj->HomePositionInternal[i] = 0.0;
    }

    for (i = 0; i < 36; i++) {
      obj->MotionSubspaceInternal[i] = 0.0;
    }

    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    obj->NameInternal = s;
    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    obj->TypeInternal = s;
    s = obj->NameInternal;
    s.Length = 7.0;
    for (i = 0; i < 7; i++) {
      s.Vector[i] = b_cv[i];
    }

    obj->NameInternal = s;
    s = obj->TypeInternal;
    s.Length = 5.0;
    for (i = 0; i < 5; i++) {
      s.Vector[i] = b_cv1[i];
    }

    obj->TypeInternal = s;
    s = obj->TypeInternal;
    if (s.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(s.Length);
    }

    result = false;
    if (i == 8) {
      ibmat = 0;
      do {
        exitg1 = 0;
        if (ibmat < 8) {
          if (b_cv2[ibmat] != s.Vector[ibmat]) {
            exitg1 = 1;
          } else {
            ibmat++;
          }
        } else {
          result = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (result) {
      ibmat = 0;
    } else {
      result = false;
      if (i == 9) {
        ibmat = 0;
        do {
          exitg1 = 0;
          if (ibmat < 9) {
            if (cv1[ibmat] != s.Vector[ibmat]) {
              exitg1 = 1;
            } else {
              ibmat++;
            }
          } else {
            result = true;
            exitg1 = 1;
          }
        } while (exitg1 == 0);
      }

      if (result) {
        ibmat = 1;
      } else {
        result = false;
        if (i == 8) {
          ibmat = 0;
          do {
            exitg1 = 0;
            if (ibmat < 8) {
              if (b_cv3[ibmat] != s.Vector[ibmat]) {
                exitg1 = 1;
              } else {
                ibmat++;
              }
            } else {
              result = true;
              exitg1 = 1;
            }
          } while (exitg1 == 0);
        }

        if (result) {
          ibmat = 2;
        } else {
          ibmat = -1;
        }
      }
    }

    switch (ibmat) {
     case 0:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = b_iv[i];
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = -3.1415926535897931;
      poslim_data[1] = 3.1415926535897931;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      obj->VelocityNumber = 1.0;
      obj->PositionNumber = 1.0;
      obj->JointAxisInternal[0] = 0.0;
      obj->JointAxisInternal[1] = 0.0;
      obj->JointAxisInternal[2] = 1.0;
      break;

     case 1:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = b_iv1[i];
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = -0.5;
      poslim_data[1] = 0.5;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      obj->VelocityNumber = 1.0;
      obj->PositionNumber = 1.0;
      obj->JointAxisInternal[0] = 0.0;
      obj->JointAxisInternal[1] = 0.0;
      obj->JointAxisInternal[2] = 1.0;
      break;

     case 2:
      {
        signed char b_I[36];
        signed char b[6];
        for (i = 0; i < 36; i++) {
          b_I[i] = 0;
        }

        for (ibmat = 0; ibmat < 6; ibmat++) {
          b_I[ibmat + 6 * ibmat] = 1;
        }

        for (i = 0; i < 36; i++) {
          msubspace_data[i] = b_I[i];
        }

        poslim_size_idx_0 = 7;
        for (homepos_size_idx_1 = 0; homepos_size_idx_1 < 2; homepos_size_idx_1
             ++) {
          ibmat = homepos_size_idx_1 * 3;
          b_tmp = static_cast<signed char>(10 * homepos_size_idx_1 - 5);
          b[ibmat] = b_tmp;
          b[ibmat + 1] = b_tmp;
          b[ibmat + 2] = b_tmp;
          poslim_data[7 * homepos_size_idx_1] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 1] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 2] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 3] = rtNaN;
        }

        for (i = 0; i < 2; i++) {
          poslim_data[7 * i + 4] = b[3 * i];
          poslim_data[7 * i + 5] = b[3 * i + 1];
          poslim_data[7 * i + 6] = b[3 * i + 2];
        }

        homepos_size_idx_1 = 7;
        for (i = 0; i < 7; i++) {
          homepos_data[i] = iv2[i];
        }

        obj->VelocityNumber = 6.0;
        obj->PositionNumber = 7.0;
        obj->JointAxisInternal[0] = rtNaN;
        obj->JointAxisInternal[1] = rtNaN;
        obj->JointAxisInternal[2] = rtNaN;
      }
      break;

     default:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = 0.0;
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = 0.0;
      poslim_data[1] = 0.0;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      obj->VelocityNumber = 0.0;
      obj->PositionNumber = 0.0;
      obj->JointAxisInternal[0] = 0.0;
      obj->JointAxisInternal[1] = 0.0;
      obj->JointAxisInternal[2] = 0.0;
      break;
    }

    obj->set_MotionSubspace(msubspace_data);
    s = obj->TypeInternal;
    if (s.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(s.Length);
    }

    result = false;
    if (i == 5) {
      ibmat = 0;
      do {
        exitg1 = 0;
        if (ibmat < 5) {
          if (s.Vector[ibmat] != b_cv4[ibmat]) {
            exitg1 = 1;
          } else {
            ibmat++;
          }
        } else {
          result = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (!result) {
      double d;
      d = obj->PositionNumber;
      if (d < 1.0) {
        ibmat = 0;
      } else {
        ibmat = static_cast<int>(d);
      }

      for (i = 0; i < 2; i++) {
        for (int i1{0}; i1 < ibmat; i1++) {
          obj->PositionLimitsInternal[i1 + 7 * i] = poslim_data[i1 +
            poslim_size_idx_0 * i];
        }
      }

      for (i = 0; i < homepos_size_idx_1; i++) {
        obj->HomePositionInternal[i] = homepos_data[i];
      }
    } else {
      obj->PositionLimitsInternal[0] = poslim_data[0];
      obj->PositionLimitsInternal[7] = poslim_data[1];
      obj->HomePositionInternal[0] = homepos_data[0];
    }

    return obj;
  }

  //
  // Arguments    : void
  // Return Type  : void
  //
  void rigidBodyJoint::b_setFixedTransform()
  {
    static const double inputTform[16]{ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0,
      0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.223, 1.0 };

    for (int i{0}; i < 16; i++) {
      JointToParentTransform[i] = inputTform[i];
      ChildToJointTransform[i] = 0.0;
    }

    ChildToJointTransform[0] = 1.0;
    ChildToJointTransform[5] = 1.0;
    ChildToJointTransform[10] = 1.0;
    ChildToJointTransform[15] = 1.0;
  }

  //
  // Arguments    : void
  // Return Type  : void
  //
  void rigidBodyJoint::b_set_HomePosition()
  {
    double d;
    int loop_ub;
    d = PositionNumber;
    if (d < 1.0) {
      loop_ub = 0;
    } else {
      loop_ub = static_cast<int>(d);
    }

    for (int i{0}; i < loop_ub; i++) {
      HomePositionInternal[i] = 1.570796326794897;
    }
  }

  //
  // Arguments    : void
  // Return Type  : void
  //
  void rigidBodyJoint::b_set_JointAxis()
  {
    static const double dv[6]{ 0.0, 0.0, 0.0, 0.0, -1.0, 0.0 };

    static const double dv1[6]{ 0.0, -1.0, 0.0, 0.0, 0.0, 0.0 };

    static const char b_cv[8]{ 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };

    int i;
    bool result;
    JointAxisInternal[0] = 0.0;
    JointAxisInternal[1] = -1.0;
    JointAxisInternal[2] = 0.0;
    if (TypeInternal.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(TypeInternal.Length);
    }

    result = false;
    if (i == 8) {
      i = 0;
      int exitg1;
      do {
        exitg1 = 0;
        if (i < 8) {
          if (b_cv[i] != TypeInternal.Vector[i]) {
            exitg1 = 1;
          } else {
            i++;
          }
        } else {
          result = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (result) {
      i = 0;
    } else {
      i = -1;
    }

    if (i == 0) {
      b_set_MotionSubspace(dv1);
    } else {
      b_set_MotionSubspace(dv);
    }
  }

  //
  // Arguments    : const double msubspace[6]
  // Return Type  : void
  //
  void rigidBodyJoint::b_set_MotionSubspace(const double msubspace[6])
  {
    static const char b_cv[5]{ 'f', 'i', 'x', 'e', 'd' };

    int i;
    int kstr;
    bool b_bool;
    if (TypeInternal.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(TypeInternal.Length);
    }

    b_bool = false;
    if (i == 5) {
      kstr = 0;
      int exitg1;
      do {
        exitg1 = 0;
        if (kstr < 5) {
          if (TypeInternal.Vector[kstr] != b_cv[kstr]) {
            exitg1 = 1;
          } else {
            kstr++;
          }
        } else {
          b_bool = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (!b_bool) {
      double d;
      d = VelocityNumber;
      if (d < 1.0) {
        kstr = 0;
      } else {
        kstr = static_cast<int>(d);
      }

      for (i = 0; i < kstr; i++) {
        for (int i1{0}; i1 < 6; i1++) {
          int i2;
          i2 = i1 + 6 * i;
          MotionSubspaceInternal[i2] = msubspace[i2];
        }
      }
    } else {
      for (i = 0; i < 6; i++) {
        MotionSubspaceInternal[i] = 0.0;
      }
    }
  }

  //
  // Arguments    : void
  // Return Type  : void
  //
  void rigidBodyJoint::b_set_PositionLimits()
  {
    array<bool, 1U> x;
    double dv[2];
    double d;
    int ix;
    int loop_ub;
    bool resetHome;
    resetHome = false;
    switch (static_cast<int>(PositionNumber)) {
     case 0:
     case 7:
      break;

     default:
      {
        bool exitg1;
        bool y;
        d = PositionNumber;
        if (d < 1.0) {
          loop_ub = 0;
        } else {
          loop_ub = static_cast<int>(d);
        }

        x.set_size(loop_ub);
        for (ix = 0; ix < loop_ub; ix++) {
          x[ix] = (HomePositionInternal[ix] > 3.1415926535897931);
        }

        y = false;
        ix = 1;
        exitg1 = false;
        while ((!exitg1) && (ix <= x.size(0))) {
          if (x[ix - 1]) {
            y = true;
            exitg1 = true;
          } else {
            ix++;
          }
        }

        if (y) {
          resetHome = true;
        } else {
          x.set_size(loop_ub);
          for (ix = 0; ix < loop_ub; ix++) {
            x[ix] = (HomePositionInternal[ix] < -0.95993108859688125);
          }

          y = false;
          ix = 1;
          exitg1 = false;
          while ((!exitg1) && (ix <= x.size(0))) {
            if (x[ix - 1]) {
              y = true;
              exitg1 = true;
            } else {
              ix++;
            }
          }

          if (y) {
            resetHome = true;
          }
        }
      }
      break;
    }

    d = PositionNumber;
    dv[0] = -0.95993108859688125;
    dv[1] = 3.1415926535897931;
    if (d < 1.0) {
      loop_ub = 0;
    } else {
      loop_ub = static_cast<int>(d);
    }

    for (ix = 0; ix < 2; ix++) {
      for (int i{0}; i < loop_ub; i++) {
        PositionLimitsInternal[i + 7 * ix] = dv[i + loop_ub * ix];
      }
    }

    if (resetHome) {
      resetHomePosition();
    }
  }

  //
  // Arguments    : rigidBody &bodyin
  //                robotics::manip::internal::CollisionSet &iobj_0
  //                rigidBodyJoint &iobj_1
  //                robotics::manip::internal::RigidBody &iobj_2
  // Return Type  : void
  //
  void rigidBodyTree::c_addBody(rigidBody &bodyin, robotics::manip::internal::
    CollisionSet &iobj_0, rigidBodyJoint &iobj_1, robotics::manip::internal::
    RigidBody &iobj_2)
  {
    static const char b_cv[6]{ 'b', 'o', 'd', 'y', 'A', '1' };

    static const char b_cv1[5]{ 'f', 'i', 'x', 'e', 'd' };

    rigidBodyJoint *jnt;
    robotics::manip::internal::CharacterVector b_obj;
    robotics::manip::internal::RigidBody *b_bodyin;
    robotics::manip::internal::RigidBody *body;
    robotics::manip::internal::b_RigidBodyTree *obj;
    double b_index;
    int obj_size[2];
    int exitg1;
    int loop_ub;
    int pid;
    char obj_data[200];
    bool b_bool;
    obj = TreeInternal;
    b_bodyin = bodyin.BodyInternal;
    b_obj = b_bodyin->NameInternal;
    if (b_obj.Length < 1.0) {
      loop_ub = 0;
    } else {
      loop_ub = static_cast<int>(b_obj.Length);
    }

    obj_size[0] = 1;
    obj_size[1] = loop_ub;
    if (loop_ub - 1 >= 0) {
      ::std::copy(&b_obj.Vector[0], &b_obj.Vector[loop_ub], &obj_data[0]);
    }

    obj->findBodyIndexByName(obj_data, obj_size);
    pid = -1;
    b_obj = obj->Base.NameInternal;
    if (b_obj.Length < 1.0) {
      loop_ub = 0;
    } else {
      loop_ub = static_cast<int>(b_obj.Length);
    }

    b_bool = false;
    if (loop_ub == 6) {
      loop_ub = 0;
      do {
        exitg1 = 0;
        if (loop_ub < 6) {
          if (b_obj.Vector[loop_ub] != b_cv[loop_ub]) {
            exitg1 = 1;
          } else {
            loop_ub++;
          }
        } else {
          b_bool = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (b_bool) {
      pid = 0;
    } else {
      int i;
      bool exitg2;
      b_index = obj->NumBodies;
      i = 0;
      exitg2 = false;
      while ((!exitg2) && (i <= static_cast<int>(b_index) - 1)) {
        body = obj->Bodies[i];
        b_obj = body->NameInternal;
        if (b_obj.Length < 1.0) {
          loop_ub = 0;
        } else {
          loop_ub = static_cast<int>(b_obj.Length);
        }

        b_bool = false;
        if (loop_ub == 6) {
          loop_ub = 0;
          do {
            exitg1 = 0;
            if (loop_ub < 6) {
              if (b_obj.Vector[loop_ub] != b_cv[loop_ub]) {
                exitg1 = 1;
              } else {
                loop_ub++;
              }
            } else {
              b_bool = true;
              exitg1 = 1;
            }
          } while (exitg1 == 0);
        }

        if (b_bool) {
          pid = i + 1;
          exitg2 = true;
        } else {
          i++;
        }
      }
    }

    jnt = b_bodyin->JointInternal;
    b_obj = jnt->NameInternal;
    if (b_obj.Length < 1.0) {
      loop_ub = 0;
    } else {
      loop_ub = static_cast<int>(b_obj.Length);
    }

    obj_size[0] = 1;
    obj_size[1] = loop_ub;
    if (loop_ub - 1 >= 0) {
      ::std::copy(&b_obj.Vector[0], &b_obj.Vector[loop_ub], &obj_data[0]);
    }

    obj->findBodyIndexByJointName(obj_data, obj_size);
    b_index = obj->NumBodies + 1.0;
    body = b_bodyin->copy((&iobj_0)[0], (&iobj_1)[0], iobj_2);
    obj->Bodies[static_cast<int>(b_index) - 1] = body;
    body->Index = b_index;
    body->ParentIndex = pid;
    body->JointInternal->InTree = true;
    obj->NumBodies++;
    jnt = body->JointInternal;
    b_obj = jnt->TypeInternal;
    if (b_obj.Length < 1.0) {
      loop_ub = 0;
    } else {
      loop_ub = static_cast<int>(b_obj.Length);
    }

    b_bool = false;
    if (loop_ub == 5) {
      loop_ub = 0;
      do {
        exitg1 = 0;
        if (loop_ub < 5) {
          if (b_obj.Vector[loop_ub] != b_cv1[loop_ub]) {
            exitg1 = 1;
          } else {
            loop_ub++;
          }
        } else {
          b_bool = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (!b_bool) {
      obj->NumNonFixedBodies++;
      jnt = body->JointInternal;
      loop_ub = static_cast<int>(body->Index) - 1;
      obj->PositionDoFMap[loop_ub] = obj->PositionNumber + 1.0;
      obj->PositionDoFMap[loop_ub + 12] = obj->PositionNumber +
        jnt->PositionNumber;
      jnt = body->JointInternal;
      loop_ub = static_cast<int>(body->Index) - 1;
      obj->VelocityDoFMap[loop_ub] = obj->VelocityNumber + 1.0;
      obj->VelocityDoFMap[loop_ub + 12] = obj->VelocityNumber +
        jnt->VelocityNumber;
    } else {
      loop_ub = static_cast<int>(body->Index);
      obj->PositionDoFMap[loop_ub - 1] = 0.0;
      obj->PositionDoFMap[loop_ub + 11] = -1.0;
      loop_ub = static_cast<int>(body->Index);
      obj->VelocityDoFMap[loop_ub - 1] = 0.0;
      obj->VelocityDoFMap[loop_ub + 11] = -1.0;
    }

    jnt = body->JointInternal;
    obj->PositionNumber += jnt->PositionNumber;
    jnt = body->JointInternal;
    obj->VelocityNumber += jnt->VelocityNumber;
  }

  //
  // Arguments    : const collisionCapsule *varargin_1
  // Return Type  : void
  //
  void rigidBody::c_addCollision(const collisionCapsule *varargin_1)
  {
    static const double a[16]{ -0.0175, 0.0, -0.9998, 0.0, 0.0, 1.0, 0.0, 0.0,
      0.9998, 0.0, -0.0175, 0.0, 0.25, 0.0, 0.015, 1.0 };

    void *geometryInternal;
    collisionCapsule lobj_0;
    robotics::manip::internal::CollisionGeometry collisionGeometry;
    robotics::manip::internal::CollisionSet *b_obj;
    robotics::manip::internal::RigidBody *obj;
    double poseTform[16];
    double y[16];
    double length;
    double radius;
    obj = BodyInternal;
    for (int i{0}; i < 16; i++) {
      poseTform[i] = varargin_1->PoseInternal[i];
    }

    for (int i{0}; i < 4; i++) {
      double d;
      double d1;
      radius = a[i];
      length = a[i + 4];
      d = a[i + 8];
      d1 = a[i + 12];
      for (int i1{0}; i1 < 4; i1++) {
        int i2;
        i2 = i1 << 2;
        y[i + i2] = ((radius * poseTform[i2] + length * poseTform[i2 + 1]) + d *
                     poseTform[i2 + 2]) + d1 * poseTform[i2 + 3];
      }
    }

    radius = varargin_1->RadiusInternal;
    length = varargin_1->LengthInternal;
    lobj_0.RadiusInternal = radius;
    lobj_0.LengthInternal = length;
    geometryInternal = collisioncodegen_makeCapsule(radius, length);
    lobj_0.GeometryInternal = geometryInternal;
    lobj_0.matlabCodegenIsDeleted = false;
    for (int i{0}; i < 16; i++) {
      poseTform[i] = varargin_1->PoseInternal[i];
    }

    ::std::copy(&poseTform[0], &poseTform[16], &lobj_0.PoseInternal[0]);
    geometryInternal = collisioncodegen_makeCapsule(radius, length);
    collisionGeometry.CollisionPrimitive = geometryInternal;
    ::std::copy(&y[0], &y[16], &collisionGeometry.LocalPose[0]);
    ::std::copy(&y[0], &y[16], &collisionGeometry.WorldPose[0]);
    collisionGeometry.MeshScale[0] = 1.0;
    collisionGeometry.MeshScale[1] = 1.0;
    collisionGeometry.MeshScale[2] = 1.0;
    b_obj = obj->CollisionsInternal;
    if (b_obj->Size < b_obj->MaxElements) {
      b_obj->Size++;
      b_obj->CollisionGeometries[static_cast<int>(b_obj->Size) - 1] =
        collisionGeometry;
    }
  }

  //
  // Arguments    : void
  // Return Type  : rigidBodyJoint *
  //
  rigidBodyJoint *rigidBodyJoint::c_init()
  {
    static const char b_cv1[8]{ 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };

    static const char b_cv2[8]{ 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };

    static const char b_cv3[8]{ 'f', 'l', 'o', 'a', 't', 'i', 'n', 'g' };

    static const signed char iv2[7]{ 1, 0, 0, 0, 0, 0, 0 };

    static const signed char b_iv[6]{ 0, 0, 1, 0, 0, 0 };

    static const signed char b_iv1[6]{ 0, 0, 0, 0, 0, 1 };

    static const char b_cv[5]{ 'j', 'n', 't', 'A', '1' };

    static const char b_cv4[5]{ 'f', 'i', 'x', 'e', 'd' };

    rigidBodyJoint *obj;
    robotics::manip::internal::CharacterVector s;
    double msubspace_data[36];
    double poslim_data[14];
    int exitg1;
    int homepos_size_idx_1;
    int i;
    int ibmat;
    int poslim_size_idx_0;
    signed char homepos_data[7];
    signed char b_tmp;
    bool result;
    obj = this;
    obj->InTree = false;
    for (i = 0; i < 16; i++) {
      b_tmp = iv[i];
      obj->JointToParentTransform[i] = b_tmp;
      obj->ChildToJointTransform[i] = b_tmp;
    }

    for (i = 0; i < 14; i++) {
      obj->PositionLimitsInternal[i] = 0.0;
    }

    for (i = 0; i < 7; i++) {
      obj->HomePositionInternal[i] = 0.0;
    }

    for (i = 0; i < 36; i++) {
      obj->MotionSubspaceInternal[i] = 0.0;
    }

    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    obj->NameInternal = s;
    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    obj->TypeInternal = s;
    s = obj->NameInternal;
    s.Length = 5.0;
    for (i = 0; i < 5; i++) {
      s.Vector[i] = b_cv[i];
    }

    obj->NameInternal = s;
    s = obj->TypeInternal;
    s.Length = 8.0;
    for (i = 0; i < 8; i++) {
      s.Vector[i] = b_cv1[i];
    }

    obj->TypeInternal = s;
    s = obj->TypeInternal;
    if (s.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(s.Length);
    }

    result = false;
    if (i == 8) {
      ibmat = 0;
      do {
        exitg1 = 0;
        if (ibmat < 8) {
          if (b_cv2[ibmat] != s.Vector[ibmat]) {
            exitg1 = 1;
          } else {
            ibmat++;
          }
        } else {
          result = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (result) {
      ibmat = 0;
    } else {
      result = false;
      if (i == 9) {
        ibmat = 0;
        do {
          exitg1 = 0;
          if (ibmat < 9) {
            if (cv1[ibmat] != s.Vector[ibmat]) {
              exitg1 = 1;
            } else {
              ibmat++;
            }
          } else {
            result = true;
            exitg1 = 1;
          }
        } while (exitg1 == 0);
      }

      if (result) {
        ibmat = 1;
      } else {
        result = false;
        if (i == 8) {
          ibmat = 0;
          do {
            exitg1 = 0;
            if (ibmat < 8) {
              if (b_cv3[ibmat] != s.Vector[ibmat]) {
                exitg1 = 1;
              } else {
                ibmat++;
              }
            } else {
              result = true;
              exitg1 = 1;
            }
          } while (exitg1 == 0);
        }

        if (result) {
          ibmat = 2;
        } else {
          ibmat = -1;
        }
      }
    }

    switch (ibmat) {
     case 0:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = b_iv[i];
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = -3.1415926535897931;
      poslim_data[1] = 3.1415926535897931;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      obj->VelocityNumber = 1.0;
      obj->PositionNumber = 1.0;
      obj->JointAxisInternal[0] = 0.0;
      obj->JointAxisInternal[1] = 0.0;
      obj->JointAxisInternal[2] = 1.0;
      break;

     case 1:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = b_iv1[i];
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = -0.5;
      poslim_data[1] = 0.5;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      obj->VelocityNumber = 1.0;
      obj->PositionNumber = 1.0;
      obj->JointAxisInternal[0] = 0.0;
      obj->JointAxisInternal[1] = 0.0;
      obj->JointAxisInternal[2] = 1.0;
      break;

     case 2:
      {
        signed char b_I[36];
        signed char b[6];
        for (i = 0; i < 36; i++) {
          b_I[i] = 0;
        }

        for (ibmat = 0; ibmat < 6; ibmat++) {
          b_I[ibmat + 6 * ibmat] = 1;
        }

        for (i = 0; i < 36; i++) {
          msubspace_data[i] = b_I[i];
        }

        poslim_size_idx_0 = 7;
        for (homepos_size_idx_1 = 0; homepos_size_idx_1 < 2; homepos_size_idx_1
             ++) {
          ibmat = homepos_size_idx_1 * 3;
          b_tmp = static_cast<signed char>(10 * homepos_size_idx_1 - 5);
          b[ibmat] = b_tmp;
          b[ibmat + 1] = b_tmp;
          b[ibmat + 2] = b_tmp;
          poslim_data[7 * homepos_size_idx_1] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 1] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 2] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 3] = rtNaN;
        }

        for (i = 0; i < 2; i++) {
          poslim_data[7 * i + 4] = b[3 * i];
          poslim_data[7 * i + 5] = b[3 * i + 1];
          poslim_data[7 * i + 6] = b[3 * i + 2];
        }

        homepos_size_idx_1 = 7;
        for (i = 0; i < 7; i++) {
          homepos_data[i] = iv2[i];
        }

        obj->VelocityNumber = 6.0;
        obj->PositionNumber = 7.0;
        obj->JointAxisInternal[0] = rtNaN;
        obj->JointAxisInternal[1] = rtNaN;
        obj->JointAxisInternal[2] = rtNaN;
      }
      break;

     default:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = 0.0;
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = 0.0;
      poslim_data[1] = 0.0;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      obj->VelocityNumber = 0.0;
      obj->PositionNumber = 0.0;
      obj->JointAxisInternal[0] = 0.0;
      obj->JointAxisInternal[1] = 0.0;
      obj->JointAxisInternal[2] = 0.0;
      break;
    }

    obj->set_MotionSubspace(msubspace_data);
    s = obj->TypeInternal;
    if (s.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(s.Length);
    }

    result = false;
    if (i == 5) {
      ibmat = 0;
      do {
        exitg1 = 0;
        if (ibmat < 5) {
          if (s.Vector[ibmat] != b_cv4[ibmat]) {
            exitg1 = 1;
          } else {
            ibmat++;
          }
        } else {
          result = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (!result) {
      double d;
      d = obj->PositionNumber;
      if (d < 1.0) {
        ibmat = 0;
      } else {
        ibmat = static_cast<int>(d);
      }

      for (i = 0; i < 2; i++) {
        for (int i1{0}; i1 < ibmat; i1++) {
          obj->PositionLimitsInternal[i1 + 7 * i] = poslim_data[i1 +
            poslim_size_idx_0 * i];
        }
      }

      for (i = 0; i < homepos_size_idx_1; i++) {
        obj->HomePositionInternal[i] = homepos_data[i];
      }
    } else {
      obj->PositionLimitsInternal[0] = poslim_data[0];
      obj->PositionLimitsInternal[7] = poslim_data[1];
      obj->HomePositionInternal[0] = homepos_data[0];
    }

    return obj;
  }

  //
  // Arguments    : void
  // Return Type  : collisionCapsule *
  //
  collisionCapsule *collisionCapsule::c_init()
  {
    void *geometryInternal;
    collisionCapsule *obj;
    obj = this;
    for (int i{0}; i < 16; i++) {
      obj->PoseInternal[i] = iv[i];
    }

    obj->RadiusInternal = 0.14;
    obj->LengthInternal = 0.4;
    geometryInternal = collisioncodegen_makeCapsule(0.14, 0.4);
    obj->GeometryInternal = geometryInternal;
    obj->matlabCodegenIsDeleted = false;
    return obj;
  }

  //
  // Arguments    : robotics::manip::internal::RigidBodyTree &iobj_0
  //                robotics::manip::internal::CollisionSet &iobj_1
  //                rigidBodyJoint &iobj_2
  //                robotics::manip::internal::RigidBody &iobj_3
  // Return Type  : rigidBody *
  //
  rigidBody *rigidBody::c_init(robotics::manip::internal::RigidBodyTree &iobj_0,
    robotics::manip::internal::CollisionSet &iobj_1, rigidBodyJoint &iobj_2,
    robotics::manip::internal::RigidBody &iobj_3)
  {
    static const char b_cv1[10]{ 'b', 'o', 'd', 'y', 'A', '2', '_', 'j', 'n',
      't' };

    static const char b_cv3[8]{ 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };

    static const char b_cv4[8]{ 'f', 'l', 'o', 'a', 't', 'i', 'n', 'g' };

    static const signed char iv2[7]{ 1, 0, 0, 0, 0, 0, 0 };

    static const char b_cv[6]{ 'b', 'o', 'd', 'y', 'A', '2' };

    static const signed char b_iv[6]{ 0, 0, 1, 0, 0, 0 };

    static const signed char b_iv1[6]{ 0, 0, 0, 0, 0, 1 };

    static const char b_cv2[5]{ 'f', 'i', 'x', 'e', 'd' };

    static const char b_cv5[5]{ 'f', 'i', 'x', 'e', 'd' };

    rigidBody *obj;
    robotics::manip::internal::CharacterVector s;
    robotics::manip::internal::RigidBodyTree *b_default;
    double msubspace_data[36];
    double poslim_data[14];
    int exitg1;
    int homepos_size_idx_1;
    int i;
    int i1;
    int ibmat;
    int poslim_size_idx_0;
    signed char b_I[36];
    signed char c_I[9];
    signed char homepos_data[7];
    bool result;
    obj = this;
    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    iobj_3.NameInternal = s;
    s = iobj_3.NameInternal;
    s.Length = 6.0;
    for (i = 0; i < 6; i++) {
      s.Vector[i] = b_cv[i];
    }

    iobj_3.NameInternal = s;
    iobj_2.InTree = false;
    for (i = 0; i < 16; i++) {
      i1 = iv[i];
      iobj_2.JointToParentTransform[i] = i1;
      iobj_2.ChildToJointTransform[i] = i1;
    }

    for (i = 0; i < 14; i++) {
      iobj_2.PositionLimitsInternal[i] = 0.0;
    }

    for (i = 0; i < 7; i++) {
      iobj_2.HomePositionInternal[i] = 0.0;
    }

    for (i = 0; i < 36; i++) {
      iobj_2.MotionSubspaceInternal[i] = 0.0;
    }

    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    iobj_2.NameInternal = s;
    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    iobj_2.TypeInternal = s;
    s = iobj_2.NameInternal;
    s.Length = 10.0;
    for (i = 0; i < 10; i++) {
      s.Vector[i] = b_cv1[i];
    }

    iobj_2.NameInternal = s;
    s = iobj_2.TypeInternal;
    s.Length = 5.0;
    for (i = 0; i < 5; i++) {
      s.Vector[i] = b_cv2[i];
    }

    iobj_2.TypeInternal = s;
    s = iobj_2.TypeInternal;
    if (s.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(s.Length);
    }

    result = false;
    if (i == 8) {
      ibmat = 0;
      do {
        exitg1 = 0;
        if (ibmat < 8) {
          if (b_cv3[ibmat] != s.Vector[ibmat]) {
            exitg1 = 1;
          } else {
            ibmat++;
          }
        } else {
          result = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (result) {
      ibmat = 0;
    } else {
      result = false;
      if (i == 9) {
        ibmat = 0;
        do {
          exitg1 = 0;
          if (ibmat < 9) {
            if (cv1[ibmat] != s.Vector[ibmat]) {
              exitg1 = 1;
            } else {
              ibmat++;
            }
          } else {
            result = true;
            exitg1 = 1;
          }
        } while (exitg1 == 0);
      }

      if (result) {
        ibmat = 1;
      } else {
        result = false;
        if (i == 8) {
          ibmat = 0;
          do {
            exitg1 = 0;
            if (ibmat < 8) {
              if (b_cv4[ibmat] != s.Vector[ibmat]) {
                exitg1 = 1;
              } else {
                ibmat++;
              }
            } else {
              result = true;
              exitg1 = 1;
            }
          } while (exitg1 == 0);
        }

        if (result) {
          ibmat = 2;
        } else {
          ibmat = -1;
        }
      }
    }

    switch (ibmat) {
     case 0:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = b_iv[i];
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = -3.1415926535897931;
      poslim_data[1] = 3.1415926535897931;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      iobj_2.VelocityNumber = 1.0;
      iobj_2.PositionNumber = 1.0;
      iobj_2.JointAxisInternal[0] = 0.0;
      iobj_2.JointAxisInternal[1] = 0.0;
      iobj_2.JointAxisInternal[2] = 1.0;
      break;

     case 1:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = b_iv1[i];
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = -0.5;
      poslim_data[1] = 0.5;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      iobj_2.VelocityNumber = 1.0;
      iobj_2.PositionNumber = 1.0;
      iobj_2.JointAxisInternal[0] = 0.0;
      iobj_2.JointAxisInternal[1] = 0.0;
      iobj_2.JointAxisInternal[2] = 1.0;
      break;

     case 2:
      {
        signed char b[6];
        for (i = 0; i < 36; i++) {
          b_I[i] = 0;
        }

        for (ibmat = 0; ibmat < 6; ibmat++) {
          b_I[ibmat + 6 * ibmat] = 1;
        }

        for (i = 0; i < 36; i++) {
          msubspace_data[i] = b_I[i];
        }

        poslim_size_idx_0 = 7;
        for (homepos_size_idx_1 = 0; homepos_size_idx_1 < 2; homepos_size_idx_1
             ++) {
          signed char b_tmp;
          ibmat = homepos_size_idx_1 * 3;
          b_tmp = static_cast<signed char>(10 * homepos_size_idx_1 - 5);
          b[ibmat] = b_tmp;
          b[ibmat + 1] = b_tmp;
          b[ibmat + 2] = b_tmp;
          poslim_data[7 * homepos_size_idx_1] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 1] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 2] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 3] = rtNaN;
        }

        for (i = 0; i < 2; i++) {
          poslim_data[7 * i + 4] = b[3 * i];
          poslim_data[7 * i + 5] = b[3 * i + 1];
          poslim_data[7 * i + 6] = b[3 * i + 2];
        }

        homepos_size_idx_1 = 7;
        for (i = 0; i < 7; i++) {
          homepos_data[i] = iv2[i];
        }

        iobj_2.VelocityNumber = 6.0;
        iobj_2.PositionNumber = 7.0;
        iobj_2.JointAxisInternal[0] = rtNaN;
        iobj_2.JointAxisInternal[1] = rtNaN;
        iobj_2.JointAxisInternal[2] = rtNaN;
      }
      break;

     default:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = 0.0;
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = 0.0;
      poslim_data[1] = 0.0;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      iobj_2.VelocityNumber = 0.0;
      iobj_2.PositionNumber = 0.0;
      iobj_2.JointAxisInternal[0] = 0.0;
      iobj_2.JointAxisInternal[1] = 0.0;
      iobj_2.JointAxisInternal[2] = 0.0;
      break;
    }

    iobj_2.set_MotionSubspace(msubspace_data);
    s = iobj_2.TypeInternal;
    if (s.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(s.Length);
    }

    result = false;
    if (i == 5) {
      ibmat = 0;
      do {
        exitg1 = 0;
        if (ibmat < 5) {
          if (s.Vector[ibmat] != b_cv5[ibmat]) {
            exitg1 = 1;
          } else {
            ibmat++;
          }
        } else {
          result = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (!result) {
      double d;
      d = iobj_2.PositionNumber;
      if (d < 1.0) {
        ibmat = 0;
      } else {
        ibmat = static_cast<int>(d);
      }

      for (i = 0; i < 2; i++) {
        for (i1 = 0; i1 < ibmat; i1++) {
          iobj_2.PositionLimitsInternal[i1 + 7 * i] = poslim_data[i1 +
            poslim_size_idx_0 * i];
        }
      }

      for (i = 0; i < homepos_size_idx_1; i++) {
        iobj_2.HomePositionInternal[i] = homepos_data[i];
      }
    } else {
      iobj_2.PositionLimitsInternal[0] = poslim_data[0];
      iobj_2.PositionLimitsInternal[7] = poslim_data[1];
      iobj_2.HomePositionInternal[0] = homepos_data[0];
    }

    iobj_3.JointInternal = &iobj_2;
    iobj_3.Index = -1.0;
    iobj_3.ParentIndex = -1.0;
    iobj_3.MassInternal = 1.0;
    iobj_3.CenterOfMassInternal[0] = 0.0;
    iobj_3.CenterOfMassInternal[1] = 0.0;
    iobj_3.CenterOfMassInternal[2] = 0.0;
    for (i = 0; i < 9; i++) {
      c_I[i] = 0;
    }

    c_I[0] = 1;
    c_I[4] = 1;
    c_I[8] = 1;
    for (i = 0; i < 9; i++) {
      iobj_3.InertiaInternal[i] = c_I[i];
    }

    for (i = 0; i < 36; i++) {
      b_I[i] = 0;
    }

    for (ibmat = 0; ibmat < 6; ibmat++) {
      b_I[ibmat + 6 * ibmat] = 1;
    }

    for (i = 0; i < 36; i++) {
      iobj_3.SpatialInertia[i] = b_I[i];
    }

    iobj_3.CollisionsInternal = (&iobj_1)[0].init(static_cast<double>(0.0));
    iobj_3.matlabCodegenIsDeleted = false;
    b_default = iobj_0.init();
    iobj_3.CollisionsInternal = (&iobj_1)[1].init(1.0);
    obj->BodyInternal = &iobj_3;
    obj->TreeInternal = b_default;
    obj->matlabCodegenIsDeleted = false;
    return obj;
  }

  //
  // Arguments    : void
  // Return Type  : void
  //
  void rigidBodyJoint::c_setFixedTransform()
  {
    static const double inputTform[16]{ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0,
      0.0, 0.0, 1.0, 0.0, 0.04, 0.0, 0.223, 1.0 };

    for (int i{0}; i < 16; i++) {
      JointToParentTransform[i] = inputTform[i];
      ChildToJointTransform[i] = 0.0;
    }

    ChildToJointTransform[0] = 1.0;
    ChildToJointTransform[5] = 1.0;
    ChildToJointTransform[10] = 1.0;
    ChildToJointTransform[15] = 1.0;
  }

  //
  // Arguments    : void
  // Return Type  : void
  //
  void rigidBodyJoint::c_set_JointAxis()
  {
    static const double dv[6]{ 0.0, 0.0, 0.0, 0.0, 0.0, -1.0 };

    static const double dv1[6]{ 0.0, 0.0, -1.0, 0.0, 0.0, 0.0 };

    static const char b_cv[8]{ 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };

    int i;
    bool result;
    JointAxisInternal[0] = 0.0;
    JointAxisInternal[1] = 0.0;
    JointAxisInternal[2] = -1.0;
    if (TypeInternal.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(TypeInternal.Length);
    }

    result = false;
    if (i == 8) {
      i = 0;
      int exitg1;
      do {
        exitg1 = 0;
        if (i < 8) {
          if (b_cv[i] != TypeInternal.Vector[i]) {
            exitg1 = 1;
          } else {
            i++;
          }
        } else {
          result = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (result) {
      i = 0;
    } else {
      i = -1;
    }

    if (i == 0) {
      b_set_MotionSubspace(dv1);
    } else {
      b_set_MotionSubspace(dv);
    }
  }

  //
  // Arguments    : void
  // Return Type  : void
  //
  void rigidBodyJoint::c_set_PositionLimits()
  {
    static const double lims[2]{ -1.2217304763960311, 3.717551306747922 };

    array<bool, 1U> x;
    double d;
    int ix;
    int loop_ub;
    bool resetHome;
    resetHome = false;
    switch (static_cast<int>(PositionNumber)) {
     case 0:
     case 7:
      break;

     default:
      {
        bool exitg1;
        bool y;
        d = PositionNumber;
        if (d < 1.0) {
          loop_ub = 0;
        } else {
          loop_ub = static_cast<int>(d);
        }

        x.set_size(loop_ub);
        for (ix = 0; ix < loop_ub; ix++) {
          x[ix] = (HomePositionInternal[ix] > 3.717551306747922);
        }

        y = false;
        ix = 1;
        exitg1 = false;
        while ((!exitg1) && (ix <= x.size(0))) {
          if (x[ix - 1]) {
            y = true;
            exitg1 = true;
          } else {
            ix++;
          }
        }

        if (y) {
          resetHome = true;
        } else {
          x.set_size(loop_ub);
          for (ix = 0; ix < loop_ub; ix++) {
            x[ix] = (HomePositionInternal[ix] < -1.2217304763960311);
          }

          y = false;
          ix = 1;
          exitg1 = false;
          while ((!exitg1) && (ix <= x.size(0))) {
            if (x[ix - 1]) {
              y = true;
              exitg1 = true;
            } else {
              ix++;
            }
          }

          if (y) {
            resetHome = true;
          }
        }
      }
      break;
    }

    d = PositionNumber;
    if (d < 1.0) {
      loop_ub = 0;
    } else {
      loop_ub = static_cast<int>(d);
    }

    for (ix = 0; ix < 2; ix++) {
      for (int i{0}; i < loop_ub; i++) {
        PositionLimitsInternal[i + 7 * ix] = lims[i + loop_ub * ix];
      }
    }

    if (resetHome) {
      resetHomePosition();
    }
  }

  //
  // Arguments    : const double config[6]
  //                array<double, 2U> &separationDist
  // Return Type  : bool
  //
  bool rigidBodyTree::checkCollision(const double config[6], array<double, 2U>
    &separationDist)
  {
    static const char b_cv[8]{ 'b', 'o', 'd', 'y', 'B', 'a', 's', 'e' };

    static const char cv11[8]{ 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };

    static const char cv12[8]{ 'f', 'l', 'o', 'a', 't', 'i', 'n', 'g' };

    static const char cv8[8]{ 'b', 'o', 'd', 'y', 'T', 'o', 'o', 'l' };

    static const char b_cv1[6]{ 'b', 'o', 'd', 'y', 'A', '1' };

    static const char b_cv2[6]{ 'b', 'o', 'd', 'y', 'A', '2' };

    static const char b_cv3[6]{ 'b', 'o', 'd', 'y', 'A', '3' };

    static const char b_cv4[6]{ 'b', 'o', 'd', 'y', 'A', '4' };

    static const char b_cv5[6]{ 'b', 'o', 'd', 'y', 'A', '5' };

    static const char cv6[6]{ 'b', 'o', 'd', 'y', 'A', '6' };

    static const char cv7[6]{ 'b', 'o', 'd', 'y', 'E', 'E' };

    static const char parsedResults_f3_f1[4]{ 'b', 'a', 's', 'e' };

    static const signed char varargin_2[4]{ 0, 0, 0, 1 };

    static const char cv9[3]{ 'o', 'f', 'f' };

    static const char cv10[2]{ 'o', 'n' };

    rigidBodyJoint *c_obj;
    robotics::manip::internal::CharacterVector b_obj;
    robotics::manip::internal::RigidBody *body;
    robotics::manip::internal::b_RigidBodyTree *obj;
    array<double, 2U> witnessPts;
    cell_wrap_41 Ttree_data[12];
    cell_wrap_41 tTree_data[12];
    double x[24];
    double T1[16];
    double b[16];
    double b_T1[16];
    double d;
    int obj_size[2];
    int b_i;
    int exitg1;
    int i;
    int kstr;
    char obj_data[200];
    char a_data[3];
    bool b_bool;
    bool isColliding;
    obj = TreeInternal;
    x[0] = -1.0;
    b_obj = obj->Base.NameInternal;
    if (b_obj.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(b_obj.Length);
    }

    isColliding = false;
    if (i == 4) {
      kstr = 0;
      do {
        exitg1 = 0;
        if (kstr < 4) {
          if (b_obj.Vector[kstr] != parsedResults_f3_f1[kstr]) {
            exitg1 = 1;
          } else {
            kstr++;
          }
        } else {
          isColliding = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (isColliding) {
      x[0] = 0.0;
    } else {
      bool exitg2;
      d = obj->NumBodies;
      b_i = 0;
      exitg2 = false;
      while ((!exitg2) && (b_i <= static_cast<int>(d) - 1)) {
        body = obj->Bodies[b_i];
        b_obj = body->NameInternal;
        if (b_obj.Length < 1.0) {
          i = 0;
        } else {
          i = static_cast<int>(b_obj.Length);
        }

        isColliding = false;
        if (i == 4) {
          kstr = 0;
          do {
            exitg1 = 0;
            if (kstr < 4) {
              if (b_obj.Vector[kstr] != parsedResults_f3_f1[kstr]) {
                exitg1 = 1;
              } else {
                kstr++;
              }
            } else {
              isColliding = true;
              exitg1 = 1;
            }
          } while (exitg1 == 0);
        }

        if (isColliding) {
          x[0] = static_cast<double>(b_i) + 1.0;
          exitg2 = true;
        } else {
          b_i++;
        }
      }
    }

    x[12] = obj->findBodyIndexByName(b_cv);
    x[1] = obj->findBodyIndexByName(b_cv);
    x[13] = obj->b_findBodyIndexByName(b_cv1);
    x[2] = obj->b_findBodyIndexByName(b_cv1);
    x[14] = obj->b_findBodyIndexByName(b_cv2);
    x[3] = obj->b_findBodyIndexByName(b_cv2);
    x[15] = obj->b_findBodyIndexByName(b_cv3);
    x[4] = obj->b_findBodyIndexByName(b_cv3);
    x[16] = obj->b_findBodyIndexByName(b_cv4);
    x[5] = obj->b_findBodyIndexByName(b_cv4);
    x[17] = obj->b_findBodyIndexByName(b_cv5);
    x[6] = obj->b_findBodyIndexByName(b_cv5);
    x[18] = obj->b_findBodyIndexByName(cv6);
    x[7] = obj->b_findBodyIndexByName(cv6);
    x[19] = obj->b_findBodyIndexByName(cv7);
    x[8] = obj->b_findBodyIndexByName(cv7);
    x[20] = obj->findBodyIndexByName(cv8);
    x[9] = obj->findBodyIndexByName(cv8);
    x[21] = obj->c_findBodyIndexByName(cv3);
    x[10] = obj->b_findBodyIndexByName(b_cv2);
    x[22] = obj->b_findBodyIndexByName(b_cv4);
    x[11] = obj->b_findBodyIndexByName(b_cv4);
    x[23] = obj->findBodyIndexByName(cv8);
    validatestring(cv9, a_data, obj_size);
    isColliding = false;
    if (obj_size[1] == 2) {
      kstr = 0;
      do {
        exitg1 = 0;
        if (kstr < 2) {
          if (cv2[static_cast<int>(static_cast<unsigned char>(a_data[kstr]) &
               127U)] != cv2[static_cast<int>(cv10[kstr])]) {
            exitg1 = 1;
          } else {
            kstr++;
          }
        } else {
          isColliding = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    validatestring(cv9, a_data, obj_size);
    b_bool = false;
    if (obj_size[1] == 2) {
      kstr = 0;
      do {
        exitg1 = 0;
        if (kstr < 2) {
          if (cv2[static_cast<int>(static_cast<unsigned char>(a_data[kstr]) &
               127U)] != cv2[static_cast<int>(cv10[kstr])]) {
            exitg1 = 1;
          } else {
            kstr++;
          }
        } else {
          b_bool = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    obj = TreeInternal;
    if (!isColliding) {
      double a[16];
      double k;
      double n;
      int i1;
      int i2;
      int loop_ub;
      n = obj->NumBodies;
      repmat(n, tTree_data, obj_size);
      k = 1.0;
      i = static_cast<int>(n);
      for (b_i = 0; b_i < i; b_i++) {
        double d1;
        double d2;
        double d3;
        body = obj->Bodies[b_i];
        n = body->JointInternal->PositionNumber;
        d = k + n;
        if (k > d - 1.0) {
          i1 = 0;
          i2 = 0;
        } else {
          i1 = static_cast<int>(k) - 1;
          i2 = static_cast<int>(d - 1.0);
        }

        c_obj = body->JointInternal;
        for (loop_ub = 0; loop_ub < 16; loop_ub++) {
          a[loop_ub] = c_obj->JointToParentTransform[loop_ub];
        }

        b_obj = c_obj->TypeInternal;
        if (b_obj.Length < 1.0) {
          loop_ub = 0;
        } else {
          loop_ub = static_cast<int>(b_obj.Length);
        }

        isColliding = false;
        if (loop_ub == 8) {
          kstr = 0;
          do {
            exitg1 = 0;
            if (kstr < 8) {
              if (cv11[kstr] != b_obj.Vector[kstr]) {
                exitg1 = 1;
              } else {
                kstr++;
              }
            } else {
              isColliding = true;
              exitg1 = 1;
            }
          } while (exitg1 == 0);
        }

        if (isColliding) {
          kstr = 0;
        } else {
          isColliding = false;
          if (loop_ub == 9) {
            kstr = 0;
            do {
              exitg1 = 0;
              if (kstr < 9) {
                if (cv1[kstr] != b_obj.Vector[kstr]) {
                  exitg1 = 1;
                } else {
                  kstr++;
                }
              } else {
                isColliding = true;
                exitg1 = 1;
              }
            } while (exitg1 == 0);
          }

          if (isColliding) {
            kstr = 1;
          } else {
            isColliding = false;
            if (loop_ub == 8) {
              kstr = 0;
              do {
                exitg1 = 0;
                if (kstr < 8) {
                  if (cv12[kstr] != b_obj.Vector[kstr]) {
                    exitg1 = 1;
                  } else {
                    kstr++;
                  }
                } else {
                  isColliding = true;
                  exitg1 = 1;
                }
              } while (exitg1 == 0);
            }

            if (isColliding) {
              kstr = 2;
            } else {
              kstr = -1;
            }
          }
        }

        switch (kstr) {
         case 0:
          {
            double v_data[9];
            double v[3];
            c_obj->get_JointAxis(v);
            loop_ub = i2 - i1;
            v_data[0] = v[0];
            v_data[1] = v[1];
            v_data[2] = v[2];
            for (i2 = 0; i2 < loop_ub; i2++) {
              v_data[i2 + 3] = config[i1 + i2];
            }

            axang2tform(v_data, T1);
            ::std::copy(&T1[0], &T1[16], &b_T1[0]);
          }
          break;

         case 1:
          {
            double I_data[27];
            double b_v_data[18];
            double v[3];
            signed char b_I[9];
            c_obj->get_JointAxis(v);
            for (loop_ub = 0; loop_ub < 9; loop_ub++) {
              b_I[loop_ub] = 0;
            }

            b_I[0] = 1;
            b_I[4] = 1;
            b_I[8] = 1;
            loop_ub = i2 - i1;
            for (i2 = 0; i2 < loop_ub; i2++) {
              n = config[i1 + i2];
              b_v_data[3 * i2] = v[0] * n;
              b_v_data[3 * i2 + 1] = v[1] * n;
              b_v_data[3 * i2 + 2] = v[2] * n;
            }

            for (i1 = 0; i1 < 3; i1++) {
              I_data[3 * i1] = b_I[3 * i1];
              kstr = 3 * i1 + 1;
              I_data[kstr] = b_I[kstr];
              kstr = 3 * i1 + 2;
              I_data[kstr] = b_I[kstr];
            }

            for (i1 = 0; i1 < loop_ub; i1++) {
              kstr = 3 * (i1 + 3);
              I_data[kstr] = b_v_data[3 * i1];
              I_data[kstr + 1] = b_v_data[3 * i1 + 1];
              I_data[kstr + 2] = b_v_data[3 * i1 + 2];
            }

            for (i1 = 0; i1 < 4; i1++) {
              b_T1[4 * i1] = I_data[3 * i1];
              b_T1[4 * i1 + 1] = I_data[3 * i1 + 1];
              b_T1[4 * i1 + 2] = I_data[3 * i1 + 2];
              b_T1[4 * i1 + 3] = varargin_2[i1];
            }
          }
          break;

         case 2:
          {
            double v_data[9];
            double b_config[4];
            std::memset(&T1[0], 0, 16U * sizeof(double));
            T1[0] = 1.0;
            T1[5] = 1.0;
            T1[10] = 1.0;
            T1[15] = 1.0;
            T1[12] = config[i1 + 4];
            T1[13] = config[i1 + 5];
            T1[14] = config[i1 + 6];
            std::memset(&b[0], 0, 16U * sizeof(double));
            b_config[0] = config[i1];
            b_config[1] = config[i1 + 1];
            b_config[2] = config[i1 + 2];
            b_config[3] = config[i1 + 3];
            robotics::internal::quat2rotm(b_config, v_data);
            for (i1 = 0; i1 < 3; i1++) {
              kstr = i1 << 2;
              b[kstr] = v_data[3 * i1];
              b[kstr + 1] = v_data[3 * i1 + 1];
              b[kstr + 2] = v_data[3 * i1 + 2];
            }

            b[15] = 1.0;
            for (i1 = 0; i1 < 4; i1++) {
              d1 = T1[i1];
              d2 = T1[i1 + 4];
              d3 = T1[i1 + 8];
              n = T1[i1 + 12];
              for (i2 = 0; i2 < 4; i2++) {
                loop_ub = i2 << 2;
                b_T1[i1 + loop_ub] = ((d1 * b[loop_ub] + d2 * b[loop_ub + 1]) +
                                      d3 * b[loop_ub + 2]) + n * b[loop_ub + 3];
              }
            }
          }
          break;

         default:
          std::memset(&T1[0], 0, 16U * sizeof(double));
          T1[0] = 1.0;
          T1[5] = 1.0;
          T1[10] = 1.0;
          T1[15] = 1.0;
          ::std::copy(&T1[0], &T1[16], &b_T1[0]);
          break;
        }

        for (i1 = 0; i1 < 16; i1++) {
          b[i1] = c_obj->ChildToJointTransform[i1];
        }

        for (i1 = 0; i1 < 4; i1++) {
          d1 = a[i1];
          d2 = a[i1 + 4];
          d3 = a[i1 + 8];
          n = a[i1 + 12];
          for (i2 = 0; i2 < 4; i2++) {
            T1[i1 + (i2 << 2)] = ((d1 * b_T1[4 * i2] + d2 * b_T1[4 * i2 + 1]) +
                                  d3 * b_T1[4 * i2 + 2]) + n * b_T1[4 * i2 + 3];
          }

          d1 = T1[i1];
          d2 = T1[i1 + 4];
          d3 = T1[i1 + 8];
          n = T1[i1 + 12];
          for (i2 = 0; i2 < 4; i2++) {
            loop_ub = i2 << 2;
            tTree_data[b_i].f1[i1 + loop_ub] = ((d1 * b[loop_ub] + d2 *
              b[loop_ub + 1]) + d3 * b[loop_ub + 2]) + n * b[loop_ub + 3];
          }
        }

        k = d;
        if (body->ParentIndex > 0.0) {
          for (i1 = 0; i1 < 16; i1++) {
            a[i1] = tTree_data[static_cast<int>(body->ParentIndex) - 1].f1[i1];
          }

          for (i1 = 0; i1 < 4; i1++) {
            d = a[i1];
            d1 = a[i1 + 4];
            d2 = a[i1 + 8];
            d3 = a[i1 + 12];
            for (i2 = 0; i2 < 4; i2++) {
              loop_ub = i2 << 2;
              T1[i1 + loop_ub] = ((d * tTree_data[b_i].f1[loop_ub] + d1 *
                                   tTree_data[b_i].f1[loop_ub + 1]) + d2 *
                                  tTree_data[b_i].f1[loop_ub + 2]) + d3 *
                tTree_data[b_i].f1[loop_ub + 3];
            }
          }

          ::std::copy(&T1[0], &T1[16], &tTree_data[b_i].f1[0]);
        }
      }

      b_obj = obj->Base.NameInternal;
      if (b_obj.Length < 1.0) {
        loop_ub = 0;
      } else {
        loop_ub = static_cast<int>(b_obj.Length);
      }

      obj->forwardKinematics(config, Ttree_data, obj_size);
      obj_size[0] = 1;
      obj_size[1] = loop_ub;
      if (loop_ub - 1 >= 0) {
        ::std::copy(&b_obj.Vector[0], &b_obj.Vector[loop_ub], &obj_data[0]);
      }

      n = obj->findBodyIndexByName(obj_data, obj_size);
      if (n == 0.0) {
        std::memset(&T1[0], 0, 16U * sizeof(double));
        T1[0] = 1.0;
        T1[5] = 1.0;
        T1[10] = 1.0;
        T1[15] = 1.0;
      } else {
        for (i = 0; i < 16; i++) {
          T1[i] = Ttree_data[static_cast<int>(n) - 1].f1[i];
        }
      }

      internal::sort(x);
      for (i = 0; i < 4; i++) {
        signed char i3;
        signed char i4;
        signed char i5;
        signed char i6;
        i3 = iv[i];
        i4 = iv[i + 4];
        i5 = iv[i + 8];
        i6 = iv[i + 12];
        for (i1 = 0; i1 < 4; i1++) {
          i2 = i1 << 2;
          a[i + i2] = ((static_cast<double>(i3) * T1[i2] + static_cast<double>
                        (i4) * T1[i2 + 1]) + static_cast<double>(i5) * T1[i2 + 2])
            + static_cast<double>(i6) * T1[i2 + 3];
        }
      }

      isColliding = obj->checkSelfCollision(tTree_data, a, b_bool, x,
        separationDist, witnessPts);
    } else {
      isColliding = false;
      d = obj->NumBodies + 1.0;
      separationDist.set_size(static_cast<int>(d), static_cast<int>(d));
      kstr = static_cast<int>(d) * static_cast<int>(d);
      for (i = 0; i < kstr; i++) {
        separationDist[i] = rtInf;
      }
    }

    return isColliding;
  }

  //
  // Arguments    : rigidBodyJoint &iobj_0
  //                robotics::manip::internal::RigidBody &iobj_1
  //                robotics::manip::internal::CollisionSet &iobj_2
  //                robotics::manip::internal::b_RigidBodyTree &iobj_3
  //                rigidBodyTree &iobj_4
  // Return Type  : rigidBodyTree *
  //
  rigidBodyTree *rigidBodyTree::copy(rigidBodyJoint &iobj_0, robotics::manip::
    internal::RigidBody &iobj_1, robotics::manip::internal::CollisionSet &iobj_2,
    robotics::manip::internal::b_RigidBodyTree &iobj_3, rigidBodyTree &iobj_4)
  {
    void *copyGeometryInternal;
    rigidBodyTree *newrobot;
    robotics::manip::internal::CharacterVector b_obj;
    robotics::manip::internal::CollisionGeometry b_newObj;
    robotics::manip::internal::CollisionGeometry d_obj;
    robotics::manip::internal::CollisionSet *c_obj;
    robotics::manip::internal::CollisionSet *newObj;
    robotics::manip::internal::RigidBody *body;
    robotics::manip::internal::RigidBody *parent;
    robotics::manip::internal::b_RigidBodyTree *newRobotInternal;
    robotics::manip::internal::b_RigidBodyTree *obj;
    double pid;
    int obj_size[2];
    int loop_ub;
    char obj_data[200];
    obj = TreeInternal;
    newRobotInternal = iobj_3.init();
    b_obj = obj->Base.NameInternal;
    if (b_obj.Length < 1.0) {
      loop_ub = 0;
    } else {
      loop_ub = static_cast<int>(b_obj.Length);
    }

    obj_size[0] = 1;
    obj_size[1] = loop_ub;
    if (loop_ub - 1 >= 0) {
      ::std::copy(&b_obj.Vector[0], &b_obj.Vector[loop_ub], &obj_data[0]);
    }

    newRobotInternal->set_BaseName(obj_data, obj_size);
    c_obj = obj->Base.CollisionsInternal;
    newObj = (&iobj_2)[0].init(c_obj->MaxElements);
    newObj->Size = c_obj->Size;
    pid = c_obj->Size;
    loop_ub = static_cast<int>(pid);
    for (int i{0}; i < loop_ub; i++) {
      d_obj = c_obj->CollisionGeometries[i];
      copyGeometryInternal = collisioncodegen_copyGeometry
        (d_obj.CollisionPrimitive);
      b_newObj.CollisionPrimitive = copyGeometryInternal;
      ::std::copy(&d_obj.LocalPose[0], &d_obj.LocalPose[16],
                  &b_newObj.LocalPose[0]);
      b_newObj.MeshScale[0] = d_obj.MeshScale[0];
      b_newObj.MeshScale[1] = d_obj.MeshScale[1];
      b_newObj.MeshScale[2] = d_obj.MeshScale[2];
      ::std::copy(&d_obj.WorldPose[0], &d_obj.WorldPose[16],
                  &b_newObj.WorldPose[0]);
      newObj->CollisionGeometries[i] = b_newObj;
    }

    double g_idx_1;
    double g_idx_2;
    newRobotInternal->Base.CollisionsInternal = newObj;
    pid = obj->Gravity[0];
    g_idx_1 = obj->Gravity[1];
    g_idx_2 = obj->Gravity[2];
    newRobotInternal->Gravity[0] = pid;
    newRobotInternal->Gravity[1] = g_idx_1;
    newRobotInternal->Gravity[2] = g_idx_2;
    if (obj->NumBodies >= 1.0) {
      body = obj->Bodies[0];
      pid = body->ParentIndex;
      if (pid > 0.0) {
        parent = obj->Bodies[static_cast<int>(pid) - 1];
      } else {
        parent = &obj->Base;
      }

      b_obj = parent->NameInternal;
      if (b_obj.Length < 1.0) {
        loop_ub = 0;
      } else {
        loop_ub = static_cast<int>(b_obj.Length);
      }

      obj_size[0] = 1;
      obj_size[1] = loop_ub;
      if (loop_ub - 1 >= 0) {
        ::std::copy(&b_obj.Vector[0], &b_obj.Vector[loop_ub], &obj_data[0]);
      }

      newRobotInternal->addBody(body, obj_data, obj_size, (&iobj_2)[1], (&iobj_0)
        [0], (&iobj_1)[0]);
    }

    if (obj->NumBodies >= 2.0) {
      body = obj->Bodies[1];
      pid = body->ParentIndex;
      if (pid > 0.0) {
        parent = obj->Bodies[static_cast<int>(pid) - 1];
      } else {
        parent = &obj->Base;
      }

      b_obj = parent->NameInternal;
      if (b_obj.Length < 1.0) {
        loop_ub = 0;
      } else {
        loop_ub = static_cast<int>(b_obj.Length);
      }

      obj_size[0] = 1;
      obj_size[1] = loop_ub;
      if (loop_ub - 1 >= 0) {
        ::std::copy(&b_obj.Vector[0], &b_obj.Vector[loop_ub], &obj_data[0]);
      }

      newRobotInternal->addBody(body, obj_data, obj_size, (&iobj_2)[3], (&iobj_0)
        [2], (&iobj_1)[1]);
    }

    if (obj->NumBodies >= 3.0) {
      body = obj->Bodies[2];
      pid = body->ParentIndex;
      if (pid > 0.0) {
        parent = obj->Bodies[static_cast<int>(pid) - 1];
      } else {
        parent = &obj->Base;
      }

      b_obj = parent->NameInternal;
      if (b_obj.Length < 1.0) {
        loop_ub = 0;
      } else {
        loop_ub = static_cast<int>(b_obj.Length);
      }

      obj_size[0] = 1;
      obj_size[1] = loop_ub;
      if (loop_ub - 1 >= 0) {
        ::std::copy(&b_obj.Vector[0], &b_obj.Vector[loop_ub], &obj_data[0]);
      }

      newRobotInternal->addBody(body, obj_data, obj_size, (&iobj_2)[5], (&iobj_0)
        [4], (&iobj_1)[2]);
    }

    if (obj->NumBodies >= 4.0) {
      body = obj->Bodies[3];
      pid = body->ParentIndex;
      if (pid > 0.0) {
        parent = obj->Bodies[static_cast<int>(pid) - 1];
      } else {
        parent = &obj->Base;
      }

      b_obj = parent->NameInternal;
      if (b_obj.Length < 1.0) {
        loop_ub = 0;
      } else {
        loop_ub = static_cast<int>(b_obj.Length);
      }

      obj_size[0] = 1;
      obj_size[1] = loop_ub;
      if (loop_ub - 1 >= 0) {
        ::std::copy(&b_obj.Vector[0], &b_obj.Vector[loop_ub], &obj_data[0]);
      }

      newRobotInternal->addBody(body, obj_data, obj_size, (&iobj_2)[7], (&iobj_0)
        [6], (&iobj_1)[3]);
    }

    if (obj->NumBodies >= 5.0) {
      body = obj->Bodies[4];
      pid = body->ParentIndex;
      if (pid > 0.0) {
        parent = obj->Bodies[static_cast<int>(pid) - 1];
      } else {
        parent = &obj->Base;
      }

      b_obj = parent->NameInternal;
      if (b_obj.Length < 1.0) {
        loop_ub = 0;
      } else {
        loop_ub = static_cast<int>(b_obj.Length);
      }

      obj_size[0] = 1;
      obj_size[1] = loop_ub;
      if (loop_ub - 1 >= 0) {
        ::std::copy(&b_obj.Vector[0], &b_obj.Vector[loop_ub], &obj_data[0]);
      }

      newRobotInternal->addBody(body, obj_data, obj_size, (&iobj_2)[9], (&iobj_0)
        [8], (&iobj_1)[4]);
    }

    if (obj->NumBodies >= 6.0) {
      body = obj->Bodies[5];
      pid = body->ParentIndex;
      if (pid > 0.0) {
        parent = obj->Bodies[static_cast<int>(pid) - 1];
      } else {
        parent = &obj->Base;
      }

      b_obj = parent->NameInternal;
      if (b_obj.Length < 1.0) {
        loop_ub = 0;
      } else {
        loop_ub = static_cast<int>(b_obj.Length);
      }

      obj_size[0] = 1;
      obj_size[1] = loop_ub;
      if (loop_ub - 1 >= 0) {
        ::std::copy(&b_obj.Vector[0], &b_obj.Vector[loop_ub], &obj_data[0]);
      }

      newRobotInternal->addBody(body, obj_data, obj_size, (&iobj_2)[11],
        (&iobj_0)[10], (&iobj_1)[5]);
    }

    if (obj->NumBodies >= 7.0) {
      body = obj->Bodies[6];
      pid = body->ParentIndex;
      if (pid > 0.0) {
        parent = obj->Bodies[static_cast<int>(pid) - 1];
      } else {
        parent = &obj->Base;
      }

      b_obj = parent->NameInternal;
      if (b_obj.Length < 1.0) {
        loop_ub = 0;
      } else {
        loop_ub = static_cast<int>(b_obj.Length);
      }

      obj_size[0] = 1;
      obj_size[1] = loop_ub;
      if (loop_ub - 1 >= 0) {
        ::std::copy(&b_obj.Vector[0], &b_obj.Vector[loop_ub], &obj_data[0]);
      }

      newRobotInternal->addBody(body, obj_data, obj_size, (&iobj_2)[13],
        (&iobj_0)[12], (&iobj_1)[6]);
    }

    if (obj->NumBodies >= 8.0) {
      body = obj->Bodies[7];
      pid = body->ParentIndex;
      if (pid > 0.0) {
        parent = obj->Bodies[static_cast<int>(pid) - 1];
      } else {
        parent = &obj->Base;
      }

      b_obj = parent->NameInternal;
      if (b_obj.Length < 1.0) {
        loop_ub = 0;
      } else {
        loop_ub = static_cast<int>(b_obj.Length);
      }

      obj_size[0] = 1;
      obj_size[1] = loop_ub;
      if (loop_ub - 1 >= 0) {
        ::std::copy(&b_obj.Vector[0], &b_obj.Vector[loop_ub], &obj_data[0]);
      }

      newRobotInternal->addBody(body, obj_data, obj_size, (&iobj_2)[15],
        (&iobj_0)[14], (&iobj_1)[7]);
    }

    if (obj->NumBodies >= 9.0) {
      body = obj->Bodies[8];
      pid = body->ParentIndex;
      if (pid > 0.0) {
        parent = obj->Bodies[static_cast<int>(pid) - 1];
      } else {
        parent = &obj->Base;
      }

      b_obj = parent->NameInternal;
      if (b_obj.Length < 1.0) {
        loop_ub = 0;
      } else {
        loop_ub = static_cast<int>(b_obj.Length);
      }

      obj_size[0] = 1;
      obj_size[1] = loop_ub;
      if (loop_ub - 1 >= 0) {
        ::std::copy(&b_obj.Vector[0], &b_obj.Vector[loop_ub], &obj_data[0]);
      }

      newRobotInternal->addBody(body, obj_data, obj_size, (&iobj_2)[17],
        (&iobj_0)[16], (&iobj_1)[8]);
    }

    if (obj->NumBodies >= 10.0) {
      body = obj->Bodies[9];
      pid = body->ParentIndex;
      if (pid > 0.0) {
        parent = obj->Bodies[static_cast<int>(pid) - 1];
      } else {
        parent = &obj->Base;
      }

      b_obj = parent->NameInternal;
      if (b_obj.Length < 1.0) {
        loop_ub = 0;
      } else {
        loop_ub = static_cast<int>(b_obj.Length);
      }

      obj_size[0] = 1;
      obj_size[1] = loop_ub;
      if (loop_ub - 1 >= 0) {
        ::std::copy(&b_obj.Vector[0], &b_obj.Vector[loop_ub], &obj_data[0]);
      }

      newRobotInternal->addBody(body, obj_data, obj_size, (&iobj_2)[19],
        (&iobj_0)[18], (&iobj_1)[9]);
    }

    if (obj->NumBodies >= 11.0) {
      body = obj->Bodies[10];
      pid = body->ParentIndex;
      if (pid > 0.0) {
        parent = obj->Bodies[static_cast<int>(pid) - 1];
      } else {
        parent = &obj->Base;
      }

      b_obj = parent->NameInternal;
      if (b_obj.Length < 1.0) {
        loop_ub = 0;
      } else {
        loop_ub = static_cast<int>(b_obj.Length);
      }

      obj_size[0] = 1;
      obj_size[1] = loop_ub;
      if (loop_ub - 1 >= 0) {
        ::std::copy(&b_obj.Vector[0], &b_obj.Vector[loop_ub], &obj_data[0]);
      }

      newRobotInternal->addBody(body, obj_data, obj_size, (&iobj_2)[21],
        (&iobj_0)[20], (&iobj_1)[10]);
    }

    if (obj->NumBodies >= 12.0) {
      body = obj->Bodies[11];
      pid = body->ParentIndex;
      if (pid > 0.0) {
        parent = obj->Bodies[static_cast<int>(pid) - 1];
      } else {
        parent = &obj->Base;
      }

      b_obj = parent->NameInternal;
      if (b_obj.Length < 1.0) {
        loop_ub = 0;
      } else {
        loop_ub = static_cast<int>(b_obj.Length);
      }

      obj_size[0] = 1;
      obj_size[1] = loop_ub;
      if (loop_ub - 1 >= 0) {
        ::std::copy(&b_obj.Vector[0], &b_obj.Vector[loop_ub], &obj_data[0]);
      }

      newRobotInternal->addBody(body, obj_data, obj_size, (&iobj_2)[23],
        (&iobj_0)[22], (&iobj_1)[11]);
    }

    newrobot = &iobj_4;
    iobj_4.TreeInternal = iobj_4._pobj1.init();
    iobj_4.TreeInternal->Base.CollisionsInternal = iobj_4._pobj0.init(10.0);
    iobj_4.matlabCodegenIsDeleted = false;
    iobj_4.TreeInternal = newRobotInternal;
    return newrobot;
  }

  //
  // Arguments    : rigidBodyJoint &iobj_0
  // Return Type  : rigidBodyJoint *
  //
  rigidBodyJoint *rigidBodyJoint::copy(rigidBodyJoint &iobj_0) const
  {
    static const char b_cv[8]{ 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };

    static const char b_cv1[8]{ 'f', 'l', 'o', 'a', 't', 'i', 'n', 'g' };

    static const signed char iv2[7]{ 1, 0, 0, 0, 0, 0, 0 };

    static const signed char b_iv[6]{ 0, 0, 1, 0, 0, 0 };

    static const signed char b_iv1[6]{ 0, 0, 0, 0, 0, 1 };

    static const char b_cv2[5]{ 'f', 'i', 'x', 'e', 'd' };

    rigidBodyJoint *newjoint;
    robotics::manip::internal::CharacterVector b_obj;
    robotics::manip::internal::CharacterVector obj;
    robotics::manip::internal::CharacterVector s;
    double msubspace_data[36];
    double d_obj[16];
    double poslim_data[14];
    double c_obj[7];
    double obj_idx_0;
    int obj_size[2];
    int vec_size[2];
    int exitg1;
    int homepos_size_idx_1;
    int i;
    int i1;
    int ibmat;
    int poslim_size_idx_0;
    char vec_data[204];
    char obj_data[200];
    signed char homepos_data[7];
    signed char b_tmp;
    bool result;
    obj = TypeInternal;
    if (obj.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(obj.Length);
    }

    b_obj = NameInternal;
    if (b_obj.Length < 1.0) {
      i1 = 0;
    } else {
      i1 = static_cast<int>(b_obj.Length);
    }

    iobj_0.InTree = false;
    for (ibmat = 0; ibmat < 16; ibmat++) {
      b_tmp = iv[ibmat];
      iobj_0.JointToParentTransform[ibmat] = b_tmp;
      iobj_0.ChildToJointTransform[ibmat] = b_tmp;
    }

    for (ibmat = 0; ibmat < 14; ibmat++) {
      iobj_0.PositionLimitsInternal[ibmat] = 0.0;
    }

    for (ibmat = 0; ibmat < 7; ibmat++) {
      iobj_0.HomePositionInternal[ibmat] = 0.0;
    }

    for (ibmat = 0; ibmat < 36; ibmat++) {
      iobj_0.MotionSubspaceInternal[ibmat] = 0.0;
    }

    newjoint = &iobj_0;
    s.Length = 200.0;
    for (ibmat = 0; ibmat < 200; ibmat++) {
      s.Vector[ibmat] = ' ';
    }

    iobj_0.NameInternal = s;
    s.Length = 200.0;
    for (ibmat = 0; ibmat < 200; ibmat++) {
      s.Vector[ibmat] = ' ';
    }

    iobj_0.TypeInternal = s;
    s = iobj_0.NameInternal;
    s.Length = i1;
    if (i1 < 1) {
      ibmat = 0;
    } else {
      ibmat = i1;
    }

    if (ibmat - 1 >= 0) {
      ::std::copy(&b_obj.Vector[0], &b_obj.Vector[ibmat], &s.Vector[0]);
    }

    iobj_0.NameInternal = s;
    b_obj = iobj_0.TypeInternal;
    obj_size[0] = 1;
    obj_size[1] = i;
    if (i - 1 >= 0) {
      ::std::copy(&obj.Vector[0], &obj.Vector[i], &obj_data[0]);
    }

    validatestring(obj_data, obj_size, vec_data, vec_size);
    b_obj.Length = vec_size[1];
    i = vec_size[1];
    if (i - 1 >= 0) {
      ::std::copy(&vec_data[0], &vec_data[i], &b_obj.Vector[0]);
    }

    iobj_0.TypeInternal = b_obj;
    obj = iobj_0.TypeInternal;
    if (obj.Length < 1.0) {
      i1 = 0;
    } else {
      i1 = static_cast<int>(obj.Length);
    }

    result = false;
    if (i1 == 8) {
      ibmat = 0;
      do {
        exitg1 = 0;
        if (ibmat < 8) {
          if (b_cv[ibmat] != obj.Vector[ibmat]) {
            exitg1 = 1;
          } else {
            ibmat++;
          }
        } else {
          result = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (result) {
      ibmat = 0;
    } else {
      result = false;
      if (i1 == 9) {
        ibmat = 0;
        do {
          exitg1 = 0;
          if (ibmat < 9) {
            if (cv1[ibmat] != obj.Vector[ibmat]) {
              exitg1 = 1;
            } else {
              ibmat++;
            }
          } else {
            result = true;
            exitg1 = 1;
          }
        } while (exitg1 == 0);
      }

      if (result) {
        ibmat = 1;
      } else {
        result = false;
        if (i1 == 8) {
          ibmat = 0;
          do {
            exitg1 = 0;
            if (ibmat < 8) {
              if (b_cv1[ibmat] != obj.Vector[ibmat]) {
                exitg1 = 1;
              } else {
                ibmat++;
              }
            } else {
              result = true;
              exitg1 = 1;
            }
          } while (exitg1 == 0);
        }

        if (result) {
          ibmat = 2;
        } else {
          ibmat = -1;
        }
      }
    }

    switch (ibmat) {
     case 0:
      for (i1 = 0; i1 < 6; i1++) {
        msubspace_data[i1] = b_iv[i1];
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = -3.1415926535897931;
      poslim_data[1] = 3.1415926535897931;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      iobj_0.VelocityNumber = 1.0;
      iobj_0.PositionNumber = 1.0;
      iobj_0.JointAxisInternal[0] = 0.0;
      iobj_0.JointAxisInternal[1] = 0.0;
      iobj_0.JointAxisInternal[2] = 1.0;
      break;

     case 1:
      for (i1 = 0; i1 < 6; i1++) {
        msubspace_data[i1] = b_iv1[i1];
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = -0.5;
      poslim_data[1] = 0.5;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      iobj_0.VelocityNumber = 1.0;
      iobj_0.PositionNumber = 1.0;
      iobj_0.JointAxisInternal[0] = 0.0;
      iobj_0.JointAxisInternal[1] = 0.0;
      iobj_0.JointAxisInternal[2] = 1.0;
      break;

     case 2:
      {
        signed char b_I[36];
        signed char b[6];
        for (i1 = 0; i1 < 36; i1++) {
          b_I[i1] = 0;
        }

        for (ibmat = 0; ibmat < 6; ibmat++) {
          b_I[ibmat + 6 * ibmat] = 1;
        }

        for (i1 = 0; i1 < 36; i1++) {
          msubspace_data[i1] = b_I[i1];
        }

        poslim_size_idx_0 = 7;
        for (i = 0; i < 2; i++) {
          ibmat = i * 3;
          b_tmp = static_cast<signed char>(10 * i - 5);
          b[ibmat] = b_tmp;
          b[ibmat + 1] = b_tmp;
          b[ibmat + 2] = b_tmp;
          poslim_data[7 * i] = rtNaN;
          poslim_data[7 * i + 1] = rtNaN;
          poslim_data[7 * i + 2] = rtNaN;
          poslim_data[7 * i + 3] = rtNaN;
        }

        for (i1 = 0; i1 < 2; i1++) {
          poslim_data[7 * i1 + 4] = b[3 * i1];
          poslim_data[7 * i1 + 5] = b[3 * i1 + 1];
          poslim_data[7 * i1 + 6] = b[3 * i1 + 2];
        }

        homepos_size_idx_1 = 7;
        for (i1 = 0; i1 < 7; i1++) {
          homepos_data[i1] = iv2[i1];
        }

        iobj_0.VelocityNumber = 6.0;
        iobj_0.PositionNumber = 7.0;
        iobj_0.JointAxisInternal[0] = rtNaN;
        iobj_0.JointAxisInternal[1] = rtNaN;
        iobj_0.JointAxisInternal[2] = rtNaN;
      }
      break;

     default:
      for (i1 = 0; i1 < 6; i1++) {
        msubspace_data[i1] = 0.0;
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = 0.0;
      poslim_data[1] = 0.0;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      iobj_0.VelocityNumber = 0.0;
      iobj_0.PositionNumber = 0.0;
      iobj_0.JointAxisInternal[0] = 0.0;
      iobj_0.JointAxisInternal[1] = 0.0;
      iobj_0.JointAxisInternal[2] = 0.0;
      break;
    }

    iobj_0.set_MotionSubspace(msubspace_data);
    obj = iobj_0.TypeInternal;
    if (obj.Length < 1.0) {
      i1 = 0;
    } else {
      i1 = static_cast<int>(obj.Length);
    }

    result = false;
    if (i1 == 5) {
      ibmat = 0;
      do {
        exitg1 = 0;
        if (ibmat < 5) {
          if (obj.Vector[ibmat] != b_cv2[ibmat]) {
            exitg1 = 1;
          } else {
            ibmat++;
          }
        } else {
          result = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (!result) {
      obj_idx_0 = iobj_0.PositionNumber;
      if (obj_idx_0 < 1.0) {
        i = 0;
      } else {
        i = static_cast<int>(obj_idx_0);
      }

      for (i1 = 0; i1 < 2; i1++) {
        for (ibmat = 0; ibmat < i; ibmat++) {
          iobj_0.PositionLimitsInternal[ibmat + 7 * i1] = poslim_data[ibmat +
            poslim_size_idx_0 * i1];
        }
      }

      for (i1 = 0; i1 < homepos_size_idx_1; i1++) {
        iobj_0.HomePositionInternal[i1] = homepos_data[i1];
      }
    } else {
      iobj_0.PositionLimitsInternal[0] = poslim_data[0];
      iobj_0.PositionLimitsInternal[7] = poslim_data[1];
      iobj_0.HomePositionInternal[0] = homepos_data[0];
    }

    obj = NameInternal;
    if (obj.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(obj.Length);
    }

    if (i != 0) {
      obj = NameInternal;
      if (obj.Length < 1.0) {
        i1 = 0;
      } else {
        i1 = static_cast<int>(obj.Length);
      }

      if (!iobj_0.InTree) {
        b_obj = iobj_0.NameInternal;
        b_obj.Length = i1;
        if (i1 < 1) {
          i = 0;
        } else {
          i = i1;
        }

        if (i - 1 >= 0) {
          ::std::copy(&obj.Vector[0], &obj.Vector[i], &b_obj.Vector[0]);
        }

        iobj_0.NameInternal = b_obj;
      }
    }

    for (i1 = 0; i1 < 14; i1++) {
      poslim_data[i1] = PositionLimitsInternal[i1];
    }

    for (i1 = 0; i1 < 14; i1++) {
      iobj_0.PositionLimitsInternal[i1] = poslim_data[i1];
    }

    for (i1 = 0; i1 < 7; i1++) {
      c_obj[i1] = HomePositionInternal[i1];
    }

    for (i1 = 0; i1 < 7; i1++) {
      iobj_0.HomePositionInternal[i1] = c_obj[i1];
    }

    double obj_idx_1;
    double obj_idx_2;
    obj_idx_0 = JointAxisInternal[0];
    obj_idx_1 = JointAxisInternal[1];
    obj_idx_2 = JointAxisInternal[2];
    iobj_0.JointAxisInternal[0] = obj_idx_0;
    iobj_0.JointAxisInternal[1] = obj_idx_1;
    iobj_0.JointAxisInternal[2] = obj_idx_2;
    get_MotionSubspace(msubspace_data, obj_size);
    iobj_0.set_MotionSubspace(msubspace_data);
    for (i1 = 0; i1 < 16; i1++) {
      d_obj[i1] = JointToParentTransform[i1];
    }

    for (i1 = 0; i1 < 16; i1++) {
      iobj_0.JointToParentTransform[i1] = d_obj[i1];
    }

    for (i1 = 0; i1 < 16; i1++) {
      d_obj[i1] = ChildToJointTransform[i1];
    }

    for (i1 = 0; i1 < 16; i1++) {
      iobj_0.ChildToJointTransform[i1] = d_obj[i1];
    }

    return newjoint;
  }

  //
  // Arguments    : rigidBody &bodyin
  //                robotics::manip::internal::CollisionSet &iobj_0
  //                rigidBodyJoint &iobj_1
  //                robotics::manip::internal::RigidBody &iobj_2
  // Return Type  : void
  //
  void rigidBodyTree::d_addBody(rigidBody &bodyin, robotics::manip::internal::
    CollisionSet &iobj_0, rigidBodyJoint &iobj_1, robotics::manip::internal::
    RigidBody &iobj_2)
  {
    static const char b_cv[6]{ 'b', 'o', 'd', 'y', 'A', '2' };

    static const char b_cv1[5]{ 'f', 'i', 'x', 'e', 'd' };

    rigidBodyJoint *jnt;
    robotics::manip::internal::CharacterVector b_obj;
    robotics::manip::internal::RigidBody *b_bodyin;
    robotics::manip::internal::RigidBody *body;
    robotics::manip::internal::b_RigidBodyTree *obj;
    double b_index;
    int obj_size[2];
    int exitg1;
    int loop_ub;
    int pid;
    char obj_data[200];
    bool b_bool;
    obj = TreeInternal;
    b_bodyin = bodyin.BodyInternal;
    b_obj = b_bodyin->NameInternal;
    if (b_obj.Length < 1.0) {
      loop_ub = 0;
    } else {
      loop_ub = static_cast<int>(b_obj.Length);
    }

    obj_size[0] = 1;
    obj_size[1] = loop_ub;
    if (loop_ub - 1 >= 0) {
      ::std::copy(&b_obj.Vector[0], &b_obj.Vector[loop_ub], &obj_data[0]);
    }

    obj->findBodyIndexByName(obj_data, obj_size);
    pid = -1;
    b_obj = obj->Base.NameInternal;
    if (b_obj.Length < 1.0) {
      loop_ub = 0;
    } else {
      loop_ub = static_cast<int>(b_obj.Length);
    }

    b_bool = false;
    if (loop_ub == 6) {
      loop_ub = 0;
      do {
        exitg1 = 0;
        if (loop_ub < 6) {
          if (b_obj.Vector[loop_ub] != b_cv[loop_ub]) {
            exitg1 = 1;
          } else {
            loop_ub++;
          }
        } else {
          b_bool = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (b_bool) {
      pid = 0;
    } else {
      int i;
      bool exitg2;
      b_index = obj->NumBodies;
      i = 0;
      exitg2 = false;
      while ((!exitg2) && (i <= static_cast<int>(b_index) - 1)) {
        body = obj->Bodies[i];
        b_obj = body->NameInternal;
        if (b_obj.Length < 1.0) {
          loop_ub = 0;
        } else {
          loop_ub = static_cast<int>(b_obj.Length);
        }

        b_bool = false;
        if (loop_ub == 6) {
          loop_ub = 0;
          do {
            exitg1 = 0;
            if (loop_ub < 6) {
              if (b_obj.Vector[loop_ub] != b_cv[loop_ub]) {
                exitg1 = 1;
              } else {
                loop_ub++;
              }
            } else {
              b_bool = true;
              exitg1 = 1;
            }
          } while (exitg1 == 0);
        }

        if (b_bool) {
          pid = i + 1;
          exitg2 = true;
        } else {
          i++;
        }
      }
    }

    jnt = b_bodyin->JointInternal;
    b_obj = jnt->NameInternal;
    if (b_obj.Length < 1.0) {
      loop_ub = 0;
    } else {
      loop_ub = static_cast<int>(b_obj.Length);
    }

    obj_size[0] = 1;
    obj_size[1] = loop_ub;
    if (loop_ub - 1 >= 0) {
      ::std::copy(&b_obj.Vector[0], &b_obj.Vector[loop_ub], &obj_data[0]);
    }

    obj->findBodyIndexByJointName(obj_data, obj_size);
    b_index = obj->NumBodies + 1.0;
    body = b_bodyin->copy((&iobj_0)[0], (&iobj_1)[0], iobj_2);
    obj->Bodies[static_cast<int>(b_index) - 1] = body;
    body->Index = b_index;
    body->ParentIndex = pid;
    body->JointInternal->InTree = true;
    obj->NumBodies++;
    jnt = body->JointInternal;
    b_obj = jnt->TypeInternal;
    if (b_obj.Length < 1.0) {
      loop_ub = 0;
    } else {
      loop_ub = static_cast<int>(b_obj.Length);
    }

    b_bool = false;
    if (loop_ub == 5) {
      loop_ub = 0;
      do {
        exitg1 = 0;
        if (loop_ub < 5) {
          if (b_obj.Vector[loop_ub] != b_cv1[loop_ub]) {
            exitg1 = 1;
          } else {
            loop_ub++;
          }
        } else {
          b_bool = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (!b_bool) {
      obj->NumNonFixedBodies++;
      jnt = body->JointInternal;
      loop_ub = static_cast<int>(body->Index) - 1;
      obj->PositionDoFMap[loop_ub] = obj->PositionNumber + 1.0;
      obj->PositionDoFMap[loop_ub + 12] = obj->PositionNumber +
        jnt->PositionNumber;
      jnt = body->JointInternal;
      loop_ub = static_cast<int>(body->Index) - 1;
      obj->VelocityDoFMap[loop_ub] = obj->VelocityNumber + 1.0;
      obj->VelocityDoFMap[loop_ub + 12] = obj->VelocityNumber +
        jnt->VelocityNumber;
    } else {
      loop_ub = static_cast<int>(body->Index);
      obj->PositionDoFMap[loop_ub - 1] = 0.0;
      obj->PositionDoFMap[loop_ub + 11] = -1.0;
      loop_ub = static_cast<int>(body->Index);
      obj->VelocityDoFMap[loop_ub - 1] = 0.0;
      obj->VelocityDoFMap[loop_ub + 11] = -1.0;
    }

    jnt = body->JointInternal;
    obj->PositionNumber += jnt->PositionNumber;
    jnt = body->JointInternal;
    obj->VelocityNumber += jnt->VelocityNumber;
  }

  //
  // Arguments    : const collisionCapsule *varargin_1
  // Return Type  : void
  //
  void rigidBody::d_addCollision(const collisionCapsule *varargin_1)
  {
    static const double a[16]{ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0,
      1.0, 0.0, 0.0, 0.0, -0.19, 1.0 };

    void *geometryInternal;
    collisionCapsule lobj_0;
    robotics::manip::internal::CollisionGeometry collisionGeometry;
    robotics::manip::internal::CollisionSet *b_obj;
    robotics::manip::internal::RigidBody *obj;
    double poseTform[16];
    double y[16];
    double length;
    double radius;
    obj = BodyInternal;
    for (int i{0}; i < 16; i++) {
      poseTform[i] = varargin_1->PoseInternal[i];
    }

    for (int i{0}; i < 4; i++) {
      double d;
      double d1;
      radius = a[i];
      length = a[i + 4];
      d = a[i + 8];
      d1 = a[i + 12];
      for (int i1{0}; i1 < 4; i1++) {
        int i2;
        i2 = i1 << 2;
        y[i + i2] = ((radius * poseTform[i2] + length * poseTform[i2 + 1]) + d *
                     poseTform[i2 + 2]) + d1 * poseTform[i2 + 3];
      }
    }

    radius = varargin_1->RadiusInternal;
    length = varargin_1->LengthInternal;
    lobj_0.RadiusInternal = radius;
    lobj_0.LengthInternal = length;
    geometryInternal = collisioncodegen_makeCapsule(radius, length);
    lobj_0.GeometryInternal = geometryInternal;
    lobj_0.matlabCodegenIsDeleted = false;
    for (int i{0}; i < 16; i++) {
      poseTform[i] = varargin_1->PoseInternal[i];
    }

    ::std::copy(&poseTform[0], &poseTform[16], &lobj_0.PoseInternal[0]);
    geometryInternal = collisioncodegen_makeCapsule(radius, length);
    collisionGeometry.CollisionPrimitive = geometryInternal;
    ::std::copy(&y[0], &y[16], &collisionGeometry.LocalPose[0]);
    ::std::copy(&y[0], &y[16], &collisionGeometry.WorldPose[0]);
    collisionGeometry.MeshScale[0] = 1.0;
    collisionGeometry.MeshScale[1] = 1.0;
    collisionGeometry.MeshScale[2] = 1.0;
    b_obj = obj->CollisionsInternal;
    if (b_obj->Size < b_obj->MaxElements) {
      b_obj->Size++;
      b_obj->CollisionGeometries[static_cast<int>(b_obj->Size) - 1] =
        collisionGeometry;
    }
  }

  //
  // Arguments    : robotics::manip::internal::RigidBodyTree &iobj_0
  //                robotics::manip::internal::CollisionSet &iobj_1
  //                rigidBodyJoint &iobj_2
  //                robotics::manip::internal::RigidBody &iobj_3
  // Return Type  : rigidBody *
  //
  rigidBody *rigidBody::d_init(robotics::manip::internal::RigidBodyTree &iobj_0,
    robotics::manip::internal::CollisionSet &iobj_1, rigidBodyJoint &iobj_2,
    robotics::manip::internal::RigidBody &iobj_3)
  {
    static const char b_cv1[10]{ 'b', 'o', 'd', 'y', 'A', '3', '_', 'j', 'n',
      't' };

    static const char b_cv3[8]{ 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };

    static const char b_cv4[8]{ 'f', 'l', 'o', 'a', 't', 'i', 'n', 'g' };

    static const signed char iv2[7]{ 1, 0, 0, 0, 0, 0, 0 };

    static const char b_cv[6]{ 'b', 'o', 'd', 'y', 'A', '3' };

    static const signed char b_iv[6]{ 0, 0, 1, 0, 0, 0 };

    static const signed char b_iv1[6]{ 0, 0, 0, 0, 0, 1 };

    static const char b_cv2[5]{ 'f', 'i', 'x', 'e', 'd' };

    static const char b_cv5[5]{ 'f', 'i', 'x', 'e', 'd' };

    rigidBody *obj;
    robotics::manip::internal::CharacterVector s;
    robotics::manip::internal::RigidBodyTree *b_default;
    double msubspace_data[36];
    double poslim_data[14];
    int exitg1;
    int homepos_size_idx_1;
    int i;
    int i1;
    int ibmat;
    int poslim_size_idx_0;
    signed char b_I[36];
    signed char c_I[9];
    signed char homepos_data[7];
    bool result;
    obj = this;
    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    iobj_3.NameInternal = s;
    s = iobj_3.NameInternal;
    s.Length = 6.0;
    for (i = 0; i < 6; i++) {
      s.Vector[i] = b_cv[i];
    }

    iobj_3.NameInternal = s;
    iobj_2.InTree = false;
    for (i = 0; i < 16; i++) {
      i1 = iv[i];
      iobj_2.JointToParentTransform[i] = i1;
      iobj_2.ChildToJointTransform[i] = i1;
    }

    for (i = 0; i < 14; i++) {
      iobj_2.PositionLimitsInternal[i] = 0.0;
    }

    for (i = 0; i < 7; i++) {
      iobj_2.HomePositionInternal[i] = 0.0;
    }

    for (i = 0; i < 36; i++) {
      iobj_2.MotionSubspaceInternal[i] = 0.0;
    }

    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    iobj_2.NameInternal = s;
    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    iobj_2.TypeInternal = s;
    s = iobj_2.NameInternal;
    s.Length = 10.0;
    for (i = 0; i < 10; i++) {
      s.Vector[i] = b_cv1[i];
    }

    iobj_2.NameInternal = s;
    s = iobj_2.TypeInternal;
    s.Length = 5.0;
    for (i = 0; i < 5; i++) {
      s.Vector[i] = b_cv2[i];
    }

    iobj_2.TypeInternal = s;
    s = iobj_2.TypeInternal;
    if (s.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(s.Length);
    }

    result = false;
    if (i == 8) {
      ibmat = 0;
      do {
        exitg1 = 0;
        if (ibmat < 8) {
          if (b_cv3[ibmat] != s.Vector[ibmat]) {
            exitg1 = 1;
          } else {
            ibmat++;
          }
        } else {
          result = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (result) {
      ibmat = 0;
    } else {
      result = false;
      if (i == 9) {
        ibmat = 0;
        do {
          exitg1 = 0;
          if (ibmat < 9) {
            if (cv1[ibmat] != s.Vector[ibmat]) {
              exitg1 = 1;
            } else {
              ibmat++;
            }
          } else {
            result = true;
            exitg1 = 1;
          }
        } while (exitg1 == 0);
      }

      if (result) {
        ibmat = 1;
      } else {
        result = false;
        if (i == 8) {
          ibmat = 0;
          do {
            exitg1 = 0;
            if (ibmat < 8) {
              if (b_cv4[ibmat] != s.Vector[ibmat]) {
                exitg1 = 1;
              } else {
                ibmat++;
              }
            } else {
              result = true;
              exitg1 = 1;
            }
          } while (exitg1 == 0);
        }

        if (result) {
          ibmat = 2;
        } else {
          ibmat = -1;
        }
      }
    }

    switch (ibmat) {
     case 0:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = b_iv[i];
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = -3.1415926535897931;
      poslim_data[1] = 3.1415926535897931;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      iobj_2.VelocityNumber = 1.0;
      iobj_2.PositionNumber = 1.0;
      iobj_2.JointAxisInternal[0] = 0.0;
      iobj_2.JointAxisInternal[1] = 0.0;
      iobj_2.JointAxisInternal[2] = 1.0;
      break;

     case 1:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = b_iv1[i];
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = -0.5;
      poslim_data[1] = 0.5;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      iobj_2.VelocityNumber = 1.0;
      iobj_2.PositionNumber = 1.0;
      iobj_2.JointAxisInternal[0] = 0.0;
      iobj_2.JointAxisInternal[1] = 0.0;
      iobj_2.JointAxisInternal[2] = 1.0;
      break;

     case 2:
      {
        signed char b[6];
        for (i = 0; i < 36; i++) {
          b_I[i] = 0;
        }

        for (ibmat = 0; ibmat < 6; ibmat++) {
          b_I[ibmat + 6 * ibmat] = 1;
        }

        for (i = 0; i < 36; i++) {
          msubspace_data[i] = b_I[i];
        }

        poslim_size_idx_0 = 7;
        for (homepos_size_idx_1 = 0; homepos_size_idx_1 < 2; homepos_size_idx_1
             ++) {
          signed char b_tmp;
          ibmat = homepos_size_idx_1 * 3;
          b_tmp = static_cast<signed char>(10 * homepos_size_idx_1 - 5);
          b[ibmat] = b_tmp;
          b[ibmat + 1] = b_tmp;
          b[ibmat + 2] = b_tmp;
          poslim_data[7 * homepos_size_idx_1] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 1] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 2] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 3] = rtNaN;
        }

        for (i = 0; i < 2; i++) {
          poslim_data[7 * i + 4] = b[3 * i];
          poslim_data[7 * i + 5] = b[3 * i + 1];
          poslim_data[7 * i + 6] = b[3 * i + 2];
        }

        homepos_size_idx_1 = 7;
        for (i = 0; i < 7; i++) {
          homepos_data[i] = iv2[i];
        }

        iobj_2.VelocityNumber = 6.0;
        iobj_2.PositionNumber = 7.0;
        iobj_2.JointAxisInternal[0] = rtNaN;
        iobj_2.JointAxisInternal[1] = rtNaN;
        iobj_2.JointAxisInternal[2] = rtNaN;
      }
      break;

     default:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = 0.0;
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = 0.0;
      poslim_data[1] = 0.0;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      iobj_2.VelocityNumber = 0.0;
      iobj_2.PositionNumber = 0.0;
      iobj_2.JointAxisInternal[0] = 0.0;
      iobj_2.JointAxisInternal[1] = 0.0;
      iobj_2.JointAxisInternal[2] = 0.0;
      break;
    }

    iobj_2.set_MotionSubspace(msubspace_data);
    s = iobj_2.TypeInternal;
    if (s.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(s.Length);
    }

    result = false;
    if (i == 5) {
      ibmat = 0;
      do {
        exitg1 = 0;
        if (ibmat < 5) {
          if (s.Vector[ibmat] != b_cv5[ibmat]) {
            exitg1 = 1;
          } else {
            ibmat++;
          }
        } else {
          result = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (!result) {
      double d;
      d = iobj_2.PositionNumber;
      if (d < 1.0) {
        ibmat = 0;
      } else {
        ibmat = static_cast<int>(d);
      }

      for (i = 0; i < 2; i++) {
        for (i1 = 0; i1 < ibmat; i1++) {
          iobj_2.PositionLimitsInternal[i1 + 7 * i] = poslim_data[i1 +
            poslim_size_idx_0 * i];
        }
      }

      for (i = 0; i < homepos_size_idx_1; i++) {
        iobj_2.HomePositionInternal[i] = homepos_data[i];
      }
    } else {
      iobj_2.PositionLimitsInternal[0] = poslim_data[0];
      iobj_2.PositionLimitsInternal[7] = poslim_data[1];
      iobj_2.HomePositionInternal[0] = homepos_data[0];
    }

    iobj_3.JointInternal = &iobj_2;
    iobj_3.Index = -1.0;
    iobj_3.ParentIndex = -1.0;
    iobj_3.MassInternal = 1.0;
    iobj_3.CenterOfMassInternal[0] = 0.0;
    iobj_3.CenterOfMassInternal[1] = 0.0;
    iobj_3.CenterOfMassInternal[2] = 0.0;
    for (i = 0; i < 9; i++) {
      c_I[i] = 0;
    }

    c_I[0] = 1;
    c_I[4] = 1;
    c_I[8] = 1;
    for (i = 0; i < 9; i++) {
      iobj_3.InertiaInternal[i] = c_I[i];
    }

    for (i = 0; i < 36; i++) {
      b_I[i] = 0;
    }

    for (ibmat = 0; ibmat < 6; ibmat++) {
      b_I[ibmat + 6 * ibmat] = 1;
    }

    for (i = 0; i < 36; i++) {
      iobj_3.SpatialInertia[i] = b_I[i];
    }

    iobj_3.CollisionsInternal = iobj_1.init(static_cast<double>(0.0));
    iobj_3.matlabCodegenIsDeleted = false;
    b_default = iobj_0.init();
    obj->BodyInternal = &iobj_3;
    obj->TreeInternal = b_default;
    obj->matlabCodegenIsDeleted = false;
    return obj;
  }

  //
  // Arguments    : void
  // Return Type  : rigidBodyJoint *
  //
  rigidBodyJoint *rigidBodyJoint::d_init()
  {
    static const char b_cv1[8]{ 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };

    static const char b_cv2[8]{ 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };

    static const char b_cv3[8]{ 'f', 'l', 'o', 'a', 't', 'i', 'n', 'g' };

    static const signed char iv2[7]{ 1, 0, 0, 0, 0, 0, 0 };

    static const signed char b_iv[6]{ 0, 0, 1, 0, 0, 0 };

    static const signed char b_iv1[6]{ 0, 0, 0, 0, 0, 1 };

    static const char b_cv[5]{ 'j', 'n', 't', 'A', '2' };

    static const char b_cv4[5]{ 'f', 'i', 'x', 'e', 'd' };

    rigidBodyJoint *obj;
    robotics::manip::internal::CharacterVector s;
    double msubspace_data[36];
    double poslim_data[14];
    int exitg1;
    int homepos_size_idx_1;
    int i;
    int ibmat;
    int poslim_size_idx_0;
    signed char homepos_data[7];
    signed char b_tmp;
    bool result;
    obj = this;
    obj->InTree = false;
    for (i = 0; i < 16; i++) {
      b_tmp = iv[i];
      obj->JointToParentTransform[i] = b_tmp;
      obj->ChildToJointTransform[i] = b_tmp;
    }

    for (i = 0; i < 14; i++) {
      obj->PositionLimitsInternal[i] = 0.0;
    }

    for (i = 0; i < 7; i++) {
      obj->HomePositionInternal[i] = 0.0;
    }

    for (i = 0; i < 36; i++) {
      obj->MotionSubspaceInternal[i] = 0.0;
    }

    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    obj->NameInternal = s;
    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    obj->TypeInternal = s;
    s = obj->NameInternal;
    s.Length = 5.0;
    for (i = 0; i < 5; i++) {
      s.Vector[i] = b_cv[i];
    }

    obj->NameInternal = s;
    s = obj->TypeInternal;
    s.Length = 8.0;
    for (i = 0; i < 8; i++) {
      s.Vector[i] = b_cv1[i];
    }

    obj->TypeInternal = s;
    s = obj->TypeInternal;
    if (s.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(s.Length);
    }

    result = false;
    if (i == 8) {
      ibmat = 0;
      do {
        exitg1 = 0;
        if (ibmat < 8) {
          if (b_cv2[ibmat] != s.Vector[ibmat]) {
            exitg1 = 1;
          } else {
            ibmat++;
          }
        } else {
          result = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (result) {
      ibmat = 0;
    } else {
      result = false;
      if (i == 9) {
        ibmat = 0;
        do {
          exitg1 = 0;
          if (ibmat < 9) {
            if (cv1[ibmat] != s.Vector[ibmat]) {
              exitg1 = 1;
            } else {
              ibmat++;
            }
          } else {
            result = true;
            exitg1 = 1;
          }
        } while (exitg1 == 0);
      }

      if (result) {
        ibmat = 1;
      } else {
        result = false;
        if (i == 8) {
          ibmat = 0;
          do {
            exitg1 = 0;
            if (ibmat < 8) {
              if (b_cv3[ibmat] != s.Vector[ibmat]) {
                exitg1 = 1;
              } else {
                ibmat++;
              }
            } else {
              result = true;
              exitg1 = 1;
            }
          } while (exitg1 == 0);
        }

        if (result) {
          ibmat = 2;
        } else {
          ibmat = -1;
        }
      }
    }

    switch (ibmat) {
     case 0:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = b_iv[i];
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = -3.1415926535897931;
      poslim_data[1] = 3.1415926535897931;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      obj->VelocityNumber = 1.0;
      obj->PositionNumber = 1.0;
      obj->JointAxisInternal[0] = 0.0;
      obj->JointAxisInternal[1] = 0.0;
      obj->JointAxisInternal[2] = 1.0;
      break;

     case 1:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = b_iv1[i];
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = -0.5;
      poslim_data[1] = 0.5;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      obj->VelocityNumber = 1.0;
      obj->PositionNumber = 1.0;
      obj->JointAxisInternal[0] = 0.0;
      obj->JointAxisInternal[1] = 0.0;
      obj->JointAxisInternal[2] = 1.0;
      break;

     case 2:
      {
        signed char b_I[36];
        signed char b[6];
        for (i = 0; i < 36; i++) {
          b_I[i] = 0;
        }

        for (ibmat = 0; ibmat < 6; ibmat++) {
          b_I[ibmat + 6 * ibmat] = 1;
        }

        for (i = 0; i < 36; i++) {
          msubspace_data[i] = b_I[i];
        }

        poslim_size_idx_0 = 7;
        for (homepos_size_idx_1 = 0; homepos_size_idx_1 < 2; homepos_size_idx_1
             ++) {
          ibmat = homepos_size_idx_1 * 3;
          b_tmp = static_cast<signed char>(10 * homepos_size_idx_1 - 5);
          b[ibmat] = b_tmp;
          b[ibmat + 1] = b_tmp;
          b[ibmat + 2] = b_tmp;
          poslim_data[7 * homepos_size_idx_1] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 1] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 2] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 3] = rtNaN;
        }

        for (i = 0; i < 2; i++) {
          poslim_data[7 * i + 4] = b[3 * i];
          poslim_data[7 * i + 5] = b[3 * i + 1];
          poslim_data[7 * i + 6] = b[3 * i + 2];
        }

        homepos_size_idx_1 = 7;
        for (i = 0; i < 7; i++) {
          homepos_data[i] = iv2[i];
        }

        obj->VelocityNumber = 6.0;
        obj->PositionNumber = 7.0;
        obj->JointAxisInternal[0] = rtNaN;
        obj->JointAxisInternal[1] = rtNaN;
        obj->JointAxisInternal[2] = rtNaN;
      }
      break;

     default:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = 0.0;
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = 0.0;
      poslim_data[1] = 0.0;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      obj->VelocityNumber = 0.0;
      obj->PositionNumber = 0.0;
      obj->JointAxisInternal[0] = 0.0;
      obj->JointAxisInternal[1] = 0.0;
      obj->JointAxisInternal[2] = 0.0;
      break;
    }

    obj->set_MotionSubspace(msubspace_data);
    s = obj->TypeInternal;
    if (s.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(s.Length);
    }

    result = false;
    if (i == 5) {
      ibmat = 0;
      do {
        exitg1 = 0;
        if (ibmat < 5) {
          if (s.Vector[ibmat] != b_cv4[ibmat]) {
            exitg1 = 1;
          } else {
            ibmat++;
          }
        } else {
          result = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (!result) {
      double d;
      d = obj->PositionNumber;
      if (d < 1.0) {
        ibmat = 0;
      } else {
        ibmat = static_cast<int>(d);
      }

      for (i = 0; i < 2; i++) {
        for (int i1{0}; i1 < ibmat; i1++) {
          obj->PositionLimitsInternal[i1 + 7 * i] = poslim_data[i1 +
            poslim_size_idx_0 * i];
        }
      }

      for (i = 0; i < homepos_size_idx_1; i++) {
        obj->HomePositionInternal[i] = homepos_data[i];
      }
    } else {
      obj->PositionLimitsInternal[0] = poslim_data[0];
      obj->PositionLimitsInternal[7] = poslim_data[1];
      obj->HomePositionInternal[0] = homepos_data[0];
    }

    return obj;
  }

  //
  // Arguments    : void
  // Return Type  : collisionCapsule *
  //
  collisionCapsule *collisionCapsule::d_init()
  {
    void *geometryInternal;
    collisionCapsule *obj;
    obj = this;
    for (int i{0}; i < 16; i++) {
      obj->PoseInternal[i] = iv[i];
    }

    obj->RadiusInternal = 0.071;
    obj->LengthInternal = 0.331;
    geometryInternal = collisioncodegen_makeCapsule(0.071, 0.331);
    obj->GeometryInternal = geometryInternal;
    obj->matlabCodegenIsDeleted = false;
    return obj;
  }

  //
  // Arguments    : void
  // Return Type  : void
  //
  void rigidBodyJoint::d_setFixedTransform()
  {
    static const double inputTform[16]{ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0,
      0.0, 0.0, 1.0, 0.0, 0.445, 0.0, 0.0, 1.0 };

    for (int i{0}; i < 16; i++) {
      JointToParentTransform[i] = inputTform[i];
      ChildToJointTransform[i] = 0.0;
    }

    ChildToJointTransform[0] = 1.0;
    ChildToJointTransform[5] = 1.0;
    ChildToJointTransform[10] = 1.0;
    ChildToJointTransform[15] = 1.0;
  }

  //
  // Arguments    : void
  // Return Type  : void
  //
  void rigidBodyJoint::d_set_PositionLimits()
  {
    array<bool, 1U> x;
    double dv[2];
    double d;
    int ix;
    int loop_ub;
    bool resetHome;
    resetHome = false;
    switch (static_cast<int>(PositionNumber)) {
     case 0:
     case 7:
      break;

     default:
      {
        bool exitg1;
        bool y;
        d = PositionNumber;
        if (d < 1.0) {
          loop_ub = 0;
        } else {
          loop_ub = static_cast<int>(d);
        }

        x.set_size(loop_ub);
        for (ix = 0; ix < loop_ub; ix++) {
          x[ix] = (HomePositionInternal[ix] > 3.3161255787892259);
        }

        y = false;
        ix = 1;
        exitg1 = false;
        while ((!exitg1) && (ix <= x.size(0))) {
          if (x[ix - 1]) {
            y = true;
            exitg1 = true;
          } else {
            ix++;
          }
        }

        if (y) {
          resetHome = true;
        } else {
          x.set_size(loop_ub);
          for (ix = 0; ix < loop_ub; ix++) {
            x[ix] = (HomePositionInternal[ix] < -3.3161255787892259);
          }

          y = false;
          ix = 1;
          exitg1 = false;
          while ((!exitg1) && (ix <= x.size(0))) {
            if (x[ix - 1]) {
              y = true;
              exitg1 = true;
            } else {
              ix++;
            }
          }

          if (y) {
            resetHome = true;
          }
        }
      }
      break;
    }

    d = PositionNumber;
    dv[0] = -3.3161255787892259;
    dv[1] = 3.3161255787892259;
    if (d < 1.0) {
      loop_ub = 0;
    } else {
      loop_ub = static_cast<int>(d);
    }

    for (ix = 0; ix < 2; ix++) {
      for (int i{0}; i < loop_ub; i++) {
        PositionLimitsInternal[i + 7 * ix] = dv[i + loop_ub * ix];
      }
    }

    if (resetHome) {
      resetHomePosition();
    }
  }

  //
  // Arguments    : rigidBody &bodyin
  //                robotics::manip::internal::CollisionSet &iobj_0
  //                rigidBodyJoint &iobj_1
  //                robotics::manip::internal::RigidBody &iobj_2
  // Return Type  : void
  //
  void rigidBodyTree::e_addBody(rigidBody &bodyin, robotics::manip::internal::
    CollisionSet &iobj_0, rigidBodyJoint &iobj_1, robotics::manip::internal::
    RigidBody &iobj_2)
  {
    static const char b_cv[6]{ 'b', 'o', 'd', 'y', 'A', '3' };

    static const char b_cv1[5]{ 'f', 'i', 'x', 'e', 'd' };

    rigidBodyJoint *jnt;
    robotics::manip::internal::CharacterVector b_obj;
    robotics::manip::internal::RigidBody *b_bodyin;
    robotics::manip::internal::RigidBody *body;
    robotics::manip::internal::b_RigidBodyTree *obj;
    double b_index;
    int obj_size[2];
    int exitg1;
    int loop_ub;
    int pid;
    char obj_data[200];
    bool b_bool;
    obj = TreeInternal;
    b_bodyin = bodyin.BodyInternal;
    b_obj = b_bodyin->NameInternal;
    if (b_obj.Length < 1.0) {
      loop_ub = 0;
    } else {
      loop_ub = static_cast<int>(b_obj.Length);
    }

    obj_size[0] = 1;
    obj_size[1] = loop_ub;
    if (loop_ub - 1 >= 0) {
      ::std::copy(&b_obj.Vector[0], &b_obj.Vector[loop_ub], &obj_data[0]);
    }

    obj->findBodyIndexByName(obj_data, obj_size);
    pid = -1;
    b_obj = obj->Base.NameInternal;
    if (b_obj.Length < 1.0) {
      loop_ub = 0;
    } else {
      loop_ub = static_cast<int>(b_obj.Length);
    }

    b_bool = false;
    if (loop_ub == 6) {
      loop_ub = 0;
      do {
        exitg1 = 0;
        if (loop_ub < 6) {
          if (b_obj.Vector[loop_ub] != b_cv[loop_ub]) {
            exitg1 = 1;
          } else {
            loop_ub++;
          }
        } else {
          b_bool = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (b_bool) {
      pid = 0;
    } else {
      int i;
      bool exitg2;
      b_index = obj->NumBodies;
      i = 0;
      exitg2 = false;
      while ((!exitg2) && (i <= static_cast<int>(b_index) - 1)) {
        body = obj->Bodies[i];
        b_obj = body->NameInternal;
        if (b_obj.Length < 1.0) {
          loop_ub = 0;
        } else {
          loop_ub = static_cast<int>(b_obj.Length);
        }

        b_bool = false;
        if (loop_ub == 6) {
          loop_ub = 0;
          do {
            exitg1 = 0;
            if (loop_ub < 6) {
              if (b_obj.Vector[loop_ub] != b_cv[loop_ub]) {
                exitg1 = 1;
              } else {
                loop_ub++;
              }
            } else {
              b_bool = true;
              exitg1 = 1;
            }
          } while (exitg1 == 0);
        }

        if (b_bool) {
          pid = i + 1;
          exitg2 = true;
        } else {
          i++;
        }
      }
    }

    jnt = b_bodyin->JointInternal;
    b_obj = jnt->NameInternal;
    if (b_obj.Length < 1.0) {
      loop_ub = 0;
    } else {
      loop_ub = static_cast<int>(b_obj.Length);
    }

    obj_size[0] = 1;
    obj_size[1] = loop_ub;
    if (loop_ub - 1 >= 0) {
      ::std::copy(&b_obj.Vector[0], &b_obj.Vector[loop_ub], &obj_data[0]);
    }

    obj->findBodyIndexByJointName(obj_data, obj_size);
    b_index = obj->NumBodies + 1.0;
    body = b_bodyin->copy((&iobj_0)[0], (&iobj_1)[0], iobj_2);
    obj->Bodies[static_cast<int>(b_index) - 1] = body;
    body->Index = b_index;
    body->ParentIndex = pid;
    body->JointInternal->InTree = true;
    obj->NumBodies++;
    jnt = body->JointInternal;
    b_obj = jnt->TypeInternal;
    if (b_obj.Length < 1.0) {
      loop_ub = 0;
    } else {
      loop_ub = static_cast<int>(b_obj.Length);
    }

    b_bool = false;
    if (loop_ub == 5) {
      loop_ub = 0;
      do {
        exitg1 = 0;
        if (loop_ub < 5) {
          if (b_obj.Vector[loop_ub] != b_cv1[loop_ub]) {
            exitg1 = 1;
          } else {
            loop_ub++;
          }
        } else {
          b_bool = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (!b_bool) {
      obj->NumNonFixedBodies++;
      jnt = body->JointInternal;
      loop_ub = static_cast<int>(body->Index) - 1;
      obj->PositionDoFMap[loop_ub] = obj->PositionNumber + 1.0;
      obj->PositionDoFMap[loop_ub + 12] = obj->PositionNumber +
        jnt->PositionNumber;
      jnt = body->JointInternal;
      loop_ub = static_cast<int>(body->Index) - 1;
      obj->VelocityDoFMap[loop_ub] = obj->VelocityNumber + 1.0;
      obj->VelocityDoFMap[loop_ub + 12] = obj->VelocityNumber +
        jnt->VelocityNumber;
    } else {
      loop_ub = static_cast<int>(body->Index);
      obj->PositionDoFMap[loop_ub - 1] = 0.0;
      obj->PositionDoFMap[loop_ub + 11] = -1.0;
      loop_ub = static_cast<int>(body->Index);
      obj->VelocityDoFMap[loop_ub - 1] = 0.0;
      obj->VelocityDoFMap[loop_ub + 11] = -1.0;
    }

    jnt = body->JointInternal;
    obj->PositionNumber += jnt->PositionNumber;
    jnt = body->JointInternal;
    obj->VelocityNumber += jnt->VelocityNumber;
  }

  //
  // Arguments    : const collisionCapsule *varargin_1
  // Return Type  : void
  //
  void rigidBody::e_addCollision(const collisionCapsule *varargin_1)
  {
    static const double a[16]{ 0.9848, 0.0, -0.1736, 0.0, 0.0, 1.0, 0.0, 0.0,
      0.1736, 0.0, 0.9848, 0.0, 0.0, 0.0, 0.13, 1.0 };

    void *geometryInternal;
    collisionCapsule lobj_0;
    robotics::manip::internal::CollisionGeometry collisionGeometry;
    robotics::manip::internal::CollisionSet *b_obj;
    robotics::manip::internal::RigidBody *obj;
    double poseTform[16];
    double y[16];
    double length;
    double radius;
    obj = BodyInternal;
    for (int i{0}; i < 16; i++) {
      poseTform[i] = varargin_1->PoseInternal[i];
    }

    for (int i{0}; i < 4; i++) {
      double d;
      double d1;
      radius = a[i];
      length = a[i + 4];
      d = a[i + 8];
      d1 = a[i + 12];
      for (int i1{0}; i1 < 4; i1++) {
        int i2;
        i2 = i1 << 2;
        y[i + i2] = ((radius * poseTform[i2] + length * poseTform[i2 + 1]) + d *
                     poseTform[i2 + 2]) + d1 * poseTform[i2 + 3];
      }
    }

    radius = varargin_1->RadiusInternal;
    length = varargin_1->LengthInternal;
    lobj_0.RadiusInternal = radius;
    lobj_0.LengthInternal = length;
    geometryInternal = collisioncodegen_makeCapsule(radius, length);
    lobj_0.GeometryInternal = geometryInternal;
    lobj_0.matlabCodegenIsDeleted = false;
    for (int i{0}; i < 16; i++) {
      poseTform[i] = varargin_1->PoseInternal[i];
    }

    ::std::copy(&poseTform[0], &poseTform[16], &lobj_0.PoseInternal[0]);
    geometryInternal = collisioncodegen_makeCapsule(radius, length);
    collisionGeometry.CollisionPrimitive = geometryInternal;
    ::std::copy(&y[0], &y[16], &collisionGeometry.LocalPose[0]);
    ::std::copy(&y[0], &y[16], &collisionGeometry.WorldPose[0]);
    collisionGeometry.MeshScale[0] = 1.0;
    collisionGeometry.MeshScale[1] = 1.0;
    collisionGeometry.MeshScale[2] = 1.0;
    b_obj = obj->CollisionsInternal;
    if (b_obj->Size < b_obj->MaxElements) {
      b_obj->Size++;
      b_obj->CollisionGeometries[static_cast<int>(b_obj->Size) - 1] =
        collisionGeometry;
    }
  }

  //
  // Arguments    : robotics::manip::internal::RigidBodyTree &iobj_0
  //                robotics::manip::internal::CollisionSet &iobj_1
  //                rigidBodyJoint &iobj_2
  //                robotics::manip::internal::RigidBody &iobj_3
  // Return Type  : rigidBody *
  //
  rigidBody *rigidBody::e_init(robotics::manip::internal::RigidBodyTree &iobj_0,
    robotics::manip::internal::CollisionSet &iobj_1, rigidBodyJoint &iobj_2,
    robotics::manip::internal::RigidBody &iobj_3)
  {
    static const char b_cv1[10]{ 'b', 'o', 'd', 'y', 'A', '4', '_', 'j', 'n',
      't' };

    static const char b_cv3[8]{ 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };

    static const char b_cv4[8]{ 'f', 'l', 'o', 'a', 't', 'i', 'n', 'g' };

    static const signed char iv2[7]{ 1, 0, 0, 0, 0, 0, 0 };

    static const char b_cv[6]{ 'b', 'o', 'd', 'y', 'A', '4' };

    static const signed char b_iv[6]{ 0, 0, 1, 0, 0, 0 };

    static const signed char b_iv1[6]{ 0, 0, 0, 0, 0, 1 };

    static const char b_cv2[5]{ 'f', 'i', 'x', 'e', 'd' };

    static const char b_cv5[5]{ 'f', 'i', 'x', 'e', 'd' };

    rigidBody *obj;
    robotics::manip::internal::CharacterVector s;
    robotics::manip::internal::RigidBodyTree *b_default;
    double msubspace_data[36];
    double poslim_data[14];
    int exitg1;
    int homepos_size_idx_1;
    int i;
    int i1;
    int ibmat;
    int poslim_size_idx_0;
    signed char b_I[36];
    signed char c_I[9];
    signed char homepos_data[7];
    bool result;
    obj = this;
    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    iobj_3.NameInternal = s;
    s = iobj_3.NameInternal;
    s.Length = 6.0;
    for (i = 0; i < 6; i++) {
      s.Vector[i] = b_cv[i];
    }

    iobj_3.NameInternal = s;
    iobj_2.InTree = false;
    for (i = 0; i < 16; i++) {
      i1 = iv[i];
      iobj_2.JointToParentTransform[i] = i1;
      iobj_2.ChildToJointTransform[i] = i1;
    }

    for (i = 0; i < 14; i++) {
      iobj_2.PositionLimitsInternal[i] = 0.0;
    }

    for (i = 0; i < 7; i++) {
      iobj_2.HomePositionInternal[i] = 0.0;
    }

    for (i = 0; i < 36; i++) {
      iobj_2.MotionSubspaceInternal[i] = 0.0;
    }

    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    iobj_2.NameInternal = s;
    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    iobj_2.TypeInternal = s;
    s = iobj_2.NameInternal;
    s.Length = 10.0;
    for (i = 0; i < 10; i++) {
      s.Vector[i] = b_cv1[i];
    }

    iobj_2.NameInternal = s;
    s = iobj_2.TypeInternal;
    s.Length = 5.0;
    for (i = 0; i < 5; i++) {
      s.Vector[i] = b_cv2[i];
    }

    iobj_2.TypeInternal = s;
    s = iobj_2.TypeInternal;
    if (s.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(s.Length);
    }

    result = false;
    if (i == 8) {
      ibmat = 0;
      do {
        exitg1 = 0;
        if (ibmat < 8) {
          if (b_cv3[ibmat] != s.Vector[ibmat]) {
            exitg1 = 1;
          } else {
            ibmat++;
          }
        } else {
          result = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (result) {
      ibmat = 0;
    } else {
      result = false;
      if (i == 9) {
        ibmat = 0;
        do {
          exitg1 = 0;
          if (ibmat < 9) {
            if (cv1[ibmat] != s.Vector[ibmat]) {
              exitg1 = 1;
            } else {
              ibmat++;
            }
          } else {
            result = true;
            exitg1 = 1;
          }
        } while (exitg1 == 0);
      }

      if (result) {
        ibmat = 1;
      } else {
        result = false;
        if (i == 8) {
          ibmat = 0;
          do {
            exitg1 = 0;
            if (ibmat < 8) {
              if (b_cv4[ibmat] != s.Vector[ibmat]) {
                exitg1 = 1;
              } else {
                ibmat++;
              }
            } else {
              result = true;
              exitg1 = 1;
            }
          } while (exitg1 == 0);
        }

        if (result) {
          ibmat = 2;
        } else {
          ibmat = -1;
        }
      }
    }

    switch (ibmat) {
     case 0:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = b_iv[i];
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = -3.1415926535897931;
      poslim_data[1] = 3.1415926535897931;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      iobj_2.VelocityNumber = 1.0;
      iobj_2.PositionNumber = 1.0;
      iobj_2.JointAxisInternal[0] = 0.0;
      iobj_2.JointAxisInternal[1] = 0.0;
      iobj_2.JointAxisInternal[2] = 1.0;
      break;

     case 1:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = b_iv1[i];
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = -0.5;
      poslim_data[1] = 0.5;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      iobj_2.VelocityNumber = 1.0;
      iobj_2.PositionNumber = 1.0;
      iobj_2.JointAxisInternal[0] = 0.0;
      iobj_2.JointAxisInternal[1] = 0.0;
      iobj_2.JointAxisInternal[2] = 1.0;
      break;

     case 2:
      {
        signed char b[6];
        for (i = 0; i < 36; i++) {
          b_I[i] = 0;
        }

        for (ibmat = 0; ibmat < 6; ibmat++) {
          b_I[ibmat + 6 * ibmat] = 1;
        }

        for (i = 0; i < 36; i++) {
          msubspace_data[i] = b_I[i];
        }

        poslim_size_idx_0 = 7;
        for (homepos_size_idx_1 = 0; homepos_size_idx_1 < 2; homepos_size_idx_1
             ++) {
          signed char b_tmp;
          ibmat = homepos_size_idx_1 * 3;
          b_tmp = static_cast<signed char>(10 * homepos_size_idx_1 - 5);
          b[ibmat] = b_tmp;
          b[ibmat + 1] = b_tmp;
          b[ibmat + 2] = b_tmp;
          poslim_data[7 * homepos_size_idx_1] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 1] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 2] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 3] = rtNaN;
        }

        for (i = 0; i < 2; i++) {
          poslim_data[7 * i + 4] = b[3 * i];
          poslim_data[7 * i + 5] = b[3 * i + 1];
          poslim_data[7 * i + 6] = b[3 * i + 2];
        }

        homepos_size_idx_1 = 7;
        for (i = 0; i < 7; i++) {
          homepos_data[i] = iv2[i];
        }

        iobj_2.VelocityNumber = 6.0;
        iobj_2.PositionNumber = 7.0;
        iobj_2.JointAxisInternal[0] = rtNaN;
        iobj_2.JointAxisInternal[1] = rtNaN;
        iobj_2.JointAxisInternal[2] = rtNaN;
      }
      break;

     default:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = 0.0;
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = 0.0;
      poslim_data[1] = 0.0;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      iobj_2.VelocityNumber = 0.0;
      iobj_2.PositionNumber = 0.0;
      iobj_2.JointAxisInternal[0] = 0.0;
      iobj_2.JointAxisInternal[1] = 0.0;
      iobj_2.JointAxisInternal[2] = 0.0;
      break;
    }

    iobj_2.set_MotionSubspace(msubspace_data);
    s = iobj_2.TypeInternal;
    if (s.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(s.Length);
    }

    result = false;
    if (i == 5) {
      ibmat = 0;
      do {
        exitg1 = 0;
        if (ibmat < 5) {
          if (s.Vector[ibmat] != b_cv5[ibmat]) {
            exitg1 = 1;
          } else {
            ibmat++;
          }
        } else {
          result = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (!result) {
      double d;
      d = iobj_2.PositionNumber;
      if (d < 1.0) {
        ibmat = 0;
      } else {
        ibmat = static_cast<int>(d);
      }

      for (i = 0; i < 2; i++) {
        for (i1 = 0; i1 < ibmat; i1++) {
          iobj_2.PositionLimitsInternal[i1 + 7 * i] = poslim_data[i1 +
            poslim_size_idx_0 * i];
        }
      }

      for (i = 0; i < homepos_size_idx_1; i++) {
        iobj_2.HomePositionInternal[i] = homepos_data[i];
      }
    } else {
      iobj_2.PositionLimitsInternal[0] = poslim_data[0];
      iobj_2.PositionLimitsInternal[7] = poslim_data[1];
      iobj_2.HomePositionInternal[0] = homepos_data[0];
    }

    iobj_3.JointInternal = &iobj_2;
    iobj_3.Index = -1.0;
    iobj_3.ParentIndex = -1.0;
    iobj_3.MassInternal = 1.0;
    iobj_3.CenterOfMassInternal[0] = 0.0;
    iobj_3.CenterOfMassInternal[1] = 0.0;
    iobj_3.CenterOfMassInternal[2] = 0.0;
    for (i = 0; i < 9; i++) {
      c_I[i] = 0;
    }

    c_I[0] = 1;
    c_I[4] = 1;
    c_I[8] = 1;
    for (i = 0; i < 9; i++) {
      iobj_3.InertiaInternal[i] = c_I[i];
    }

    for (i = 0; i < 36; i++) {
      b_I[i] = 0;
    }

    for (ibmat = 0; ibmat < 6; ibmat++) {
      b_I[ibmat + 6 * ibmat] = 1;
    }

    for (i = 0; i < 36; i++) {
      iobj_3.SpatialInertia[i] = b_I[i];
    }

    iobj_3.CollisionsInternal = (&iobj_1)[0].init(static_cast<double>(0.0));
    iobj_3.matlabCodegenIsDeleted = false;
    b_default = iobj_0.init();
    iobj_3.CollisionsInternal = (&iobj_1)[1].init(1.0);
    obj->BodyInternal = &iobj_3;
    obj->TreeInternal = b_default;
    obj->matlabCodegenIsDeleted = false;
    return obj;
  }

  //
  // Arguments    : void
  // Return Type  : rigidBodyJoint *
  //
  rigidBodyJoint *rigidBodyJoint::e_init()
  {
    static const char b_cv1[8]{ 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };

    static const char b_cv2[8]{ 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };

    static const char b_cv3[8]{ 'f', 'l', 'o', 'a', 't', 'i', 'n', 'g' };

    static const signed char iv2[7]{ 1, 0, 0, 0, 0, 0, 0 };

    static const signed char b_iv[6]{ 0, 0, 1, 0, 0, 0 };

    static const signed char b_iv1[6]{ 0, 0, 0, 0, 0, 1 };

    static const char b_cv[5]{ 'j', 'n', 't', 'A', '3' };

    static const char b_cv4[5]{ 'f', 'i', 'x', 'e', 'd' };

    rigidBodyJoint *obj;
    robotics::manip::internal::CharacterVector s;
    double msubspace_data[36];
    double poslim_data[14];
    int exitg1;
    int homepos_size_idx_1;
    int i;
    int ibmat;
    int poslim_size_idx_0;
    signed char homepos_data[7];
    signed char b_tmp;
    bool result;
    obj = this;
    obj->InTree = false;
    for (i = 0; i < 16; i++) {
      b_tmp = iv[i];
      obj->JointToParentTransform[i] = b_tmp;
      obj->ChildToJointTransform[i] = b_tmp;
    }

    for (i = 0; i < 14; i++) {
      obj->PositionLimitsInternal[i] = 0.0;
    }

    for (i = 0; i < 7; i++) {
      obj->HomePositionInternal[i] = 0.0;
    }

    for (i = 0; i < 36; i++) {
      obj->MotionSubspaceInternal[i] = 0.0;
    }

    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    obj->NameInternal = s;
    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    obj->TypeInternal = s;
    s = obj->NameInternal;
    s.Length = 5.0;
    for (i = 0; i < 5; i++) {
      s.Vector[i] = b_cv[i];
    }

    obj->NameInternal = s;
    s = obj->TypeInternal;
    s.Length = 8.0;
    for (i = 0; i < 8; i++) {
      s.Vector[i] = b_cv1[i];
    }

    obj->TypeInternal = s;
    s = obj->TypeInternal;
    if (s.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(s.Length);
    }

    result = false;
    if (i == 8) {
      ibmat = 0;
      do {
        exitg1 = 0;
        if (ibmat < 8) {
          if (b_cv2[ibmat] != s.Vector[ibmat]) {
            exitg1 = 1;
          } else {
            ibmat++;
          }
        } else {
          result = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (result) {
      ibmat = 0;
    } else {
      result = false;
      if (i == 9) {
        ibmat = 0;
        do {
          exitg1 = 0;
          if (ibmat < 9) {
            if (cv1[ibmat] != s.Vector[ibmat]) {
              exitg1 = 1;
            } else {
              ibmat++;
            }
          } else {
            result = true;
            exitg1 = 1;
          }
        } while (exitg1 == 0);
      }

      if (result) {
        ibmat = 1;
      } else {
        result = false;
        if (i == 8) {
          ibmat = 0;
          do {
            exitg1 = 0;
            if (ibmat < 8) {
              if (b_cv3[ibmat] != s.Vector[ibmat]) {
                exitg1 = 1;
              } else {
                ibmat++;
              }
            } else {
              result = true;
              exitg1 = 1;
            }
          } while (exitg1 == 0);
        }

        if (result) {
          ibmat = 2;
        } else {
          ibmat = -1;
        }
      }
    }

    switch (ibmat) {
     case 0:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = b_iv[i];
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = -3.1415926535897931;
      poslim_data[1] = 3.1415926535897931;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      obj->VelocityNumber = 1.0;
      obj->PositionNumber = 1.0;
      obj->JointAxisInternal[0] = 0.0;
      obj->JointAxisInternal[1] = 0.0;
      obj->JointAxisInternal[2] = 1.0;
      break;

     case 1:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = b_iv1[i];
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = -0.5;
      poslim_data[1] = 0.5;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      obj->VelocityNumber = 1.0;
      obj->PositionNumber = 1.0;
      obj->JointAxisInternal[0] = 0.0;
      obj->JointAxisInternal[1] = 0.0;
      obj->JointAxisInternal[2] = 1.0;
      break;

     case 2:
      {
        signed char b_I[36];
        signed char b[6];
        for (i = 0; i < 36; i++) {
          b_I[i] = 0;
        }

        for (ibmat = 0; ibmat < 6; ibmat++) {
          b_I[ibmat + 6 * ibmat] = 1;
        }

        for (i = 0; i < 36; i++) {
          msubspace_data[i] = b_I[i];
        }

        poslim_size_idx_0 = 7;
        for (homepos_size_idx_1 = 0; homepos_size_idx_1 < 2; homepos_size_idx_1
             ++) {
          ibmat = homepos_size_idx_1 * 3;
          b_tmp = static_cast<signed char>(10 * homepos_size_idx_1 - 5);
          b[ibmat] = b_tmp;
          b[ibmat + 1] = b_tmp;
          b[ibmat + 2] = b_tmp;
          poslim_data[7 * homepos_size_idx_1] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 1] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 2] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 3] = rtNaN;
        }

        for (i = 0; i < 2; i++) {
          poslim_data[7 * i + 4] = b[3 * i];
          poslim_data[7 * i + 5] = b[3 * i + 1];
          poslim_data[7 * i + 6] = b[3 * i + 2];
        }

        homepos_size_idx_1 = 7;
        for (i = 0; i < 7; i++) {
          homepos_data[i] = iv2[i];
        }

        obj->VelocityNumber = 6.0;
        obj->PositionNumber = 7.0;
        obj->JointAxisInternal[0] = rtNaN;
        obj->JointAxisInternal[1] = rtNaN;
        obj->JointAxisInternal[2] = rtNaN;
      }
      break;

     default:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = 0.0;
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = 0.0;
      poslim_data[1] = 0.0;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      obj->VelocityNumber = 0.0;
      obj->PositionNumber = 0.0;
      obj->JointAxisInternal[0] = 0.0;
      obj->JointAxisInternal[1] = 0.0;
      obj->JointAxisInternal[2] = 0.0;
      break;
    }

    obj->set_MotionSubspace(msubspace_data);
    s = obj->TypeInternal;
    if (s.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(s.Length);
    }

    result = false;
    if (i == 5) {
      ibmat = 0;
      do {
        exitg1 = 0;
        if (ibmat < 5) {
          if (s.Vector[ibmat] != b_cv4[ibmat]) {
            exitg1 = 1;
          } else {
            ibmat++;
          }
        } else {
          result = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (!result) {
      double d;
      d = obj->PositionNumber;
      if (d < 1.0) {
        ibmat = 0;
      } else {
        ibmat = static_cast<int>(d);
      }

      for (i = 0; i < 2; i++) {
        for (int i1{0}; i1 < ibmat; i1++) {
          obj->PositionLimitsInternal[i1 + 7 * i] = poslim_data[i1 +
            poslim_size_idx_0 * i];
        }
      }

      for (i = 0; i < homepos_size_idx_1; i++) {
        obj->HomePositionInternal[i] = homepos_data[i];
      }
    } else {
      obj->PositionLimitsInternal[0] = poslim_data[0];
      obj->PositionLimitsInternal[7] = poslim_data[1];
      obj->HomePositionInternal[0] = homepos_data[0];
    }

    return obj;
  }

  //
  // Arguments    : void
  // Return Type  : collisionCapsule *
  //
  collisionCapsule *collisionCapsule::e_init()
  {
    void *geometryInternal;
    collisionCapsule *obj;
    obj = this;
    for (int i{0}; i < 16; i++) {
      obj->PoseInternal[i] = iv[i];
    }

    obj->RadiusInternal = 0.116;
    obj->LengthInternal = 0.2;
    geometryInternal = collisioncodegen_makeCapsule(0.116, 0.2);
    obj->GeometryInternal = geometryInternal;
    obj->matlabCodegenIsDeleted = false;
    return obj;
  }

  //
  // Arguments    : void
  // Return Type  : void
  //
  void rigidBodyJoint::e_setFixedTransform()
  {
    static const double inputTform[16]{ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0,
      0.0, 0.0, 1.0, 0.0, 0.04, 0.0, -0.0875, 1.0 };

    for (int i{0}; i < 16; i++) {
      JointToParentTransform[i] = inputTform[i];
      ChildToJointTransform[i] = 0.0;
    }

    ChildToJointTransform[0] = 1.0;
    ChildToJointTransform[5] = 1.0;
    ChildToJointTransform[10] = 1.0;
    ChildToJointTransform[15] = 1.0;
  }

  //
  // Arguments    : void
  // Return Type  : void
  //
  void rigidBodyJoint::e_set_PositionLimits()
  {
    array<bool, 1U> x;
    double dv[2];
    double d;
    int ix;
    int loop_ub;
    bool resetHome;
    resetHome = false;
    switch (static_cast<int>(PositionNumber)) {
     case 0:
     case 7:
      break;

     default:
      {
        bool exitg1;
        bool y;
        d = PositionNumber;
        if (d < 1.0) {
          loop_ub = 0;
        } else {
          loop_ub = static_cast<int>(d);
        }

        x.set_size(loop_ub);
        for (ix = 0; ix < loop_ub; ix++) {
          x[ix] = (HomePositionInternal[ix] > 2.3561944901923448);
        }

        y = false;
        ix = 1;
        exitg1 = false;
        while ((!exitg1) && (ix <= x.size(0))) {
          if (x[ix - 1]) {
            y = true;
            exitg1 = true;
          } else {
            ix++;
          }
        }

        if (y) {
          resetHome = true;
        } else {
          x.set_size(loop_ub);
          for (ix = 0; ix < loop_ub; ix++) {
            x[ix] = (HomePositionInternal[ix] < -2.3561944901923448);
          }

          y = false;
          ix = 1;
          exitg1 = false;
          while ((!exitg1) && (ix <= x.size(0))) {
            if (x[ix - 1]) {
              y = true;
              exitg1 = true;
            } else {
              ix++;
            }
          }

          if (y) {
            resetHome = true;
          }
        }
      }
      break;
    }

    d = PositionNumber;
    dv[0] = -2.3561944901923448;
    dv[1] = 2.3561944901923448;
    if (d < 1.0) {
      loop_ub = 0;
    } else {
      loop_ub = static_cast<int>(d);
    }

    for (ix = 0; ix < 2; ix++) {
      for (int i{0}; i < loop_ub; i++) {
        PositionLimitsInternal[i + 7 * ix] = dv[i + loop_ub * ix];
      }
    }

    if (resetHome) {
      resetHomePosition();
    }
  }

  //
  // Arguments    : const char obj1_data[]
  //                const int obj1_size[2]
  // Return Type  : bool
  //
  bool string::eq(const char obj1_data[], const int obj1_size[2])
  {
    static const char b_cv[7]{ 's', 'u', 'c', 'c', 'e', 's', 's' };

    bool equal;
    equal = false;
    if (obj1_size[1] == 7) {
      int kstr;
      kstr = 0;
      int exitg1;
      do {
        exitg1 = 0;
        if (kstr < 7) {
          if (obj1_data[kstr] != b_cv[kstr]) {
            exitg1 = 1;
          } else {
            kstr++;
          }
        } else {
          equal = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    return equal;
  }

  //
  // Arguments    : rigidBody &bodyin
  //                robotics::manip::internal::CollisionSet &iobj_0
  //                rigidBodyJoint &iobj_1
  //                robotics::manip::internal::RigidBody &iobj_2
  // Return Type  : void
  //
  void rigidBodyTree::f_addBody(rigidBody &bodyin, robotics::manip::internal::
    CollisionSet &iobj_0, rigidBodyJoint &iobj_1, robotics::manip::internal::
    RigidBody &iobj_2)
  {
    static const char b_cv[6]{ 'b', 'o', 'd', 'y', 'A', '4' };

    static const char b_cv1[5]{ 'f', 'i', 'x', 'e', 'd' };

    rigidBodyJoint *jnt;
    robotics::manip::internal::CharacterVector b_obj;
    robotics::manip::internal::RigidBody *b_bodyin;
    robotics::manip::internal::RigidBody *body;
    robotics::manip::internal::b_RigidBodyTree *obj;
    double b_index;
    int obj_size[2];
    int exitg1;
    int loop_ub;
    int pid;
    char obj_data[200];
    bool b_bool;
    obj = TreeInternal;
    b_bodyin = bodyin.BodyInternal;
    b_obj = b_bodyin->NameInternal;
    if (b_obj.Length < 1.0) {
      loop_ub = 0;
    } else {
      loop_ub = static_cast<int>(b_obj.Length);
    }

    obj_size[0] = 1;
    obj_size[1] = loop_ub;
    if (loop_ub - 1 >= 0) {
      ::std::copy(&b_obj.Vector[0], &b_obj.Vector[loop_ub], &obj_data[0]);
    }

    obj->findBodyIndexByName(obj_data, obj_size);
    pid = -1;
    b_obj = obj->Base.NameInternal;
    if (b_obj.Length < 1.0) {
      loop_ub = 0;
    } else {
      loop_ub = static_cast<int>(b_obj.Length);
    }

    b_bool = false;
    if (loop_ub == 6) {
      loop_ub = 0;
      do {
        exitg1 = 0;
        if (loop_ub < 6) {
          if (b_obj.Vector[loop_ub] != b_cv[loop_ub]) {
            exitg1 = 1;
          } else {
            loop_ub++;
          }
        } else {
          b_bool = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (b_bool) {
      pid = 0;
    } else {
      int i;
      bool exitg2;
      b_index = obj->NumBodies;
      i = 0;
      exitg2 = false;
      while ((!exitg2) && (i <= static_cast<int>(b_index) - 1)) {
        body = obj->Bodies[i];
        b_obj = body->NameInternal;
        if (b_obj.Length < 1.0) {
          loop_ub = 0;
        } else {
          loop_ub = static_cast<int>(b_obj.Length);
        }

        b_bool = false;
        if (loop_ub == 6) {
          loop_ub = 0;
          do {
            exitg1 = 0;
            if (loop_ub < 6) {
              if (b_obj.Vector[loop_ub] != b_cv[loop_ub]) {
                exitg1 = 1;
              } else {
                loop_ub++;
              }
            } else {
              b_bool = true;
              exitg1 = 1;
            }
          } while (exitg1 == 0);
        }

        if (b_bool) {
          pid = i + 1;
          exitg2 = true;
        } else {
          i++;
        }
      }
    }

    jnt = b_bodyin->JointInternal;
    b_obj = jnt->NameInternal;
    if (b_obj.Length < 1.0) {
      loop_ub = 0;
    } else {
      loop_ub = static_cast<int>(b_obj.Length);
    }

    obj_size[0] = 1;
    obj_size[1] = loop_ub;
    if (loop_ub - 1 >= 0) {
      ::std::copy(&b_obj.Vector[0], &b_obj.Vector[loop_ub], &obj_data[0]);
    }

    obj->findBodyIndexByJointName(obj_data, obj_size);
    b_index = obj->NumBodies + 1.0;
    body = b_bodyin->copy((&iobj_0)[0], (&iobj_1)[0], iobj_2);
    obj->Bodies[static_cast<int>(b_index) - 1] = body;
    body->Index = b_index;
    body->ParentIndex = pid;
    body->JointInternal->InTree = true;
    obj->NumBodies++;
    jnt = body->JointInternal;
    b_obj = jnt->TypeInternal;
    if (b_obj.Length < 1.0) {
      loop_ub = 0;
    } else {
      loop_ub = static_cast<int>(b_obj.Length);
    }

    b_bool = false;
    if (loop_ub == 5) {
      loop_ub = 0;
      do {
        exitg1 = 0;
        if (loop_ub < 5) {
          if (b_obj.Vector[loop_ub] != b_cv1[loop_ub]) {
            exitg1 = 1;
          } else {
            loop_ub++;
          }
        } else {
          b_bool = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (!b_bool) {
      obj->NumNonFixedBodies++;
      jnt = body->JointInternal;
      loop_ub = static_cast<int>(body->Index) - 1;
      obj->PositionDoFMap[loop_ub] = obj->PositionNumber + 1.0;
      obj->PositionDoFMap[loop_ub + 12] = obj->PositionNumber +
        jnt->PositionNumber;
      jnt = body->JointInternal;
      loop_ub = static_cast<int>(body->Index) - 1;
      obj->VelocityDoFMap[loop_ub] = obj->VelocityNumber + 1.0;
      obj->VelocityDoFMap[loop_ub + 12] = obj->VelocityNumber +
        jnt->VelocityNumber;
    } else {
      loop_ub = static_cast<int>(body->Index);
      obj->PositionDoFMap[loop_ub - 1] = 0.0;
      obj->PositionDoFMap[loop_ub + 11] = -1.0;
      loop_ub = static_cast<int>(body->Index);
      obj->VelocityDoFMap[loop_ub - 1] = 0.0;
      obj->VelocityDoFMap[loop_ub + 11] = -1.0;
    }

    jnt = body->JointInternal;
    obj->PositionNumber += jnt->PositionNumber;
    jnt = body->JointInternal;
    obj->VelocityNumber += jnt->VelocityNumber;
  }

  //
  // Arguments    : robotics::manip::internal::RigidBodyTree &iobj_0
  //                robotics::manip::internal::CollisionSet &iobj_1
  //                rigidBodyJoint &iobj_2
  //                robotics::manip::internal::RigidBody &iobj_3
  // Return Type  : rigidBody *
  //
  rigidBody *rigidBody::f_init(robotics::manip::internal::RigidBodyTree &iobj_0,
    robotics::manip::internal::CollisionSet &iobj_1, rigidBodyJoint &iobj_2,
    robotics::manip::internal::RigidBody &iobj_3)
  {
    static const char b_cv1[10]{ 'b', 'o', 'd', 'y', 'A', '5', '_', 'j', 'n',
      't' };

    static const char b_cv3[8]{ 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };

    static const char b_cv4[8]{ 'f', 'l', 'o', 'a', 't', 'i', 'n', 'g' };

    static const signed char iv2[7]{ 1, 0, 0, 0, 0, 0, 0 };

    static const char b_cv[6]{ 'b', 'o', 'd', 'y', 'A', '5' };

    static const signed char b_iv[6]{ 0, 0, 1, 0, 0, 0 };

    static const signed char b_iv1[6]{ 0, 0, 0, 0, 0, 1 };

    static const char b_cv2[5]{ 'f', 'i', 'x', 'e', 'd' };

    static const char b_cv5[5]{ 'f', 'i', 'x', 'e', 'd' };

    rigidBody *obj;
    robotics::manip::internal::CharacterVector s;
    robotics::manip::internal::RigidBodyTree *b_default;
    double msubspace_data[36];
    double poslim_data[14];
    int exitg1;
    int homepos_size_idx_1;
    int i;
    int i1;
    int ibmat;
    int poslim_size_idx_0;
    signed char b_I[36];
    signed char c_I[9];
    signed char homepos_data[7];
    bool result;
    obj = this;
    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    iobj_3.NameInternal = s;
    s = iobj_3.NameInternal;
    s.Length = 6.0;
    for (i = 0; i < 6; i++) {
      s.Vector[i] = b_cv[i];
    }

    iobj_3.NameInternal = s;
    iobj_2.InTree = false;
    for (i = 0; i < 16; i++) {
      i1 = iv[i];
      iobj_2.JointToParentTransform[i] = i1;
      iobj_2.ChildToJointTransform[i] = i1;
    }

    for (i = 0; i < 14; i++) {
      iobj_2.PositionLimitsInternal[i] = 0.0;
    }

    for (i = 0; i < 7; i++) {
      iobj_2.HomePositionInternal[i] = 0.0;
    }

    for (i = 0; i < 36; i++) {
      iobj_2.MotionSubspaceInternal[i] = 0.0;
    }

    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    iobj_2.NameInternal = s;
    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    iobj_2.TypeInternal = s;
    s = iobj_2.NameInternal;
    s.Length = 10.0;
    for (i = 0; i < 10; i++) {
      s.Vector[i] = b_cv1[i];
    }

    iobj_2.NameInternal = s;
    s = iobj_2.TypeInternal;
    s.Length = 5.0;
    for (i = 0; i < 5; i++) {
      s.Vector[i] = b_cv2[i];
    }

    iobj_2.TypeInternal = s;
    s = iobj_2.TypeInternal;
    if (s.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(s.Length);
    }

    result = false;
    if (i == 8) {
      ibmat = 0;
      do {
        exitg1 = 0;
        if (ibmat < 8) {
          if (b_cv3[ibmat] != s.Vector[ibmat]) {
            exitg1 = 1;
          } else {
            ibmat++;
          }
        } else {
          result = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (result) {
      ibmat = 0;
    } else {
      result = false;
      if (i == 9) {
        ibmat = 0;
        do {
          exitg1 = 0;
          if (ibmat < 9) {
            if (cv1[ibmat] != s.Vector[ibmat]) {
              exitg1 = 1;
            } else {
              ibmat++;
            }
          } else {
            result = true;
            exitg1 = 1;
          }
        } while (exitg1 == 0);
      }

      if (result) {
        ibmat = 1;
      } else {
        result = false;
        if (i == 8) {
          ibmat = 0;
          do {
            exitg1 = 0;
            if (ibmat < 8) {
              if (b_cv4[ibmat] != s.Vector[ibmat]) {
                exitg1 = 1;
              } else {
                ibmat++;
              }
            } else {
              result = true;
              exitg1 = 1;
            }
          } while (exitg1 == 0);
        }

        if (result) {
          ibmat = 2;
        } else {
          ibmat = -1;
        }
      }
    }

    switch (ibmat) {
     case 0:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = b_iv[i];
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = -3.1415926535897931;
      poslim_data[1] = 3.1415926535897931;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      iobj_2.VelocityNumber = 1.0;
      iobj_2.PositionNumber = 1.0;
      iobj_2.JointAxisInternal[0] = 0.0;
      iobj_2.JointAxisInternal[1] = 0.0;
      iobj_2.JointAxisInternal[2] = 1.0;
      break;

     case 1:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = b_iv1[i];
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = -0.5;
      poslim_data[1] = 0.5;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      iobj_2.VelocityNumber = 1.0;
      iobj_2.PositionNumber = 1.0;
      iobj_2.JointAxisInternal[0] = 0.0;
      iobj_2.JointAxisInternal[1] = 0.0;
      iobj_2.JointAxisInternal[2] = 1.0;
      break;

     case 2:
      {
        signed char b[6];
        for (i = 0; i < 36; i++) {
          b_I[i] = 0;
        }

        for (ibmat = 0; ibmat < 6; ibmat++) {
          b_I[ibmat + 6 * ibmat] = 1;
        }

        for (i = 0; i < 36; i++) {
          msubspace_data[i] = b_I[i];
        }

        poslim_size_idx_0 = 7;
        for (homepos_size_idx_1 = 0; homepos_size_idx_1 < 2; homepos_size_idx_1
             ++) {
          signed char b_tmp;
          ibmat = homepos_size_idx_1 * 3;
          b_tmp = static_cast<signed char>(10 * homepos_size_idx_1 - 5);
          b[ibmat] = b_tmp;
          b[ibmat + 1] = b_tmp;
          b[ibmat + 2] = b_tmp;
          poslim_data[7 * homepos_size_idx_1] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 1] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 2] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 3] = rtNaN;
        }

        for (i = 0; i < 2; i++) {
          poslim_data[7 * i + 4] = b[3 * i];
          poslim_data[7 * i + 5] = b[3 * i + 1];
          poslim_data[7 * i + 6] = b[3 * i + 2];
        }

        homepos_size_idx_1 = 7;
        for (i = 0; i < 7; i++) {
          homepos_data[i] = iv2[i];
        }

        iobj_2.VelocityNumber = 6.0;
        iobj_2.PositionNumber = 7.0;
        iobj_2.JointAxisInternal[0] = rtNaN;
        iobj_2.JointAxisInternal[1] = rtNaN;
        iobj_2.JointAxisInternal[2] = rtNaN;
      }
      break;

     default:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = 0.0;
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = 0.0;
      poslim_data[1] = 0.0;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      iobj_2.VelocityNumber = 0.0;
      iobj_2.PositionNumber = 0.0;
      iobj_2.JointAxisInternal[0] = 0.0;
      iobj_2.JointAxisInternal[1] = 0.0;
      iobj_2.JointAxisInternal[2] = 0.0;
      break;
    }

    iobj_2.set_MotionSubspace(msubspace_data);
    s = iobj_2.TypeInternal;
    if (s.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(s.Length);
    }

    result = false;
    if (i == 5) {
      ibmat = 0;
      do {
        exitg1 = 0;
        if (ibmat < 5) {
          if (s.Vector[ibmat] != b_cv5[ibmat]) {
            exitg1 = 1;
          } else {
            ibmat++;
          }
        } else {
          result = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (!result) {
      double d;
      d = iobj_2.PositionNumber;
      if (d < 1.0) {
        ibmat = 0;
      } else {
        ibmat = static_cast<int>(d);
      }

      for (i = 0; i < 2; i++) {
        for (i1 = 0; i1 < ibmat; i1++) {
          iobj_2.PositionLimitsInternal[i1 + 7 * i] = poslim_data[i1 +
            poslim_size_idx_0 * i];
        }
      }

      for (i = 0; i < homepos_size_idx_1; i++) {
        iobj_2.HomePositionInternal[i] = homepos_data[i];
      }
    } else {
      iobj_2.PositionLimitsInternal[0] = poslim_data[0];
      iobj_2.PositionLimitsInternal[7] = poslim_data[1];
      iobj_2.HomePositionInternal[0] = homepos_data[0];
    }

    iobj_3.JointInternal = &iobj_2;
    iobj_3.Index = -1.0;
    iobj_3.ParentIndex = -1.0;
    iobj_3.MassInternal = 1.0;
    iobj_3.CenterOfMassInternal[0] = 0.0;
    iobj_3.CenterOfMassInternal[1] = 0.0;
    iobj_3.CenterOfMassInternal[2] = 0.0;
    for (i = 0; i < 9; i++) {
      c_I[i] = 0;
    }

    c_I[0] = 1;
    c_I[4] = 1;
    c_I[8] = 1;
    for (i = 0; i < 9; i++) {
      iobj_3.InertiaInternal[i] = c_I[i];
    }

    for (i = 0; i < 36; i++) {
      b_I[i] = 0;
    }

    for (ibmat = 0; ibmat < 6; ibmat++) {
      b_I[ibmat + 6 * ibmat] = 1;
    }

    for (i = 0; i < 36; i++) {
      iobj_3.SpatialInertia[i] = b_I[i];
    }

    iobj_3.CollisionsInternal = iobj_1.init(static_cast<double>(0.0));
    iobj_3.matlabCodegenIsDeleted = false;
    b_default = iobj_0.init();
    obj->BodyInternal = &iobj_3;
    obj->TreeInternal = b_default;
    obj->matlabCodegenIsDeleted = false;
    return obj;
  }

  //
  // Arguments    : void
  // Return Type  : rigidBodyJoint *
  //
  rigidBodyJoint *rigidBodyJoint::f_init()
  {
    static const char b_cv1[8]{ 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };

    static const char b_cv2[8]{ 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };

    static const char b_cv3[8]{ 'f', 'l', 'o', 'a', 't', 'i', 'n', 'g' };

    static const signed char iv2[7]{ 1, 0, 0, 0, 0, 0, 0 };

    static const signed char b_iv[6]{ 0, 0, 1, 0, 0, 0 };

    static const signed char b_iv1[6]{ 0, 0, 0, 0, 0, 1 };

    static const char b_cv[5]{ 'j', 'n', 't', 'A', '4' };

    static const char b_cv4[5]{ 'f', 'i', 'x', 'e', 'd' };

    rigidBodyJoint *obj;
    robotics::manip::internal::CharacterVector s;
    double msubspace_data[36];
    double poslim_data[14];
    int exitg1;
    int homepos_size_idx_1;
    int i;
    int ibmat;
    int poslim_size_idx_0;
    signed char homepos_data[7];
    signed char b_tmp;
    bool result;
    obj = this;
    obj->InTree = false;
    for (i = 0; i < 16; i++) {
      b_tmp = iv[i];
      obj->JointToParentTransform[i] = b_tmp;
      obj->ChildToJointTransform[i] = b_tmp;
    }

    for (i = 0; i < 14; i++) {
      obj->PositionLimitsInternal[i] = 0.0;
    }

    for (i = 0; i < 7; i++) {
      obj->HomePositionInternal[i] = 0.0;
    }

    for (i = 0; i < 36; i++) {
      obj->MotionSubspaceInternal[i] = 0.0;
    }

    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    obj->NameInternal = s;
    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    obj->TypeInternal = s;
    s = obj->NameInternal;
    s.Length = 5.0;
    for (i = 0; i < 5; i++) {
      s.Vector[i] = b_cv[i];
    }

    obj->NameInternal = s;
    s = obj->TypeInternal;
    s.Length = 8.0;
    for (i = 0; i < 8; i++) {
      s.Vector[i] = b_cv1[i];
    }

    obj->TypeInternal = s;
    s = obj->TypeInternal;
    if (s.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(s.Length);
    }

    result = false;
    if (i == 8) {
      ibmat = 0;
      do {
        exitg1 = 0;
        if (ibmat < 8) {
          if (b_cv2[ibmat] != s.Vector[ibmat]) {
            exitg1 = 1;
          } else {
            ibmat++;
          }
        } else {
          result = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (result) {
      ibmat = 0;
    } else {
      result = false;
      if (i == 9) {
        ibmat = 0;
        do {
          exitg1 = 0;
          if (ibmat < 9) {
            if (cv1[ibmat] != s.Vector[ibmat]) {
              exitg1 = 1;
            } else {
              ibmat++;
            }
          } else {
            result = true;
            exitg1 = 1;
          }
        } while (exitg1 == 0);
      }

      if (result) {
        ibmat = 1;
      } else {
        result = false;
        if (i == 8) {
          ibmat = 0;
          do {
            exitg1 = 0;
            if (ibmat < 8) {
              if (b_cv3[ibmat] != s.Vector[ibmat]) {
                exitg1 = 1;
              } else {
                ibmat++;
              }
            } else {
              result = true;
              exitg1 = 1;
            }
          } while (exitg1 == 0);
        }

        if (result) {
          ibmat = 2;
        } else {
          ibmat = -1;
        }
      }
    }

    switch (ibmat) {
     case 0:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = b_iv[i];
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = -3.1415926535897931;
      poslim_data[1] = 3.1415926535897931;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      obj->VelocityNumber = 1.0;
      obj->PositionNumber = 1.0;
      obj->JointAxisInternal[0] = 0.0;
      obj->JointAxisInternal[1] = 0.0;
      obj->JointAxisInternal[2] = 1.0;
      break;

     case 1:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = b_iv1[i];
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = -0.5;
      poslim_data[1] = 0.5;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      obj->VelocityNumber = 1.0;
      obj->PositionNumber = 1.0;
      obj->JointAxisInternal[0] = 0.0;
      obj->JointAxisInternal[1] = 0.0;
      obj->JointAxisInternal[2] = 1.0;
      break;

     case 2:
      {
        signed char b_I[36];
        signed char b[6];
        for (i = 0; i < 36; i++) {
          b_I[i] = 0;
        }

        for (ibmat = 0; ibmat < 6; ibmat++) {
          b_I[ibmat + 6 * ibmat] = 1;
        }

        for (i = 0; i < 36; i++) {
          msubspace_data[i] = b_I[i];
        }

        poslim_size_idx_0 = 7;
        for (homepos_size_idx_1 = 0; homepos_size_idx_1 < 2; homepos_size_idx_1
             ++) {
          ibmat = homepos_size_idx_1 * 3;
          b_tmp = static_cast<signed char>(10 * homepos_size_idx_1 - 5);
          b[ibmat] = b_tmp;
          b[ibmat + 1] = b_tmp;
          b[ibmat + 2] = b_tmp;
          poslim_data[7 * homepos_size_idx_1] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 1] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 2] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 3] = rtNaN;
        }

        for (i = 0; i < 2; i++) {
          poslim_data[7 * i + 4] = b[3 * i];
          poslim_data[7 * i + 5] = b[3 * i + 1];
          poslim_data[7 * i + 6] = b[3 * i + 2];
        }

        homepos_size_idx_1 = 7;
        for (i = 0; i < 7; i++) {
          homepos_data[i] = iv2[i];
        }

        obj->VelocityNumber = 6.0;
        obj->PositionNumber = 7.0;
        obj->JointAxisInternal[0] = rtNaN;
        obj->JointAxisInternal[1] = rtNaN;
        obj->JointAxisInternal[2] = rtNaN;
      }
      break;

     default:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = 0.0;
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = 0.0;
      poslim_data[1] = 0.0;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      obj->VelocityNumber = 0.0;
      obj->PositionNumber = 0.0;
      obj->JointAxisInternal[0] = 0.0;
      obj->JointAxisInternal[1] = 0.0;
      obj->JointAxisInternal[2] = 0.0;
      break;
    }

    obj->set_MotionSubspace(msubspace_data);
    s = obj->TypeInternal;
    if (s.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(s.Length);
    }

    result = false;
    if (i == 5) {
      ibmat = 0;
      do {
        exitg1 = 0;
        if (ibmat < 5) {
          if (s.Vector[ibmat] != b_cv4[ibmat]) {
            exitg1 = 1;
          } else {
            ibmat++;
          }
        } else {
          result = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (!result) {
      double d;
      d = obj->PositionNumber;
      if (d < 1.0) {
        ibmat = 0;
      } else {
        ibmat = static_cast<int>(d);
      }

      for (i = 0; i < 2; i++) {
        for (int i1{0}; i1 < ibmat; i1++) {
          obj->PositionLimitsInternal[i1 + 7 * i] = poslim_data[i1 +
            poslim_size_idx_0 * i];
        }
      }

      for (i = 0; i < homepos_size_idx_1; i++) {
        obj->HomePositionInternal[i] = homepos_data[i];
      }
    } else {
      obj->PositionLimitsInternal[0] = poslim_data[0];
      obj->PositionLimitsInternal[7] = poslim_data[1];
      obj->HomePositionInternal[0] = homepos_data[0];
    }

    return obj;
  }

  //
  // Arguments    : void
  // Return Type  : void
  //
  void rigidBodyJoint::f_setFixedTransform()
  {
    static const double inputTform[16]{ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0,
      0.0, 0.0, 1.0, 0.0, 0.0, 0.0, -0.3575, 1.0 };

    for (int i{0}; i < 16; i++) {
      JointToParentTransform[i] = inputTform[i];
      ChildToJointTransform[i] = 0.0;
    }

    ChildToJointTransform[0] = 1.0;
    ChildToJointTransform[5] = 1.0;
    ChildToJointTransform[10] = 1.0;
    ChildToJointTransform[15] = 1.0;
  }

  //
  // Arguments    : void
  // Return Type  : void
  //
  void rigidBodyJoint::f_set_PositionLimits()
  {
    array<bool, 1U> x;
    double dv[2];
    double d;
    int ix;
    int loop_ub;
    bool resetHome;
    resetHome = false;
    switch (static_cast<int>(PositionNumber)) {
     case 0:
     case 7:
      break;

     default:
      {
        bool exitg1;
        bool y;
        d = PositionNumber;
        if (d < 1.0) {
          loop_ub = 0;
        } else {
          loop_ub = static_cast<int>(d);
        }

        x.set_size(loop_ub);
        for (ix = 0; ix < loop_ub; ix++) {
          x[ix] = (HomePositionInternal[ix] > 6.2831853071795862);
        }

        y = false;
        ix = 1;
        exitg1 = false;
        while ((!exitg1) && (ix <= x.size(0))) {
          if (x[ix - 1]) {
            y = true;
            exitg1 = true;
          } else {
            ix++;
          }
        }

        if (y) {
          resetHome = true;
        } else {
          x.set_size(loop_ub);
          for (ix = 0; ix < loop_ub; ix++) {
            x[ix] = (HomePositionInternal[ix] < -6.2831853071795862);
          }

          y = false;
          ix = 1;
          exitg1 = false;
          while ((!exitg1) && (ix <= x.size(0))) {
            if (x[ix - 1]) {
              y = true;
              exitg1 = true;
            } else {
              ix++;
            }
          }

          if (y) {
            resetHome = true;
          }
        }
      }
      break;
    }

    d = PositionNumber;
    dv[0] = -6.2831853071795862;
    dv[1] = 6.2831853071795862;
    if (d < 1.0) {
      loop_ub = 0;
    } else {
      loop_ub = static_cast<int>(d);
    }

    for (ix = 0; ix < 2; ix++) {
      for (int i{0}; i < loop_ub; i++) {
        PositionLimitsInternal[i + 7 * ix] = dv[i + loop_ub * ix];
      }
    }

    if (resetHome) {
      resetHomePosition();
    }
  }

  //
  // Arguments    : rigidBody &bodyin
  //                robotics::manip::internal::CollisionSet &iobj_0
  //                rigidBodyJoint &iobj_1
  //                robotics::manip::internal::RigidBody &iobj_2
  // Return Type  : void
  //
  void rigidBodyTree::g_addBody(rigidBody &bodyin, robotics::manip::internal::
    CollisionSet &iobj_0, rigidBodyJoint &iobj_1, robotics::manip::internal::
    RigidBody &iobj_2)
  {
    static const char b_cv[6]{ 'b', 'o', 'd', 'y', 'A', '5' };

    static const char b_cv1[5]{ 'f', 'i', 'x', 'e', 'd' };

    rigidBodyJoint *jnt;
    robotics::manip::internal::CharacterVector b_obj;
    robotics::manip::internal::RigidBody *b_bodyin;
    robotics::manip::internal::RigidBody *body;
    robotics::manip::internal::b_RigidBodyTree *obj;
    double b_index;
    int obj_size[2];
    int exitg1;
    int loop_ub;
    int pid;
    char obj_data[200];
    bool b_bool;
    obj = TreeInternal;
    b_bodyin = bodyin.BodyInternal;
    b_obj = b_bodyin->NameInternal;
    if (b_obj.Length < 1.0) {
      loop_ub = 0;
    } else {
      loop_ub = static_cast<int>(b_obj.Length);
    }

    obj_size[0] = 1;
    obj_size[1] = loop_ub;
    if (loop_ub - 1 >= 0) {
      ::std::copy(&b_obj.Vector[0], &b_obj.Vector[loop_ub], &obj_data[0]);
    }

    obj->findBodyIndexByName(obj_data, obj_size);
    pid = -1;
    b_obj = obj->Base.NameInternal;
    if (b_obj.Length < 1.0) {
      loop_ub = 0;
    } else {
      loop_ub = static_cast<int>(b_obj.Length);
    }

    b_bool = false;
    if (loop_ub == 6) {
      loop_ub = 0;
      do {
        exitg1 = 0;
        if (loop_ub < 6) {
          if (b_obj.Vector[loop_ub] != b_cv[loop_ub]) {
            exitg1 = 1;
          } else {
            loop_ub++;
          }
        } else {
          b_bool = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (b_bool) {
      pid = 0;
    } else {
      int i;
      bool exitg2;
      b_index = obj->NumBodies;
      i = 0;
      exitg2 = false;
      while ((!exitg2) && (i <= static_cast<int>(b_index) - 1)) {
        body = obj->Bodies[i];
        b_obj = body->NameInternal;
        if (b_obj.Length < 1.0) {
          loop_ub = 0;
        } else {
          loop_ub = static_cast<int>(b_obj.Length);
        }

        b_bool = false;
        if (loop_ub == 6) {
          loop_ub = 0;
          do {
            exitg1 = 0;
            if (loop_ub < 6) {
              if (b_obj.Vector[loop_ub] != b_cv[loop_ub]) {
                exitg1 = 1;
              } else {
                loop_ub++;
              }
            } else {
              b_bool = true;
              exitg1 = 1;
            }
          } while (exitg1 == 0);
        }

        if (b_bool) {
          pid = i + 1;
          exitg2 = true;
        } else {
          i++;
        }
      }
    }

    jnt = b_bodyin->JointInternal;
    b_obj = jnt->NameInternal;
    if (b_obj.Length < 1.0) {
      loop_ub = 0;
    } else {
      loop_ub = static_cast<int>(b_obj.Length);
    }

    obj_size[0] = 1;
    obj_size[1] = loop_ub;
    if (loop_ub - 1 >= 0) {
      ::std::copy(&b_obj.Vector[0], &b_obj.Vector[loop_ub], &obj_data[0]);
    }

    obj->findBodyIndexByJointName(obj_data, obj_size);
    b_index = obj->NumBodies + 1.0;
    body = b_bodyin->copy((&iobj_0)[0], (&iobj_1)[0], iobj_2);
    obj->Bodies[static_cast<int>(b_index) - 1] = body;
    body->Index = b_index;
    body->ParentIndex = pid;
    body->JointInternal->InTree = true;
    obj->NumBodies++;
    jnt = body->JointInternal;
    b_obj = jnt->TypeInternal;
    if (b_obj.Length < 1.0) {
      loop_ub = 0;
    } else {
      loop_ub = static_cast<int>(b_obj.Length);
    }

    b_bool = false;
    if (loop_ub == 5) {
      loop_ub = 0;
      do {
        exitg1 = 0;
        if (loop_ub < 5) {
          if (b_obj.Vector[loop_ub] != b_cv1[loop_ub]) {
            exitg1 = 1;
          } else {
            loop_ub++;
          }
        } else {
          b_bool = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (!b_bool) {
      obj->NumNonFixedBodies++;
      jnt = body->JointInternal;
      loop_ub = static_cast<int>(body->Index) - 1;
      obj->PositionDoFMap[loop_ub] = obj->PositionNumber + 1.0;
      obj->PositionDoFMap[loop_ub + 12] = obj->PositionNumber +
        jnt->PositionNumber;
      jnt = body->JointInternal;
      loop_ub = static_cast<int>(body->Index) - 1;
      obj->VelocityDoFMap[loop_ub] = obj->VelocityNumber + 1.0;
      obj->VelocityDoFMap[loop_ub + 12] = obj->VelocityNumber +
        jnt->VelocityNumber;
    } else {
      loop_ub = static_cast<int>(body->Index);
      obj->PositionDoFMap[loop_ub - 1] = 0.0;
      obj->PositionDoFMap[loop_ub + 11] = -1.0;
      loop_ub = static_cast<int>(body->Index);
      obj->VelocityDoFMap[loop_ub - 1] = 0.0;
      obj->VelocityDoFMap[loop_ub + 11] = -1.0;
    }

    jnt = body->JointInternal;
    obj->PositionNumber += jnt->PositionNumber;
    jnt = body->JointInternal;
    obj->VelocityNumber += jnt->VelocityNumber;
  }

  //
  // Arguments    : robotics::manip::internal::RigidBodyTree &iobj_0
  //                robotics::manip::internal::CollisionSet &iobj_1
  //                rigidBodyJoint &iobj_2
  //                robotics::manip::internal::RigidBody &iobj_3
  // Return Type  : rigidBody *
  //
  rigidBody *rigidBody::g_init(robotics::manip::internal::RigidBodyTree &iobj_0,
    robotics::manip::internal::CollisionSet &iobj_1, rigidBodyJoint &iobj_2,
    robotics::manip::internal::RigidBody &iobj_3)
  {
    static const char b_cv1[10]{ 'b', 'o', 'd', 'y', 'A', '6', '_', 'j', 'n',
      't' };

    static const char b_cv3[8]{ 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };

    static const char b_cv4[8]{ 'f', 'l', 'o', 'a', 't', 'i', 'n', 'g' };

    static const signed char iv2[7]{ 1, 0, 0, 0, 0, 0, 0 };

    static const char b_cv[6]{ 'b', 'o', 'd', 'y', 'A', '6' };

    static const signed char b_iv[6]{ 0, 0, 1, 0, 0, 0 };

    static const signed char b_iv1[6]{ 0, 0, 0, 0, 0, 1 };

    static const char b_cv2[5]{ 'f', 'i', 'x', 'e', 'd' };

    static const char b_cv5[5]{ 'f', 'i', 'x', 'e', 'd' };

    rigidBody *obj;
    robotics::manip::internal::CharacterVector s;
    robotics::manip::internal::RigidBodyTree *b_default;
    double msubspace_data[36];
    double poslim_data[14];
    int exitg1;
    int homepos_size_idx_1;
    int i;
    int i1;
    int ibmat;
    int poslim_size_idx_0;
    signed char b_I[36];
    signed char c_I[9];
    signed char homepos_data[7];
    bool result;
    obj = this;
    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    iobj_3.NameInternal = s;
    s = iobj_3.NameInternal;
    s.Length = 6.0;
    for (i = 0; i < 6; i++) {
      s.Vector[i] = b_cv[i];
    }

    iobj_3.NameInternal = s;
    iobj_2.InTree = false;
    for (i = 0; i < 16; i++) {
      i1 = iv[i];
      iobj_2.JointToParentTransform[i] = i1;
      iobj_2.ChildToJointTransform[i] = i1;
    }

    for (i = 0; i < 14; i++) {
      iobj_2.PositionLimitsInternal[i] = 0.0;
    }

    for (i = 0; i < 7; i++) {
      iobj_2.HomePositionInternal[i] = 0.0;
    }

    for (i = 0; i < 36; i++) {
      iobj_2.MotionSubspaceInternal[i] = 0.0;
    }

    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    iobj_2.NameInternal = s;
    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    iobj_2.TypeInternal = s;
    s = iobj_2.NameInternal;
    s.Length = 10.0;
    for (i = 0; i < 10; i++) {
      s.Vector[i] = b_cv1[i];
    }

    iobj_2.NameInternal = s;
    s = iobj_2.TypeInternal;
    s.Length = 5.0;
    for (i = 0; i < 5; i++) {
      s.Vector[i] = b_cv2[i];
    }

    iobj_2.TypeInternal = s;
    s = iobj_2.TypeInternal;
    if (s.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(s.Length);
    }

    result = false;
    if (i == 8) {
      ibmat = 0;
      do {
        exitg1 = 0;
        if (ibmat < 8) {
          if (b_cv3[ibmat] != s.Vector[ibmat]) {
            exitg1 = 1;
          } else {
            ibmat++;
          }
        } else {
          result = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (result) {
      ibmat = 0;
    } else {
      result = false;
      if (i == 9) {
        ibmat = 0;
        do {
          exitg1 = 0;
          if (ibmat < 9) {
            if (cv1[ibmat] != s.Vector[ibmat]) {
              exitg1 = 1;
            } else {
              ibmat++;
            }
          } else {
            result = true;
            exitg1 = 1;
          }
        } while (exitg1 == 0);
      }

      if (result) {
        ibmat = 1;
      } else {
        result = false;
        if (i == 8) {
          ibmat = 0;
          do {
            exitg1 = 0;
            if (ibmat < 8) {
              if (b_cv4[ibmat] != s.Vector[ibmat]) {
                exitg1 = 1;
              } else {
                ibmat++;
              }
            } else {
              result = true;
              exitg1 = 1;
            }
          } while (exitg1 == 0);
        }

        if (result) {
          ibmat = 2;
        } else {
          ibmat = -1;
        }
      }
    }

    switch (ibmat) {
     case 0:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = b_iv[i];
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = -3.1415926535897931;
      poslim_data[1] = 3.1415926535897931;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      iobj_2.VelocityNumber = 1.0;
      iobj_2.PositionNumber = 1.0;
      iobj_2.JointAxisInternal[0] = 0.0;
      iobj_2.JointAxisInternal[1] = 0.0;
      iobj_2.JointAxisInternal[2] = 1.0;
      break;

     case 1:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = b_iv1[i];
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = -0.5;
      poslim_data[1] = 0.5;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      iobj_2.VelocityNumber = 1.0;
      iobj_2.PositionNumber = 1.0;
      iobj_2.JointAxisInternal[0] = 0.0;
      iobj_2.JointAxisInternal[1] = 0.0;
      iobj_2.JointAxisInternal[2] = 1.0;
      break;

     case 2:
      {
        signed char b[6];
        for (i = 0; i < 36; i++) {
          b_I[i] = 0;
        }

        for (ibmat = 0; ibmat < 6; ibmat++) {
          b_I[ibmat + 6 * ibmat] = 1;
        }

        for (i = 0; i < 36; i++) {
          msubspace_data[i] = b_I[i];
        }

        poslim_size_idx_0 = 7;
        for (homepos_size_idx_1 = 0; homepos_size_idx_1 < 2; homepos_size_idx_1
             ++) {
          signed char b_tmp;
          ibmat = homepos_size_idx_1 * 3;
          b_tmp = static_cast<signed char>(10 * homepos_size_idx_1 - 5);
          b[ibmat] = b_tmp;
          b[ibmat + 1] = b_tmp;
          b[ibmat + 2] = b_tmp;
          poslim_data[7 * homepos_size_idx_1] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 1] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 2] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 3] = rtNaN;
        }

        for (i = 0; i < 2; i++) {
          poslim_data[7 * i + 4] = b[3 * i];
          poslim_data[7 * i + 5] = b[3 * i + 1];
          poslim_data[7 * i + 6] = b[3 * i + 2];
        }

        homepos_size_idx_1 = 7;
        for (i = 0; i < 7; i++) {
          homepos_data[i] = iv2[i];
        }

        iobj_2.VelocityNumber = 6.0;
        iobj_2.PositionNumber = 7.0;
        iobj_2.JointAxisInternal[0] = rtNaN;
        iobj_2.JointAxisInternal[1] = rtNaN;
        iobj_2.JointAxisInternal[2] = rtNaN;
      }
      break;

     default:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = 0.0;
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = 0.0;
      poslim_data[1] = 0.0;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      iobj_2.VelocityNumber = 0.0;
      iobj_2.PositionNumber = 0.0;
      iobj_2.JointAxisInternal[0] = 0.0;
      iobj_2.JointAxisInternal[1] = 0.0;
      iobj_2.JointAxisInternal[2] = 0.0;
      break;
    }

    iobj_2.set_MotionSubspace(msubspace_data);
    s = iobj_2.TypeInternal;
    if (s.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(s.Length);
    }

    result = false;
    if (i == 5) {
      ibmat = 0;
      do {
        exitg1 = 0;
        if (ibmat < 5) {
          if (s.Vector[ibmat] != b_cv5[ibmat]) {
            exitg1 = 1;
          } else {
            ibmat++;
          }
        } else {
          result = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (!result) {
      double d;
      d = iobj_2.PositionNumber;
      if (d < 1.0) {
        ibmat = 0;
      } else {
        ibmat = static_cast<int>(d);
      }

      for (i = 0; i < 2; i++) {
        for (i1 = 0; i1 < ibmat; i1++) {
          iobj_2.PositionLimitsInternal[i1 + 7 * i] = poslim_data[i1 +
            poslim_size_idx_0 * i];
        }
      }

      for (i = 0; i < homepos_size_idx_1; i++) {
        iobj_2.HomePositionInternal[i] = homepos_data[i];
      }
    } else {
      iobj_2.PositionLimitsInternal[0] = poslim_data[0];
      iobj_2.PositionLimitsInternal[7] = poslim_data[1];
      iobj_2.HomePositionInternal[0] = homepos_data[0];
    }

    iobj_3.JointInternal = &iobj_2;
    iobj_3.Index = -1.0;
    iobj_3.ParentIndex = -1.0;
    iobj_3.MassInternal = 1.0;
    iobj_3.CenterOfMassInternal[0] = 0.0;
    iobj_3.CenterOfMassInternal[1] = 0.0;
    iobj_3.CenterOfMassInternal[2] = 0.0;
    for (i = 0; i < 9; i++) {
      c_I[i] = 0;
    }

    c_I[0] = 1;
    c_I[4] = 1;
    c_I[8] = 1;
    for (i = 0; i < 9; i++) {
      iobj_3.InertiaInternal[i] = c_I[i];
    }

    for (i = 0; i < 36; i++) {
      b_I[i] = 0;
    }

    for (ibmat = 0; ibmat < 6; ibmat++) {
      b_I[ibmat + 6 * ibmat] = 1;
    }

    for (i = 0; i < 36; i++) {
      iobj_3.SpatialInertia[i] = b_I[i];
    }

    iobj_3.CollisionsInternal = iobj_1.init(static_cast<double>(0.0));
    iobj_3.matlabCodegenIsDeleted = false;
    b_default = iobj_0.init();
    obj->BodyInternal = &iobj_3;
    obj->TreeInternal = b_default;
    obj->matlabCodegenIsDeleted = false;
    return obj;
  }

  //
  // Arguments    : void
  // Return Type  : rigidBodyJoint *
  //
  rigidBodyJoint *rigidBodyJoint::g_init()
  {
    static const char b_cv1[8]{ 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };

    static const char b_cv2[8]{ 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };

    static const char b_cv3[8]{ 'f', 'l', 'o', 'a', 't', 'i', 'n', 'g' };

    static const signed char iv2[7]{ 1, 0, 0, 0, 0, 0, 0 };

    static const signed char b_iv[6]{ 0, 0, 1, 0, 0, 0 };

    static const signed char b_iv1[6]{ 0, 0, 0, 0, 0, 1 };

    static const char b_cv[5]{ 'j', 'n', 't', 'A', '5' };

    static const char b_cv4[5]{ 'f', 'i', 'x', 'e', 'd' };

    rigidBodyJoint *obj;
    robotics::manip::internal::CharacterVector s;
    double msubspace_data[36];
    double poslim_data[14];
    int exitg1;
    int homepos_size_idx_1;
    int i;
    int ibmat;
    int poslim_size_idx_0;
    signed char homepos_data[7];
    signed char b_tmp;
    bool result;
    obj = this;
    obj->InTree = false;
    for (i = 0; i < 16; i++) {
      b_tmp = iv[i];
      obj->JointToParentTransform[i] = b_tmp;
      obj->ChildToJointTransform[i] = b_tmp;
    }

    for (i = 0; i < 14; i++) {
      obj->PositionLimitsInternal[i] = 0.0;
    }

    for (i = 0; i < 7; i++) {
      obj->HomePositionInternal[i] = 0.0;
    }

    for (i = 0; i < 36; i++) {
      obj->MotionSubspaceInternal[i] = 0.0;
    }

    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    obj->NameInternal = s;
    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    obj->TypeInternal = s;
    s = obj->NameInternal;
    s.Length = 5.0;
    for (i = 0; i < 5; i++) {
      s.Vector[i] = b_cv[i];
    }

    obj->NameInternal = s;
    s = obj->TypeInternal;
    s.Length = 8.0;
    for (i = 0; i < 8; i++) {
      s.Vector[i] = b_cv1[i];
    }

    obj->TypeInternal = s;
    s = obj->TypeInternal;
    if (s.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(s.Length);
    }

    result = false;
    if (i == 8) {
      ibmat = 0;
      do {
        exitg1 = 0;
        if (ibmat < 8) {
          if (b_cv2[ibmat] != s.Vector[ibmat]) {
            exitg1 = 1;
          } else {
            ibmat++;
          }
        } else {
          result = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (result) {
      ibmat = 0;
    } else {
      result = false;
      if (i == 9) {
        ibmat = 0;
        do {
          exitg1 = 0;
          if (ibmat < 9) {
            if (cv1[ibmat] != s.Vector[ibmat]) {
              exitg1 = 1;
            } else {
              ibmat++;
            }
          } else {
            result = true;
            exitg1 = 1;
          }
        } while (exitg1 == 0);
      }

      if (result) {
        ibmat = 1;
      } else {
        result = false;
        if (i == 8) {
          ibmat = 0;
          do {
            exitg1 = 0;
            if (ibmat < 8) {
              if (b_cv3[ibmat] != s.Vector[ibmat]) {
                exitg1 = 1;
              } else {
                ibmat++;
              }
            } else {
              result = true;
              exitg1 = 1;
            }
          } while (exitg1 == 0);
        }

        if (result) {
          ibmat = 2;
        } else {
          ibmat = -1;
        }
      }
    }

    switch (ibmat) {
     case 0:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = b_iv[i];
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = -3.1415926535897931;
      poslim_data[1] = 3.1415926535897931;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      obj->VelocityNumber = 1.0;
      obj->PositionNumber = 1.0;
      obj->JointAxisInternal[0] = 0.0;
      obj->JointAxisInternal[1] = 0.0;
      obj->JointAxisInternal[2] = 1.0;
      break;

     case 1:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = b_iv1[i];
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = -0.5;
      poslim_data[1] = 0.5;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      obj->VelocityNumber = 1.0;
      obj->PositionNumber = 1.0;
      obj->JointAxisInternal[0] = 0.0;
      obj->JointAxisInternal[1] = 0.0;
      obj->JointAxisInternal[2] = 1.0;
      break;

     case 2:
      {
        signed char b_I[36];
        signed char b[6];
        for (i = 0; i < 36; i++) {
          b_I[i] = 0;
        }

        for (ibmat = 0; ibmat < 6; ibmat++) {
          b_I[ibmat + 6 * ibmat] = 1;
        }

        for (i = 0; i < 36; i++) {
          msubspace_data[i] = b_I[i];
        }

        poslim_size_idx_0 = 7;
        for (homepos_size_idx_1 = 0; homepos_size_idx_1 < 2; homepos_size_idx_1
             ++) {
          ibmat = homepos_size_idx_1 * 3;
          b_tmp = static_cast<signed char>(10 * homepos_size_idx_1 - 5);
          b[ibmat] = b_tmp;
          b[ibmat + 1] = b_tmp;
          b[ibmat + 2] = b_tmp;
          poslim_data[7 * homepos_size_idx_1] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 1] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 2] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 3] = rtNaN;
        }

        for (i = 0; i < 2; i++) {
          poslim_data[7 * i + 4] = b[3 * i];
          poslim_data[7 * i + 5] = b[3 * i + 1];
          poslim_data[7 * i + 6] = b[3 * i + 2];
        }

        homepos_size_idx_1 = 7;
        for (i = 0; i < 7; i++) {
          homepos_data[i] = iv2[i];
        }

        obj->VelocityNumber = 6.0;
        obj->PositionNumber = 7.0;
        obj->JointAxisInternal[0] = rtNaN;
        obj->JointAxisInternal[1] = rtNaN;
        obj->JointAxisInternal[2] = rtNaN;
      }
      break;

     default:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = 0.0;
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = 0.0;
      poslim_data[1] = 0.0;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      obj->VelocityNumber = 0.0;
      obj->PositionNumber = 0.0;
      obj->JointAxisInternal[0] = 0.0;
      obj->JointAxisInternal[1] = 0.0;
      obj->JointAxisInternal[2] = 0.0;
      break;
    }

    obj->set_MotionSubspace(msubspace_data);
    s = obj->TypeInternal;
    if (s.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(s.Length);
    }

    result = false;
    if (i == 5) {
      ibmat = 0;
      do {
        exitg1 = 0;
        if (ibmat < 5) {
          if (s.Vector[ibmat] != b_cv4[ibmat]) {
            exitg1 = 1;
          } else {
            ibmat++;
          }
        } else {
          result = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (!result) {
      double d;
      d = obj->PositionNumber;
      if (d < 1.0) {
        ibmat = 0;
      } else {
        ibmat = static_cast<int>(d);
      }

      for (i = 0; i < 2; i++) {
        for (int i1{0}; i1 < ibmat; i1++) {
          obj->PositionLimitsInternal[i1 + 7 * i] = poslim_data[i1 +
            poslim_size_idx_0 * i];
        }
      }

      for (i = 0; i < homepos_size_idx_1; i++) {
        obj->HomePositionInternal[i] = homepos_data[i];
      }
    } else {
      obj->PositionLimitsInternal[0] = poslim_data[0];
      obj->PositionLimitsInternal[7] = poslim_data[1];
      obj->HomePositionInternal[0] = homepos_data[0];
    }

    return obj;
  }

  //
  // Arguments    : void
  // Return Type  : void
  //
  void rigidBodyJoint::g_setFixedTransform()
  {
    static const double inputTform[16]{ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0,
      0.0, 0.0, 1.0, 0.0, 0.0, 0.0, -0.0865, 1.0 };

    for (int i{0}; i < 16; i++) {
      JointToParentTransform[i] = inputTform[i];
      ChildToJointTransform[i] = 0.0;
    }

    ChildToJointTransform[0] = 1.0;
    ChildToJointTransform[5] = 1.0;
    ChildToJointTransform[10] = 1.0;
    ChildToJointTransform[15] = 1.0;
  }

  //
  // Arguments    : const double varargin_1[6]
  //                double T[16]
  // Return Type  : void
  //
  void rigidBodyTree::getTransform(const double varargin_1[6], double T[16])
  {
    static const char b_cv[6]{ 'b', 'o', 'd', 'y', 'E', 'E' };

    robotics::manip::internal::CharacterVector b_obj;
    robotics::manip::internal::RigidBody *c_obj;
    robotics::manip::internal::b_RigidBodyTree *obj;
    cell_wrap_41 Ttree_data[12];
    double T1[16];
    double T2[16];
    double R[9];
    double b_R[9];
    double c_R[3];
    double bid2;
    int Ttree_size[2];
    int bid1;
    int exitg1;
    int i;
    int kstr;
    bool b_bool;
    obj = TreeInternal;
    obj->forwardKinematics(varargin_1, Ttree_data, Ttree_size);
    bid1 = -2;
    b_obj = obj->Base.NameInternal;
    if (b_obj.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(b_obj.Length);
    }

    b_bool = false;
    if (i == 6) {
      kstr = 0;
      do {
        exitg1 = 0;
        if (kstr < 6) {
          if (b_obj.Vector[kstr] != b_cv[kstr]) {
            exitg1 = 1;
          } else {
            kstr++;
          }
        } else {
          b_bool = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (b_bool) {
      bid1 = -1;
    } else {
      int b_i;
      bool exitg2;
      bid2 = obj->NumBodies;
      b_i = 0;
      exitg2 = false;
      while ((!exitg2) && (b_i <= static_cast<int>(bid2) - 1)) {
        c_obj = obj->Bodies[b_i];
        b_obj = c_obj->NameInternal;
        if (b_obj.Length < 1.0) {
          i = 0;
        } else {
          i = static_cast<int>(b_obj.Length);
        }

        b_bool = false;
        if (i == 6) {
          kstr = 0;
          do {
            exitg1 = 0;
            if (kstr < 6) {
              if (b_obj.Vector[kstr] != b_cv[kstr]) {
                exitg1 = 1;
              } else {
                kstr++;
              }
            } else {
              b_bool = true;
              exitg1 = 1;
            }
          } while (exitg1 == 0);
        }

        if (b_bool) {
          bid1 = b_i;
          exitg2 = true;
        } else {
          b_i++;
        }
      }
    }

    if (bid1 + 1 == 0) {
      std::memset(&T1[0], 0, 16U * sizeof(double));
      T1[0] = 1.0;
      T1[5] = 1.0;
      T1[10] = 1.0;
      T1[15] = 1.0;
    } else {
      ::std::copy(&Ttree_data[bid1].f1[0], &Ttree_data[bid1].f1[16], &T1[0]);
    }

    bid2 = obj->b_findBodyIndexByName();
    if (bid2 == 0.0) {
      std::memset(&T2[0], 0, 16U * sizeof(double));
      T2[0] = 1.0;
      T2[5] = 1.0;
      T2[10] = 1.0;
      T2[15] = 1.0;
    } else {
      for (i = 0; i < 16; i++) {
        T2[i] = Ttree_data[static_cast<int>(bid2) - 1].f1[i];
      }
    }

    for (i = 0; i < 3; i++) {
      R[3 * i] = T2[i];
      R[3 * i + 1] = T2[i + 4];
      R[3 * i + 2] = T2[i + 8];
    }

    for (i = 0; i < 9; i++) {
      b_R[i] = -R[i];
    }

    for (i = 0; i < 3; i++) {
      bid2 = b_R[i] * T2[12];
      kstr = i << 2;
      T2[kstr] = R[3 * i];
      bid2 += b_R[i + 3] * T2[13];
      T2[kstr + 1] = R[3 * i + 1];
      bid2 += b_R[i + 6] * T2[14];
      T2[kstr + 2] = R[3 * i + 2];
      c_R[i] = bid2;
    }

    T2[12] = c_R[0];
    T2[13] = c_R[1];
    T2[14] = c_R[2];
    T2[3] = 0.0;
    T2[7] = 0.0;
    T2[11] = 0.0;
    T2[15] = 1.0;
    for (i = 0; i < 4; i++) {
      double d;
      double d1;
      double d2;
      bid2 = T2[i];
      d = T2[i + 4];
      d1 = T2[i + 8];
      d2 = T2[i + 12];
      for (bid1 = 0; bid1 < 4; bid1++) {
        kstr = bid1 << 2;
        T[i + kstr] = ((bid2 * T1[kstr] + d * T1[kstr + 1]) + d1 * T1[kstr + 2])
          + d2 * T1[kstr + 3];
      }
    }
  }

  //
  // Arguments    : double ax[3]
  // Return Type  : void
  //
  void rigidBodyJoint::get_JointAxis(double ax[3]) const
  {
    static const char b_cv[8]{ 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };

    int exitg1;
    int i;
    int kstr;
    bool b_bool;
    bool guard1;
    if (TypeInternal.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(TypeInternal.Length);
    }

    b_bool = false;
    if (i == 8) {
      kstr = 0;
      do {
        exitg1 = 0;
        if (kstr < 8) {
          if (TypeInternal.Vector[kstr] != b_cv[kstr]) {
            exitg1 = 1;
          } else {
            kstr++;
          }
        } else {
          b_bool = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    guard1 = false;
    if (b_bool) {
      guard1 = true;
    } else {
      b_bool = false;
      if (i == 9) {
        kstr = 0;
        do {
          exitg1 = 0;
          if (kstr < 9) {
            if (TypeInternal.Vector[kstr] != cv1[kstr]) {
              exitg1 = 1;
            } else {
              kstr++;
            }
          } else {
            b_bool = true;
            exitg1 = 1;
          }
        } while (exitg1 == 0);
      }

      if (b_bool) {
        guard1 = true;
      } else {
        ax[0] = rtNaN;
        ax[1] = rtNaN;
        ax[2] = rtNaN;
      }
    }

    if (guard1) {
      ax[0] = JointAxisInternal[0];
      ax[1] = JointAxisInternal[1];
      ax[2] = JointAxisInternal[2];
    }
  }

  //
  // Arguments    : double msubspace_data[]
  //                int msubspace_size[2]
  // Return Type  : void
  //
  void rigidBodyJoint::get_MotionSubspace(double msubspace_data[], int
    msubspace_size[2]) const
  {
    static const char b_cv[5]{ 'f', 'i', 'x', 'e', 'd' };

    int i;
    int kstr;
    bool b_bool;
    if (TypeInternal.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(TypeInternal.Length);
    }

    b_bool = false;
    if (i == 5) {
      kstr = 0;
      int exitg1;
      do {
        exitg1 = 0;
        if (kstr < 5) {
          if (TypeInternal.Vector[kstr] != b_cv[kstr]) {
            exitg1 = 1;
          } else {
            kstr++;
          }
        } else {
          b_bool = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (!b_bool) {
      double d;
      d = VelocityNumber;
      if (d < 1.0) {
        kstr = 0;
      } else {
        kstr = static_cast<int>(d);
      }

      msubspace_size[0] = 6;
      msubspace_size[1] = kstr;
      for (i = 0; i < kstr; i++) {
        for (int i1{0}; i1 < 6; i1++) {
          int msubspace_data_tmp;
          msubspace_data_tmp = i1 + 6 * i;
          msubspace_data[msubspace_data_tmp] =
            MotionSubspaceInternal[msubspace_data_tmp];
        }
      }
    } else {
      msubspace_size[0] = 6;
      msubspace_size[1] = 1;
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = 0.0;
      }
    }
  }

  //
  // Arguments    : double &solverparams_MaxTime
  //                double &solverparams_GradientTolerance
  //                double &solverparams_SolutionTolerance
  //                bool &solverparams_EnforceJointLimits
  //                bool &solverparams_AllowRandomRestart
  //                double &solverparams_StepTolerance
  // Return Type  : double
  //
  double generalizedInverseKinematics::get_SolverParameters(double
    &solverparams_MaxTime, double &solverparams_GradientTolerance, double
    &solverparams_SolutionTolerance, bool &solverparams_EnforceJointLimits, bool
    &solverparams_AllowRandomRestart, double &solverparams_StepTolerance)
  {
    robotics::core::internal::DampedBFGSwGradientProjection *obj;
    double solverparams_MaxIterations;
    obj = Solver;
    solverparams_MaxIterations = obj->MaxNumIteration;
    solverparams_MaxTime = obj->MaxTime;
    solverparams_GradientTolerance = obj->GradientTolerance;
    solverparams_SolutionTolerance = obj->SolutionTolerance;
    solverparams_AllowRandomRestart = obj->RandomRestart;
    solverparams_StepTolerance = obj->StepTolerance;
    solverparams_EnforceJointLimits = EnforceJointLimits;
    return solverparams_MaxIterations;
  }

  //
  // Arguments    : rigidBody &bodyin
  //                robotics::manip::internal::CollisionSet &iobj_0
  //                rigidBodyJoint &iobj_1
  //                robotics::manip::internal::RigidBody &iobj_2
  // Return Type  : void
  //
  void rigidBodyTree::h_addBody(rigidBody &bodyin, robotics::manip::internal::
    CollisionSet &iobj_0, rigidBodyJoint &iobj_1, robotics::manip::internal::
    RigidBody &iobj_2)
  {
    static const char b_cv[6]{ 'b', 'o', 'd', 'y', 'A', '6' };

    static const char b_cv1[5]{ 'f', 'i', 'x', 'e', 'd' };

    rigidBodyJoint *jnt;
    robotics::manip::internal::CharacterVector b_obj;
    robotics::manip::internal::RigidBody *b_bodyin;
    robotics::manip::internal::RigidBody *body;
    robotics::manip::internal::b_RigidBodyTree *obj;
    double b_index;
    int obj_size[2];
    int exitg1;
    int loop_ub;
    int pid;
    char obj_data[200];
    bool b_bool;
    obj = TreeInternal;
    b_bodyin = bodyin.BodyInternal;
    b_obj = b_bodyin->NameInternal;
    if (b_obj.Length < 1.0) {
      loop_ub = 0;
    } else {
      loop_ub = static_cast<int>(b_obj.Length);
    }

    obj_size[0] = 1;
    obj_size[1] = loop_ub;
    if (loop_ub - 1 >= 0) {
      ::std::copy(&b_obj.Vector[0], &b_obj.Vector[loop_ub], &obj_data[0]);
    }

    obj->findBodyIndexByName(obj_data, obj_size);
    pid = -1;
    b_obj = obj->Base.NameInternal;
    if (b_obj.Length < 1.0) {
      loop_ub = 0;
    } else {
      loop_ub = static_cast<int>(b_obj.Length);
    }

    b_bool = false;
    if (loop_ub == 6) {
      loop_ub = 0;
      do {
        exitg1 = 0;
        if (loop_ub < 6) {
          if (b_obj.Vector[loop_ub] != b_cv[loop_ub]) {
            exitg1 = 1;
          } else {
            loop_ub++;
          }
        } else {
          b_bool = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (b_bool) {
      pid = 0;
    } else {
      int i;
      bool exitg2;
      b_index = obj->NumBodies;
      i = 0;
      exitg2 = false;
      while ((!exitg2) && (i <= static_cast<int>(b_index) - 1)) {
        body = obj->Bodies[i];
        b_obj = body->NameInternal;
        if (b_obj.Length < 1.0) {
          loop_ub = 0;
        } else {
          loop_ub = static_cast<int>(b_obj.Length);
        }

        b_bool = false;
        if (loop_ub == 6) {
          loop_ub = 0;
          do {
            exitg1 = 0;
            if (loop_ub < 6) {
              if (b_obj.Vector[loop_ub] != b_cv[loop_ub]) {
                exitg1 = 1;
              } else {
                loop_ub++;
              }
            } else {
              b_bool = true;
              exitg1 = 1;
            }
          } while (exitg1 == 0);
        }

        if (b_bool) {
          pid = i + 1;
          exitg2 = true;
        } else {
          i++;
        }
      }
    }

    jnt = b_bodyin->JointInternal;
    b_obj = jnt->NameInternal;
    if (b_obj.Length < 1.0) {
      loop_ub = 0;
    } else {
      loop_ub = static_cast<int>(b_obj.Length);
    }

    obj_size[0] = 1;
    obj_size[1] = loop_ub;
    if (loop_ub - 1 >= 0) {
      ::std::copy(&b_obj.Vector[0], &b_obj.Vector[loop_ub], &obj_data[0]);
    }

    obj->findBodyIndexByJointName(obj_data, obj_size);
    b_index = obj->NumBodies + 1.0;
    body = b_bodyin->copy((&iobj_0)[0], (&iobj_1)[0], iobj_2);
    obj->Bodies[static_cast<int>(b_index) - 1] = body;
    body->Index = b_index;
    body->ParentIndex = pid;
    body->JointInternal->InTree = true;
    obj->NumBodies++;
    jnt = body->JointInternal;
    b_obj = jnt->TypeInternal;
    if (b_obj.Length < 1.0) {
      loop_ub = 0;
    } else {
      loop_ub = static_cast<int>(b_obj.Length);
    }

    b_bool = false;
    if (loop_ub == 5) {
      loop_ub = 0;
      do {
        exitg1 = 0;
        if (loop_ub < 5) {
          if (b_obj.Vector[loop_ub] != b_cv1[loop_ub]) {
            exitg1 = 1;
          } else {
            loop_ub++;
          }
        } else {
          b_bool = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (!b_bool) {
      obj->NumNonFixedBodies++;
      jnt = body->JointInternal;
      loop_ub = static_cast<int>(body->Index) - 1;
      obj->PositionDoFMap[loop_ub] = obj->PositionNumber + 1.0;
      obj->PositionDoFMap[loop_ub + 12] = obj->PositionNumber +
        jnt->PositionNumber;
      jnt = body->JointInternal;
      loop_ub = static_cast<int>(body->Index) - 1;
      obj->VelocityDoFMap[loop_ub] = obj->VelocityNumber + 1.0;
      obj->VelocityDoFMap[loop_ub + 12] = obj->VelocityNumber +
        jnt->VelocityNumber;
    } else {
      loop_ub = static_cast<int>(body->Index);
      obj->PositionDoFMap[loop_ub - 1] = 0.0;
      obj->PositionDoFMap[loop_ub + 11] = -1.0;
      loop_ub = static_cast<int>(body->Index);
      obj->VelocityDoFMap[loop_ub - 1] = 0.0;
      obj->VelocityDoFMap[loop_ub + 11] = -1.0;
    }

    jnt = body->JointInternal;
    obj->PositionNumber += jnt->PositionNumber;
    jnt = body->JointInternal;
    obj->VelocityNumber += jnt->VelocityNumber;
  }

  //
  // Arguments    : robotics::manip::internal::RigidBodyTree &iobj_0
  //                robotics::manip::internal::CollisionSet &iobj_1
  //                rigidBodyJoint &iobj_2
  //                robotics::manip::internal::RigidBody &iobj_3
  // Return Type  : rigidBody *
  //
  rigidBody *rigidBody::h_init(robotics::manip::internal::RigidBodyTree &iobj_0,
    robotics::manip::internal::CollisionSet &iobj_1, rigidBodyJoint &iobj_2,
    robotics::manip::internal::RigidBody &iobj_3)
  {
    static const char b_cv1[10]{ 'b', 'o', 'd', 'y', 'E', 'E', '_', 'j', 'n',
      't' };

    static const char b_cv3[8]{ 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };

    static const char b_cv4[8]{ 'f', 'l', 'o', 'a', 't', 'i', 'n', 'g' };

    static const signed char iv2[7]{ 1, 0, 0, 0, 0, 0, 0 };

    static const char b_cv[6]{ 'b', 'o', 'd', 'y', 'E', 'E' };

    static const signed char b_iv[6]{ 0, 0, 1, 0, 0, 0 };

    static const signed char b_iv1[6]{ 0, 0, 0, 0, 0, 1 };

    static const char b_cv2[5]{ 'f', 'i', 'x', 'e', 'd' };

    static const char b_cv5[5]{ 'f', 'i', 'x', 'e', 'd' };

    rigidBody *obj;
    robotics::manip::internal::CharacterVector s;
    robotics::manip::internal::RigidBodyTree *b_default;
    double msubspace_data[36];
    double poslim_data[14];
    int exitg1;
    int homepos_size_idx_1;
    int i;
    int i1;
    int ibmat;
    int poslim_size_idx_0;
    signed char b_I[36];
    signed char c_I[9];
    signed char homepos_data[7];
    bool result;
    obj = this;
    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    iobj_3.NameInternal = s;
    s = iobj_3.NameInternal;
    s.Length = 6.0;
    for (i = 0; i < 6; i++) {
      s.Vector[i] = b_cv[i];
    }

    iobj_3.NameInternal = s;
    iobj_2.InTree = false;
    for (i = 0; i < 16; i++) {
      i1 = iv[i];
      iobj_2.JointToParentTransform[i] = i1;
      iobj_2.ChildToJointTransform[i] = i1;
    }

    for (i = 0; i < 14; i++) {
      iobj_2.PositionLimitsInternal[i] = 0.0;
    }

    for (i = 0; i < 7; i++) {
      iobj_2.HomePositionInternal[i] = 0.0;
    }

    for (i = 0; i < 36; i++) {
      iobj_2.MotionSubspaceInternal[i] = 0.0;
    }

    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    iobj_2.NameInternal = s;
    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    iobj_2.TypeInternal = s;
    s = iobj_2.NameInternal;
    s.Length = 10.0;
    for (i = 0; i < 10; i++) {
      s.Vector[i] = b_cv1[i];
    }

    iobj_2.NameInternal = s;
    s = iobj_2.TypeInternal;
    s.Length = 5.0;
    for (i = 0; i < 5; i++) {
      s.Vector[i] = b_cv2[i];
    }

    iobj_2.TypeInternal = s;
    s = iobj_2.TypeInternal;
    if (s.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(s.Length);
    }

    result = false;
    if (i == 8) {
      ibmat = 0;
      do {
        exitg1 = 0;
        if (ibmat < 8) {
          if (b_cv3[ibmat] != s.Vector[ibmat]) {
            exitg1 = 1;
          } else {
            ibmat++;
          }
        } else {
          result = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (result) {
      ibmat = 0;
    } else {
      result = false;
      if (i == 9) {
        ibmat = 0;
        do {
          exitg1 = 0;
          if (ibmat < 9) {
            if (cv1[ibmat] != s.Vector[ibmat]) {
              exitg1 = 1;
            } else {
              ibmat++;
            }
          } else {
            result = true;
            exitg1 = 1;
          }
        } while (exitg1 == 0);
      }

      if (result) {
        ibmat = 1;
      } else {
        result = false;
        if (i == 8) {
          ibmat = 0;
          do {
            exitg1 = 0;
            if (ibmat < 8) {
              if (b_cv4[ibmat] != s.Vector[ibmat]) {
                exitg1 = 1;
              } else {
                ibmat++;
              }
            } else {
              result = true;
              exitg1 = 1;
            }
          } while (exitg1 == 0);
        }

        if (result) {
          ibmat = 2;
        } else {
          ibmat = -1;
        }
      }
    }

    switch (ibmat) {
     case 0:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = b_iv[i];
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = -3.1415926535897931;
      poslim_data[1] = 3.1415926535897931;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      iobj_2.VelocityNumber = 1.0;
      iobj_2.PositionNumber = 1.0;
      iobj_2.JointAxisInternal[0] = 0.0;
      iobj_2.JointAxisInternal[1] = 0.0;
      iobj_2.JointAxisInternal[2] = 1.0;
      break;

     case 1:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = b_iv1[i];
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = -0.5;
      poslim_data[1] = 0.5;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      iobj_2.VelocityNumber = 1.0;
      iobj_2.PositionNumber = 1.0;
      iobj_2.JointAxisInternal[0] = 0.0;
      iobj_2.JointAxisInternal[1] = 0.0;
      iobj_2.JointAxisInternal[2] = 1.0;
      break;

     case 2:
      {
        signed char b[6];
        for (i = 0; i < 36; i++) {
          b_I[i] = 0;
        }

        for (ibmat = 0; ibmat < 6; ibmat++) {
          b_I[ibmat + 6 * ibmat] = 1;
        }

        for (i = 0; i < 36; i++) {
          msubspace_data[i] = b_I[i];
        }

        poslim_size_idx_0 = 7;
        for (homepos_size_idx_1 = 0; homepos_size_idx_1 < 2; homepos_size_idx_1
             ++) {
          signed char b_tmp;
          ibmat = homepos_size_idx_1 * 3;
          b_tmp = static_cast<signed char>(10 * homepos_size_idx_1 - 5);
          b[ibmat] = b_tmp;
          b[ibmat + 1] = b_tmp;
          b[ibmat + 2] = b_tmp;
          poslim_data[7 * homepos_size_idx_1] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 1] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 2] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 3] = rtNaN;
        }

        for (i = 0; i < 2; i++) {
          poslim_data[7 * i + 4] = b[3 * i];
          poslim_data[7 * i + 5] = b[3 * i + 1];
          poslim_data[7 * i + 6] = b[3 * i + 2];
        }

        homepos_size_idx_1 = 7;
        for (i = 0; i < 7; i++) {
          homepos_data[i] = iv2[i];
        }

        iobj_2.VelocityNumber = 6.0;
        iobj_2.PositionNumber = 7.0;
        iobj_2.JointAxisInternal[0] = rtNaN;
        iobj_2.JointAxisInternal[1] = rtNaN;
        iobj_2.JointAxisInternal[2] = rtNaN;
      }
      break;

     default:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = 0.0;
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = 0.0;
      poslim_data[1] = 0.0;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      iobj_2.VelocityNumber = 0.0;
      iobj_2.PositionNumber = 0.0;
      iobj_2.JointAxisInternal[0] = 0.0;
      iobj_2.JointAxisInternal[1] = 0.0;
      iobj_2.JointAxisInternal[2] = 0.0;
      break;
    }

    iobj_2.set_MotionSubspace(msubspace_data);
    s = iobj_2.TypeInternal;
    if (s.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(s.Length);
    }

    result = false;
    if (i == 5) {
      ibmat = 0;
      do {
        exitg1 = 0;
        if (ibmat < 5) {
          if (s.Vector[ibmat] != b_cv5[ibmat]) {
            exitg1 = 1;
          } else {
            ibmat++;
          }
        } else {
          result = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (!result) {
      double d;
      d = iobj_2.PositionNumber;
      if (d < 1.0) {
        ibmat = 0;
      } else {
        ibmat = static_cast<int>(d);
      }

      for (i = 0; i < 2; i++) {
        for (i1 = 0; i1 < ibmat; i1++) {
          iobj_2.PositionLimitsInternal[i1 + 7 * i] = poslim_data[i1 +
            poslim_size_idx_0 * i];
        }
      }

      for (i = 0; i < homepos_size_idx_1; i++) {
        iobj_2.HomePositionInternal[i] = homepos_data[i];
      }
    } else {
      iobj_2.PositionLimitsInternal[0] = poslim_data[0];
      iobj_2.PositionLimitsInternal[7] = poslim_data[1];
      iobj_2.HomePositionInternal[0] = homepos_data[0];
    }

    iobj_3.JointInternal = &iobj_2;
    iobj_3.Index = -1.0;
    iobj_3.ParentIndex = -1.0;
    iobj_3.MassInternal = 1.0;
    iobj_3.CenterOfMassInternal[0] = 0.0;
    iobj_3.CenterOfMassInternal[1] = 0.0;
    iobj_3.CenterOfMassInternal[2] = 0.0;
    for (i = 0; i < 9; i++) {
      c_I[i] = 0;
    }

    c_I[0] = 1;
    c_I[4] = 1;
    c_I[8] = 1;
    for (i = 0; i < 9; i++) {
      iobj_3.InertiaInternal[i] = c_I[i];
    }

    for (i = 0; i < 36; i++) {
      b_I[i] = 0;
    }

    for (ibmat = 0; ibmat < 6; ibmat++) {
      b_I[ibmat + 6 * ibmat] = 1;
    }

    for (i = 0; i < 36; i++) {
      iobj_3.SpatialInertia[i] = b_I[i];
    }

    iobj_3.CollisionsInternal = iobj_1.init(static_cast<double>(0.0));
    iobj_3.matlabCodegenIsDeleted = false;
    b_default = iobj_0.init();
    obj->BodyInternal = &iobj_3;
    obj->TreeInternal = b_default;
    obj->matlabCodegenIsDeleted = false;
    return obj;
  }

  //
  // Arguments    : void
  // Return Type  : rigidBodyJoint *
  //
  rigidBodyJoint *rigidBodyJoint::h_init()
  {
    static const char b_cv1[8]{ 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };

    static const char b_cv2[8]{ 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };

    static const char b_cv3[8]{ 'f', 'l', 'o', 'a', 't', 'i', 'n', 'g' };

    static const signed char iv2[7]{ 1, 0, 0, 0, 0, 0, 0 };

    static const signed char b_iv[6]{ 0, 0, 1, 0, 0, 0 };

    static const signed char b_iv1[6]{ 0, 0, 0, 0, 0, 1 };

    static const char b_cv[5]{ 'j', 'n', 't', 'A', '6' };

    static const char b_cv4[5]{ 'f', 'i', 'x', 'e', 'd' };

    rigidBodyJoint *obj;
    robotics::manip::internal::CharacterVector s;
    double msubspace_data[36];
    double poslim_data[14];
    int exitg1;
    int homepos_size_idx_1;
    int i;
    int ibmat;
    int poslim_size_idx_0;
    signed char homepos_data[7];
    signed char b_tmp;
    bool result;
    obj = this;
    obj->InTree = false;
    for (i = 0; i < 16; i++) {
      b_tmp = iv[i];
      obj->JointToParentTransform[i] = b_tmp;
      obj->ChildToJointTransform[i] = b_tmp;
    }

    for (i = 0; i < 14; i++) {
      obj->PositionLimitsInternal[i] = 0.0;
    }

    for (i = 0; i < 7; i++) {
      obj->HomePositionInternal[i] = 0.0;
    }

    for (i = 0; i < 36; i++) {
      obj->MotionSubspaceInternal[i] = 0.0;
    }

    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    obj->NameInternal = s;
    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    obj->TypeInternal = s;
    s = obj->NameInternal;
    s.Length = 5.0;
    for (i = 0; i < 5; i++) {
      s.Vector[i] = b_cv[i];
    }

    obj->NameInternal = s;
    s = obj->TypeInternal;
    s.Length = 8.0;
    for (i = 0; i < 8; i++) {
      s.Vector[i] = b_cv1[i];
    }

    obj->TypeInternal = s;
    s = obj->TypeInternal;
    if (s.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(s.Length);
    }

    result = false;
    if (i == 8) {
      ibmat = 0;
      do {
        exitg1 = 0;
        if (ibmat < 8) {
          if (b_cv2[ibmat] != s.Vector[ibmat]) {
            exitg1 = 1;
          } else {
            ibmat++;
          }
        } else {
          result = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (result) {
      ibmat = 0;
    } else {
      result = false;
      if (i == 9) {
        ibmat = 0;
        do {
          exitg1 = 0;
          if (ibmat < 9) {
            if (cv1[ibmat] != s.Vector[ibmat]) {
              exitg1 = 1;
            } else {
              ibmat++;
            }
          } else {
            result = true;
            exitg1 = 1;
          }
        } while (exitg1 == 0);
      }

      if (result) {
        ibmat = 1;
      } else {
        result = false;
        if (i == 8) {
          ibmat = 0;
          do {
            exitg1 = 0;
            if (ibmat < 8) {
              if (b_cv3[ibmat] != s.Vector[ibmat]) {
                exitg1 = 1;
              } else {
                ibmat++;
              }
            } else {
              result = true;
              exitg1 = 1;
            }
          } while (exitg1 == 0);
        }

        if (result) {
          ibmat = 2;
        } else {
          ibmat = -1;
        }
      }
    }

    switch (ibmat) {
     case 0:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = b_iv[i];
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = -3.1415926535897931;
      poslim_data[1] = 3.1415926535897931;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      obj->VelocityNumber = 1.0;
      obj->PositionNumber = 1.0;
      obj->JointAxisInternal[0] = 0.0;
      obj->JointAxisInternal[1] = 0.0;
      obj->JointAxisInternal[2] = 1.0;
      break;

     case 1:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = b_iv1[i];
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = -0.5;
      poslim_data[1] = 0.5;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      obj->VelocityNumber = 1.0;
      obj->PositionNumber = 1.0;
      obj->JointAxisInternal[0] = 0.0;
      obj->JointAxisInternal[1] = 0.0;
      obj->JointAxisInternal[2] = 1.0;
      break;

     case 2:
      {
        signed char b_I[36];
        signed char b[6];
        for (i = 0; i < 36; i++) {
          b_I[i] = 0;
        }

        for (ibmat = 0; ibmat < 6; ibmat++) {
          b_I[ibmat + 6 * ibmat] = 1;
        }

        for (i = 0; i < 36; i++) {
          msubspace_data[i] = b_I[i];
        }

        poslim_size_idx_0 = 7;
        for (homepos_size_idx_1 = 0; homepos_size_idx_1 < 2; homepos_size_idx_1
             ++) {
          ibmat = homepos_size_idx_1 * 3;
          b_tmp = static_cast<signed char>(10 * homepos_size_idx_1 - 5);
          b[ibmat] = b_tmp;
          b[ibmat + 1] = b_tmp;
          b[ibmat + 2] = b_tmp;
          poslim_data[7 * homepos_size_idx_1] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 1] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 2] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 3] = rtNaN;
        }

        for (i = 0; i < 2; i++) {
          poslim_data[7 * i + 4] = b[3 * i];
          poslim_data[7 * i + 5] = b[3 * i + 1];
          poslim_data[7 * i + 6] = b[3 * i + 2];
        }

        homepos_size_idx_1 = 7;
        for (i = 0; i < 7; i++) {
          homepos_data[i] = iv2[i];
        }

        obj->VelocityNumber = 6.0;
        obj->PositionNumber = 7.0;
        obj->JointAxisInternal[0] = rtNaN;
        obj->JointAxisInternal[1] = rtNaN;
        obj->JointAxisInternal[2] = rtNaN;
      }
      break;

     default:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = 0.0;
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = 0.0;
      poslim_data[1] = 0.0;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      obj->VelocityNumber = 0.0;
      obj->PositionNumber = 0.0;
      obj->JointAxisInternal[0] = 0.0;
      obj->JointAxisInternal[1] = 0.0;
      obj->JointAxisInternal[2] = 0.0;
      break;
    }

    obj->set_MotionSubspace(msubspace_data);
    s = obj->TypeInternal;
    if (s.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(s.Length);
    }

    result = false;
    if (i == 5) {
      ibmat = 0;
      do {
        exitg1 = 0;
        if (ibmat < 5) {
          if (s.Vector[ibmat] != b_cv4[ibmat]) {
            exitg1 = 1;
          } else {
            ibmat++;
          }
        } else {
          result = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (!result) {
      double d;
      d = obj->PositionNumber;
      if (d < 1.0) {
        ibmat = 0;
      } else {
        ibmat = static_cast<int>(d);
      }

      for (i = 0; i < 2; i++) {
        for (int i1{0}; i1 < ibmat; i1++) {
          obj->PositionLimitsInternal[i1 + 7 * i] = poslim_data[i1 +
            poslim_size_idx_0 * i];
        }
      }

      for (i = 0; i < homepos_size_idx_1; i++) {
        obj->HomePositionInternal[i] = homepos_data[i];
      }
    } else {
      obj->PositionLimitsInternal[0] = poslim_data[0];
      obj->PositionLimitsInternal[7] = poslim_data[1];
      obj->HomePositionInternal[0] = homepos_data[0];
    }

    return obj;
  }

  //
  // Arguments    : void
  // Return Type  : void
  //
  void rigidBodyJoint::h_setFixedTransform()
  {
    static const signed char inputTform[16]{ -1, 0, 0, 0, 0, 1, 0, 0, 0, 0, -1,
      0, 0, 0, 0, 1 };

    for (int i{0}; i < 16; i++) {
      JointToParentTransform[i] = inputTform[i];
      ChildToJointTransform[i] = 0.0;
    }

    ChildToJointTransform[0] = 1.0;
    ChildToJointTransform[5] = 1.0;
    ChildToJointTransform[10] = 1.0;
    ChildToJointTransform[15] = 1.0;
  }

  //
  // Arguments    : rigidBody &bodyin
  //                robotics::manip::internal::CollisionSet &iobj_0
  //                rigidBodyJoint &iobj_1
  //                robotics::manip::internal::RigidBody &iobj_2
  // Return Type  : void
  //
  void rigidBodyTree::i_addBody(rigidBody &bodyin, robotics::manip::internal::
    CollisionSet &iobj_0, rigidBodyJoint &iobj_1, robotics::manip::internal::
    RigidBody &iobj_2)
  {
    static const char b_cv[8]{ 'b', 'o', 'd', 'y', 'T', 'o', 'o', 'l' };

    static const char b_cv1[5]{ 'f', 'i', 'x', 'e', 'd' };

    rigidBodyJoint *jnt;
    robotics::manip::internal::CharacterVector b_obj;
    robotics::manip::internal::RigidBody *b_bodyin;
    robotics::manip::internal::RigidBody *body;
    robotics::manip::internal::b_RigidBodyTree *obj;
    double b_index;
    int obj_size[2];
    int exitg1;
    int loop_ub;
    int pid;
    char obj_data[200];
    bool b_bool;
    obj = TreeInternal;
    b_bodyin = bodyin.BodyInternal;
    b_obj = b_bodyin->NameInternal;
    if (b_obj.Length < 1.0) {
      loop_ub = 0;
    } else {
      loop_ub = static_cast<int>(b_obj.Length);
    }

    obj_size[0] = 1;
    obj_size[1] = loop_ub;
    if (loop_ub - 1 >= 0) {
      ::std::copy(&b_obj.Vector[0], &b_obj.Vector[loop_ub], &obj_data[0]);
    }

    obj->findBodyIndexByName(obj_data, obj_size);
    pid = -1;
    b_obj = obj->Base.NameInternal;
    if (b_obj.Length < 1.0) {
      loop_ub = 0;
    } else {
      loop_ub = static_cast<int>(b_obj.Length);
    }

    b_bool = false;
    if (loop_ub == 8) {
      loop_ub = 0;
      do {
        exitg1 = 0;
        if (loop_ub < 8) {
          if (b_obj.Vector[loop_ub] != b_cv[loop_ub]) {
            exitg1 = 1;
          } else {
            loop_ub++;
          }
        } else {
          b_bool = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (b_bool) {
      pid = 0;
    } else {
      int i;
      bool exitg2;
      b_index = obj->NumBodies;
      i = 0;
      exitg2 = false;
      while ((!exitg2) && (i <= static_cast<int>(b_index) - 1)) {
        body = obj->Bodies[i];
        b_obj = body->NameInternal;
        if (b_obj.Length < 1.0) {
          loop_ub = 0;
        } else {
          loop_ub = static_cast<int>(b_obj.Length);
        }

        b_bool = false;
        if (loop_ub == 8) {
          loop_ub = 0;
          do {
            exitg1 = 0;
            if (loop_ub < 8) {
              if (b_obj.Vector[loop_ub] != b_cv[loop_ub]) {
                exitg1 = 1;
              } else {
                loop_ub++;
              }
            } else {
              b_bool = true;
              exitg1 = 1;
            }
          } while (exitg1 == 0);
        }

        if (b_bool) {
          pid = i + 1;
          exitg2 = true;
        } else {
          i++;
        }
      }
    }

    jnt = b_bodyin->JointInternal;
    b_obj = jnt->NameInternal;
    if (b_obj.Length < 1.0) {
      loop_ub = 0;
    } else {
      loop_ub = static_cast<int>(b_obj.Length);
    }

    obj_size[0] = 1;
    obj_size[1] = loop_ub;
    if (loop_ub - 1 >= 0) {
      ::std::copy(&b_obj.Vector[0], &b_obj.Vector[loop_ub], &obj_data[0]);
    }

    obj->findBodyIndexByJointName(obj_data, obj_size);
    b_index = obj->NumBodies + 1.0;
    body = b_bodyin->copy((&iobj_0)[0], (&iobj_1)[0], iobj_2);
    obj->Bodies[static_cast<int>(b_index) - 1] = body;
    body->Index = b_index;
    body->ParentIndex = pid;
    body->JointInternal->InTree = true;
    obj->NumBodies++;
    jnt = body->JointInternal;
    b_obj = jnt->TypeInternal;
    if (b_obj.Length < 1.0) {
      loop_ub = 0;
    } else {
      loop_ub = static_cast<int>(b_obj.Length);
    }

    b_bool = false;
    if (loop_ub == 5) {
      loop_ub = 0;
      do {
        exitg1 = 0;
        if (loop_ub < 5) {
          if (b_obj.Vector[loop_ub] != b_cv1[loop_ub]) {
            exitg1 = 1;
          } else {
            loop_ub++;
          }
        } else {
          b_bool = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (!b_bool) {
      obj->NumNonFixedBodies++;
      jnt = body->JointInternal;
      loop_ub = static_cast<int>(body->Index) - 1;
      obj->PositionDoFMap[loop_ub] = obj->PositionNumber + 1.0;
      obj->PositionDoFMap[loop_ub + 12] = obj->PositionNumber +
        jnt->PositionNumber;
      jnt = body->JointInternal;
      loop_ub = static_cast<int>(body->Index) - 1;
      obj->VelocityDoFMap[loop_ub] = obj->VelocityNumber + 1.0;
      obj->VelocityDoFMap[loop_ub + 12] = obj->VelocityNumber +
        jnt->VelocityNumber;
    } else {
      loop_ub = static_cast<int>(body->Index);
      obj->PositionDoFMap[loop_ub - 1] = 0.0;
      obj->PositionDoFMap[loop_ub + 11] = -1.0;
      loop_ub = static_cast<int>(body->Index);
      obj->VelocityDoFMap[loop_ub - 1] = 0.0;
      obj->VelocityDoFMap[loop_ub + 11] = -1.0;
    }

    jnt = body->JointInternal;
    obj->PositionNumber += jnt->PositionNumber;
    jnt = body->JointInternal;
    obj->VelocityNumber += jnt->VelocityNumber;
  }

  //
  // Arguments    : robotics::manip::internal::RigidBodyTree &iobj_0
  //                robotics::manip::internal::CollisionSet &iobj_1
  //                rigidBodyJoint &iobj_2
  //                robotics::manip::internal::RigidBody &iobj_3
  // Return Type  : rigidBody *
  //
  rigidBody *rigidBody::i_init(robotics::manip::internal::RigidBodyTree &iobj_0,
    robotics::manip::internal::CollisionSet &iobj_1, rigidBodyJoint &iobj_2,
    robotics::manip::internal::RigidBody &iobj_3)
  {
    static const char b_cv1[12]{ 'b', 'o', 'd', 'y', 'T', 'o', 'o', 'l', '_',
      'j', 'n', 't' };

    static const char b_cv[8]{ 'b', 'o', 'd', 'y', 'T', 'o', 'o', 'l' };

    static const char b_cv3[8]{ 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };

    static const char b_cv4[8]{ 'f', 'l', 'o', 'a', 't', 'i', 'n', 'g' };

    static const signed char iv2[7]{ 1, 0, 0, 0, 0, 0, 0 };

    static const signed char b_iv[6]{ 0, 0, 1, 0, 0, 0 };

    static const signed char b_iv1[6]{ 0, 0, 0, 0, 0, 1 };

    static const char b_cv2[5]{ 'f', 'i', 'x', 'e', 'd' };

    static const char b_cv5[5]{ 'f', 'i', 'x', 'e', 'd' };

    rigidBody *obj;
    robotics::manip::internal::CharacterVector s;
    robotics::manip::internal::RigidBodyTree *b_default;
    double msubspace_data[36];
    double poslim_data[14];
    int exitg1;
    int homepos_size_idx_1;
    int i;
    int i1;
    int ibmat;
    int poslim_size_idx_0;
    signed char b_I[36];
    signed char c_I[9];
    signed char homepos_data[7];
    bool result;
    obj = this;
    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    iobj_3.NameInternal = s;
    s = iobj_3.NameInternal;
    s.Length = 8.0;
    for (i = 0; i < 8; i++) {
      s.Vector[i] = b_cv[i];
    }

    iobj_3.NameInternal = s;
    iobj_2.InTree = false;
    for (i = 0; i < 16; i++) {
      i1 = iv[i];
      iobj_2.JointToParentTransform[i] = i1;
      iobj_2.ChildToJointTransform[i] = i1;
    }

    for (i = 0; i < 14; i++) {
      iobj_2.PositionLimitsInternal[i] = 0.0;
    }

    for (i = 0; i < 7; i++) {
      iobj_2.HomePositionInternal[i] = 0.0;
    }

    for (i = 0; i < 36; i++) {
      iobj_2.MotionSubspaceInternal[i] = 0.0;
    }

    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    iobj_2.NameInternal = s;
    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    iobj_2.TypeInternal = s;
    s = iobj_2.NameInternal;
    s.Length = 12.0;
    for (i = 0; i < 12; i++) {
      s.Vector[i] = b_cv1[i];
    }

    iobj_2.NameInternal = s;
    s = iobj_2.TypeInternal;
    s.Length = 5.0;
    for (i = 0; i < 5; i++) {
      s.Vector[i] = b_cv2[i];
    }

    iobj_2.TypeInternal = s;
    s = iobj_2.TypeInternal;
    if (s.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(s.Length);
    }

    result = false;
    if (i == 8) {
      ibmat = 0;
      do {
        exitg1 = 0;
        if (ibmat < 8) {
          if (b_cv3[ibmat] != s.Vector[ibmat]) {
            exitg1 = 1;
          } else {
            ibmat++;
          }
        } else {
          result = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (result) {
      ibmat = 0;
    } else {
      result = false;
      if (i == 9) {
        ibmat = 0;
        do {
          exitg1 = 0;
          if (ibmat < 9) {
            if (cv1[ibmat] != s.Vector[ibmat]) {
              exitg1 = 1;
            } else {
              ibmat++;
            }
          } else {
            result = true;
            exitg1 = 1;
          }
        } while (exitg1 == 0);
      }

      if (result) {
        ibmat = 1;
      } else {
        result = false;
        if (i == 8) {
          ibmat = 0;
          do {
            exitg1 = 0;
            if (ibmat < 8) {
              if (b_cv4[ibmat] != s.Vector[ibmat]) {
                exitg1 = 1;
              } else {
                ibmat++;
              }
            } else {
              result = true;
              exitg1 = 1;
            }
          } while (exitg1 == 0);
        }

        if (result) {
          ibmat = 2;
        } else {
          ibmat = -1;
        }
      }
    }

    switch (ibmat) {
     case 0:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = b_iv[i];
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = -3.1415926535897931;
      poslim_data[1] = 3.1415926535897931;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      iobj_2.VelocityNumber = 1.0;
      iobj_2.PositionNumber = 1.0;
      iobj_2.JointAxisInternal[0] = 0.0;
      iobj_2.JointAxisInternal[1] = 0.0;
      iobj_2.JointAxisInternal[2] = 1.0;
      break;

     case 1:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = b_iv1[i];
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = -0.5;
      poslim_data[1] = 0.5;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      iobj_2.VelocityNumber = 1.0;
      iobj_2.PositionNumber = 1.0;
      iobj_2.JointAxisInternal[0] = 0.0;
      iobj_2.JointAxisInternal[1] = 0.0;
      iobj_2.JointAxisInternal[2] = 1.0;
      break;

     case 2:
      {
        signed char b[6];
        for (i = 0; i < 36; i++) {
          b_I[i] = 0;
        }

        for (ibmat = 0; ibmat < 6; ibmat++) {
          b_I[ibmat + 6 * ibmat] = 1;
        }

        for (i = 0; i < 36; i++) {
          msubspace_data[i] = b_I[i];
        }

        poslim_size_idx_0 = 7;
        for (homepos_size_idx_1 = 0; homepos_size_idx_1 < 2; homepos_size_idx_1
             ++) {
          signed char b_tmp;
          ibmat = homepos_size_idx_1 * 3;
          b_tmp = static_cast<signed char>(10 * homepos_size_idx_1 - 5);
          b[ibmat] = b_tmp;
          b[ibmat + 1] = b_tmp;
          b[ibmat + 2] = b_tmp;
          poslim_data[7 * homepos_size_idx_1] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 1] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 2] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 3] = rtNaN;
        }

        for (i = 0; i < 2; i++) {
          poslim_data[7 * i + 4] = b[3 * i];
          poslim_data[7 * i + 5] = b[3 * i + 1];
          poslim_data[7 * i + 6] = b[3 * i + 2];
        }

        homepos_size_idx_1 = 7;
        for (i = 0; i < 7; i++) {
          homepos_data[i] = iv2[i];
        }

        iobj_2.VelocityNumber = 6.0;
        iobj_2.PositionNumber = 7.0;
        iobj_2.JointAxisInternal[0] = rtNaN;
        iobj_2.JointAxisInternal[1] = rtNaN;
        iobj_2.JointAxisInternal[2] = rtNaN;
      }
      break;

     default:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = 0.0;
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = 0.0;
      poslim_data[1] = 0.0;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      iobj_2.VelocityNumber = 0.0;
      iobj_2.PositionNumber = 0.0;
      iobj_2.JointAxisInternal[0] = 0.0;
      iobj_2.JointAxisInternal[1] = 0.0;
      iobj_2.JointAxisInternal[2] = 0.0;
      break;
    }

    iobj_2.set_MotionSubspace(msubspace_data);
    s = iobj_2.TypeInternal;
    if (s.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(s.Length);
    }

    result = false;
    if (i == 5) {
      ibmat = 0;
      do {
        exitg1 = 0;
        if (ibmat < 5) {
          if (s.Vector[ibmat] != b_cv5[ibmat]) {
            exitg1 = 1;
          } else {
            ibmat++;
          }
        } else {
          result = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (!result) {
      double d;
      d = iobj_2.PositionNumber;
      if (d < 1.0) {
        ibmat = 0;
      } else {
        ibmat = static_cast<int>(d);
      }

      for (i = 0; i < 2; i++) {
        for (i1 = 0; i1 < ibmat; i1++) {
          iobj_2.PositionLimitsInternal[i1 + 7 * i] = poslim_data[i1 +
            poslim_size_idx_0 * i];
        }
      }

      for (i = 0; i < homepos_size_idx_1; i++) {
        iobj_2.HomePositionInternal[i] = homepos_data[i];
      }
    } else {
      iobj_2.PositionLimitsInternal[0] = poslim_data[0];
      iobj_2.PositionLimitsInternal[7] = poslim_data[1];
      iobj_2.HomePositionInternal[0] = homepos_data[0];
    }

    iobj_3.JointInternal = &iobj_2;
    iobj_3.Index = -1.0;
    iobj_3.ParentIndex = -1.0;
    iobj_3.MassInternal = 1.0;
    iobj_3.CenterOfMassInternal[0] = 0.0;
    iobj_3.CenterOfMassInternal[1] = 0.0;
    iobj_3.CenterOfMassInternal[2] = 0.0;
    for (i = 0; i < 9; i++) {
      c_I[i] = 0;
    }

    c_I[0] = 1;
    c_I[4] = 1;
    c_I[8] = 1;
    for (i = 0; i < 9; i++) {
      iobj_3.InertiaInternal[i] = c_I[i];
    }

    for (i = 0; i < 36; i++) {
      b_I[i] = 0;
    }

    for (ibmat = 0; ibmat < 6; ibmat++) {
      b_I[ibmat + 6 * ibmat] = 1;
    }

    for (i = 0; i < 36; i++) {
      iobj_3.SpatialInertia[i] = b_I[i];
    }

    iobj_3.CollisionsInternal = (&iobj_1)[0].init(static_cast<double>(0.0));
    iobj_3.matlabCodegenIsDeleted = false;
    b_default = iobj_0.init();
    iobj_3.CollisionsInternal = (&iobj_1)[1].init(1.0);
    obj->BodyInternal = &iobj_3;
    obj->TreeInternal = b_default;
    obj->matlabCodegenIsDeleted = false;
    return obj;
  }

  //
  // Arguments    : void
  // Return Type  : rigidBodyJoint *
  //
  rigidBodyJoint *rigidBodyJoint::i_init()
  {
    static const char b_cv2[8]{ 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };

    static const char b_cv3[8]{ 'f', 'l', 'o', 'a', 't', 'i', 'n', 'g' };

    static const signed char iv2[7]{ 1, 0, 0, 0, 0, 0, 0 };

    static const signed char b_iv[6]{ 0, 0, 1, 0, 0, 0 };

    static const signed char b_iv1[6]{ 0, 0, 0, 0, 0, 1 };

    static const char b_cv[5]{ 'j', 'n', 't', 'E', 'E' };

    static const char b_cv1[5]{ 'f', 'i', 'x', 'e', 'd' };

    static const char b_cv4[5]{ 'f', 'i', 'x', 'e', 'd' };

    rigidBodyJoint *obj;
    robotics::manip::internal::CharacterVector s;
    double msubspace_data[36];
    double poslim_data[14];
    int exitg1;
    int homepos_size_idx_1;
    int i;
    int ibmat;
    int poslim_size_idx_0;
    signed char homepos_data[7];
    signed char b_tmp;
    bool result;
    obj = this;
    obj->InTree = false;
    for (i = 0; i < 16; i++) {
      b_tmp = iv[i];
      obj->JointToParentTransform[i] = b_tmp;
      obj->ChildToJointTransform[i] = b_tmp;
    }

    for (i = 0; i < 14; i++) {
      obj->PositionLimitsInternal[i] = 0.0;
    }

    for (i = 0; i < 7; i++) {
      obj->HomePositionInternal[i] = 0.0;
    }

    for (i = 0; i < 36; i++) {
      obj->MotionSubspaceInternal[i] = 0.0;
    }

    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    obj->NameInternal = s;
    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    obj->TypeInternal = s;
    s = obj->NameInternal;
    s.Length = 5.0;
    for (i = 0; i < 5; i++) {
      s.Vector[i] = b_cv[i];
    }

    obj->NameInternal = s;
    s = obj->TypeInternal;
    s.Length = 5.0;
    for (i = 0; i < 5; i++) {
      s.Vector[i] = b_cv1[i];
    }

    obj->TypeInternal = s;
    s = obj->TypeInternal;
    if (s.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(s.Length);
    }

    result = false;
    if (i == 8) {
      ibmat = 0;
      do {
        exitg1 = 0;
        if (ibmat < 8) {
          if (b_cv2[ibmat] != s.Vector[ibmat]) {
            exitg1 = 1;
          } else {
            ibmat++;
          }
        } else {
          result = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (result) {
      ibmat = 0;
    } else {
      result = false;
      if (i == 9) {
        ibmat = 0;
        do {
          exitg1 = 0;
          if (ibmat < 9) {
            if (cv1[ibmat] != s.Vector[ibmat]) {
              exitg1 = 1;
            } else {
              ibmat++;
            }
          } else {
            result = true;
            exitg1 = 1;
          }
        } while (exitg1 == 0);
      }

      if (result) {
        ibmat = 1;
      } else {
        result = false;
        if (i == 8) {
          ibmat = 0;
          do {
            exitg1 = 0;
            if (ibmat < 8) {
              if (b_cv3[ibmat] != s.Vector[ibmat]) {
                exitg1 = 1;
              } else {
                ibmat++;
              }
            } else {
              result = true;
              exitg1 = 1;
            }
          } while (exitg1 == 0);
        }

        if (result) {
          ibmat = 2;
        } else {
          ibmat = -1;
        }
      }
    }

    switch (ibmat) {
     case 0:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = b_iv[i];
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = -3.1415926535897931;
      poslim_data[1] = 3.1415926535897931;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      obj->VelocityNumber = 1.0;
      obj->PositionNumber = 1.0;
      obj->JointAxisInternal[0] = 0.0;
      obj->JointAxisInternal[1] = 0.0;
      obj->JointAxisInternal[2] = 1.0;
      break;

     case 1:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = b_iv1[i];
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = -0.5;
      poslim_data[1] = 0.5;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      obj->VelocityNumber = 1.0;
      obj->PositionNumber = 1.0;
      obj->JointAxisInternal[0] = 0.0;
      obj->JointAxisInternal[1] = 0.0;
      obj->JointAxisInternal[2] = 1.0;
      break;

     case 2:
      {
        signed char b_I[36];
        signed char b[6];
        for (i = 0; i < 36; i++) {
          b_I[i] = 0;
        }

        for (ibmat = 0; ibmat < 6; ibmat++) {
          b_I[ibmat + 6 * ibmat] = 1;
        }

        for (i = 0; i < 36; i++) {
          msubspace_data[i] = b_I[i];
        }

        poslim_size_idx_0 = 7;
        for (homepos_size_idx_1 = 0; homepos_size_idx_1 < 2; homepos_size_idx_1
             ++) {
          ibmat = homepos_size_idx_1 * 3;
          b_tmp = static_cast<signed char>(10 * homepos_size_idx_1 - 5);
          b[ibmat] = b_tmp;
          b[ibmat + 1] = b_tmp;
          b[ibmat + 2] = b_tmp;
          poslim_data[7 * homepos_size_idx_1] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 1] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 2] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 3] = rtNaN;
        }

        for (i = 0; i < 2; i++) {
          poslim_data[7 * i + 4] = b[3 * i];
          poslim_data[7 * i + 5] = b[3 * i + 1];
          poslim_data[7 * i + 6] = b[3 * i + 2];
        }

        homepos_size_idx_1 = 7;
        for (i = 0; i < 7; i++) {
          homepos_data[i] = iv2[i];
        }

        obj->VelocityNumber = 6.0;
        obj->PositionNumber = 7.0;
        obj->JointAxisInternal[0] = rtNaN;
        obj->JointAxisInternal[1] = rtNaN;
        obj->JointAxisInternal[2] = rtNaN;
      }
      break;

     default:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = 0.0;
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = 0.0;
      poslim_data[1] = 0.0;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      obj->VelocityNumber = 0.0;
      obj->PositionNumber = 0.0;
      obj->JointAxisInternal[0] = 0.0;
      obj->JointAxisInternal[1] = 0.0;
      obj->JointAxisInternal[2] = 0.0;
      break;
    }

    obj->set_MotionSubspace(msubspace_data);
    s = obj->TypeInternal;
    if (s.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(s.Length);
    }

    result = false;
    if (i == 5) {
      ibmat = 0;
      do {
        exitg1 = 0;
        if (ibmat < 5) {
          if (s.Vector[ibmat] != b_cv4[ibmat]) {
            exitg1 = 1;
          } else {
            ibmat++;
          }
        } else {
          result = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (!result) {
      double d;
      d = obj->PositionNumber;
      if (d < 1.0) {
        ibmat = 0;
      } else {
        ibmat = static_cast<int>(d);
      }

      for (i = 0; i < 2; i++) {
        for (int i1{0}; i1 < ibmat; i1++) {
          obj->PositionLimitsInternal[i1 + 7 * i] = poslim_data[i1 +
            poslim_size_idx_0 * i];
        }
      }

      for (i = 0; i < homepos_size_idx_1; i++) {
        obj->HomePositionInternal[i] = homepos_data[i];
      }
    } else {
      obj->PositionLimitsInternal[0] = poslim_data[0];
      obj->PositionLimitsInternal[7] = poslim_data[1];
      obj->HomePositionInternal[0] = homepos_data[0];
    }

    return obj;
  }

  //
  // Arguments    : void
  // Return Type  : void
  //
  void rigidBodyJoint::i_setFixedTransform()
  {
    static const double inputTform[16]{ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0,
      0.0, 0.0, 1.0, 0.0, 0.03, 0.0, 0.26, 1.0 };

    for (int i{0}; i < 16; i++) {
      JointToParentTransform[i] = inputTform[i];
      ChildToJointTransform[i] = 0.0;
    }

    ChildToJointTransform[0] = 1.0;
    ChildToJointTransform[5] = 1.0;
    ChildToJointTransform[10] = 1.0;
    ChildToJointTransform[15] = 1.0;
  }

  //
  // Arguments    : const double varargin_1[9]
  //                const double varargin_2[3]
  // Return Type  : void
  //
  void se3::init(const double varargin_1[9], const double varargin_2[3])
  {
    std::memset(&M[0], 0, 16U * sizeof(double));
    M[15] = 1.0;
    for (int i{0}; i < 3; i++) {
      int i1;
      i1 = i << 2;
      M[i1] = varargin_1[3 * i];
      M[i1 + 1] = varargin_1[3 * i + 1];
      M[i1 + 2] = varargin_1[3 * i + 2];
      M[i + 12] = varargin_2[i];
    }
  }

  //
  // Arguments    : void
  // Return Type  : collisionCapsule *
  //
  collisionCapsule *collisionCapsule::init()
  {
    void *geometryInternal;
    collisionCapsule *obj;
    obj = this;
    for (int i{0}; i < 16; i++) {
      obj->PoseInternal[i] = iv[i];
    }

    obj->RadiusInternal = 0.18;
    obj->LengthInternal = 0.05;
    geometryInternal = collisioncodegen_makeCapsule(0.18, 0.05);
    obj->GeometryInternal = geometryInternal;
    obj->matlabCodegenIsDeleted = false;
    return obj;
  }

  //
  // Arguments    : robotics::manip::internal::RigidBodyTree &iobj_0
  //                robotics::manip::internal::CollisionSet &iobj_1
  //                rigidBodyJoint &iobj_2
  //                robotics::manip::internal::RigidBody &iobj_3
  // Return Type  : rigidBody *
  //
  rigidBody *rigidBody::init(robotics::manip::internal::RigidBodyTree &iobj_0,
    robotics::manip::internal::CollisionSet &iobj_1, rigidBodyJoint &iobj_2,
    robotics::manip::internal::RigidBody &iobj_3)
  {
    static const char b_cv1[12]{ 'b', 'o', 'd', 'y', 'B', 'a', 's', 'e', '_',
      'j', 'n', 't' };

    static const char b_cv[8]{ 'b', 'o', 'd', 'y', 'B', 'a', 's', 'e' };

    static const char b_cv3[8]{ 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };

    static const char b_cv4[8]{ 'f', 'l', 'o', 'a', 't', 'i', 'n', 'g' };

    static const signed char iv2[7]{ 1, 0, 0, 0, 0, 0, 0 };

    static const signed char b_iv[6]{ 0, 0, 1, 0, 0, 0 };

    static const signed char b_iv1[6]{ 0, 0, 0, 0, 0, 1 };

    static const char b_cv2[5]{ 'f', 'i', 'x', 'e', 'd' };

    static const char b_cv5[5]{ 'f', 'i', 'x', 'e', 'd' };

    rigidBody *obj;
    robotics::manip::internal::CharacterVector s;
    robotics::manip::internal::RigidBodyTree *b_default;
    double msubspace_data[36];
    double poslim_data[14];
    int exitg1;
    int homepos_size_idx_1;
    int i;
    int i1;
    int ibmat;
    int poslim_size_idx_0;
    signed char b_I[36];
    signed char c_I[9];
    signed char homepos_data[7];
    bool result;
    obj = this;
    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    iobj_3.NameInternal = s;
    s = iobj_3.NameInternal;
    s.Length = 8.0;
    for (i = 0; i < 8; i++) {
      s.Vector[i] = b_cv[i];
    }

    iobj_3.NameInternal = s;
    iobj_2.InTree = false;
    for (i = 0; i < 16; i++) {
      i1 = iv[i];
      iobj_2.JointToParentTransform[i] = i1;
      iobj_2.ChildToJointTransform[i] = i1;
    }

    for (i = 0; i < 14; i++) {
      iobj_2.PositionLimitsInternal[i] = 0.0;
    }

    for (i = 0; i < 7; i++) {
      iobj_2.HomePositionInternal[i] = 0.0;
    }

    for (i = 0; i < 36; i++) {
      iobj_2.MotionSubspaceInternal[i] = 0.0;
    }

    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    iobj_2.NameInternal = s;
    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    iobj_2.TypeInternal = s;
    s = iobj_2.NameInternal;
    s.Length = 12.0;
    for (i = 0; i < 12; i++) {
      s.Vector[i] = b_cv1[i];
    }

    iobj_2.NameInternal = s;
    s = iobj_2.TypeInternal;
    s.Length = 5.0;
    for (i = 0; i < 5; i++) {
      s.Vector[i] = b_cv2[i];
    }

    iobj_2.TypeInternal = s;
    s = iobj_2.TypeInternal;
    if (s.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(s.Length);
    }

    result = false;
    if (i == 8) {
      ibmat = 0;
      do {
        exitg1 = 0;
        if (ibmat < 8) {
          if (b_cv3[ibmat] != s.Vector[ibmat]) {
            exitg1 = 1;
          } else {
            ibmat++;
          }
        } else {
          result = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (result) {
      ibmat = 0;
    } else {
      result = false;
      if (i == 9) {
        ibmat = 0;
        do {
          exitg1 = 0;
          if (ibmat < 9) {
            if (cv1[ibmat] != s.Vector[ibmat]) {
              exitg1 = 1;
            } else {
              ibmat++;
            }
          } else {
            result = true;
            exitg1 = 1;
          }
        } while (exitg1 == 0);
      }

      if (result) {
        ibmat = 1;
      } else {
        result = false;
        if (i == 8) {
          ibmat = 0;
          do {
            exitg1 = 0;
            if (ibmat < 8) {
              if (b_cv4[ibmat] != s.Vector[ibmat]) {
                exitg1 = 1;
              } else {
                ibmat++;
              }
            } else {
              result = true;
              exitg1 = 1;
            }
          } while (exitg1 == 0);
        }

        if (result) {
          ibmat = 2;
        } else {
          ibmat = -1;
        }
      }
    }

    switch (ibmat) {
     case 0:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = b_iv[i];
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = -3.1415926535897931;
      poslim_data[1] = 3.1415926535897931;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      iobj_2.VelocityNumber = 1.0;
      iobj_2.PositionNumber = 1.0;
      iobj_2.JointAxisInternal[0] = 0.0;
      iobj_2.JointAxisInternal[1] = 0.0;
      iobj_2.JointAxisInternal[2] = 1.0;
      break;

     case 1:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = b_iv1[i];
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = -0.5;
      poslim_data[1] = 0.5;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      iobj_2.VelocityNumber = 1.0;
      iobj_2.PositionNumber = 1.0;
      iobj_2.JointAxisInternal[0] = 0.0;
      iobj_2.JointAxisInternal[1] = 0.0;
      iobj_2.JointAxisInternal[2] = 1.0;
      break;

     case 2:
      {
        signed char b[6];
        for (i = 0; i < 36; i++) {
          b_I[i] = 0;
        }

        for (ibmat = 0; ibmat < 6; ibmat++) {
          b_I[ibmat + 6 * ibmat] = 1;
        }

        for (i = 0; i < 36; i++) {
          msubspace_data[i] = b_I[i];
        }

        poslim_size_idx_0 = 7;
        for (homepos_size_idx_1 = 0; homepos_size_idx_1 < 2; homepos_size_idx_1
             ++) {
          signed char b_tmp;
          ibmat = homepos_size_idx_1 * 3;
          b_tmp = static_cast<signed char>(10 * homepos_size_idx_1 - 5);
          b[ibmat] = b_tmp;
          b[ibmat + 1] = b_tmp;
          b[ibmat + 2] = b_tmp;
          poslim_data[7 * homepos_size_idx_1] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 1] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 2] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 3] = rtNaN;
        }

        for (i = 0; i < 2; i++) {
          poslim_data[7 * i + 4] = b[3 * i];
          poslim_data[7 * i + 5] = b[3 * i + 1];
          poslim_data[7 * i + 6] = b[3 * i + 2];
        }

        homepos_size_idx_1 = 7;
        for (i = 0; i < 7; i++) {
          homepos_data[i] = iv2[i];
        }

        iobj_2.VelocityNumber = 6.0;
        iobj_2.PositionNumber = 7.0;
        iobj_2.JointAxisInternal[0] = rtNaN;
        iobj_2.JointAxisInternal[1] = rtNaN;
        iobj_2.JointAxisInternal[2] = rtNaN;
      }
      break;

     default:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = 0.0;
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = 0.0;
      poslim_data[1] = 0.0;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      iobj_2.VelocityNumber = 0.0;
      iobj_2.PositionNumber = 0.0;
      iobj_2.JointAxisInternal[0] = 0.0;
      iobj_2.JointAxisInternal[1] = 0.0;
      iobj_2.JointAxisInternal[2] = 0.0;
      break;
    }

    iobj_2.set_MotionSubspace(msubspace_data);
    s = iobj_2.TypeInternal;
    if (s.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(s.Length);
    }

    result = false;
    if (i == 5) {
      ibmat = 0;
      do {
        exitg1 = 0;
        if (ibmat < 5) {
          if (s.Vector[ibmat] != b_cv5[ibmat]) {
            exitg1 = 1;
          } else {
            ibmat++;
          }
        } else {
          result = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (!result) {
      double d;
      d = iobj_2.PositionNumber;
      if (d < 1.0) {
        ibmat = 0;
      } else {
        ibmat = static_cast<int>(d);
      }

      for (i = 0; i < 2; i++) {
        for (i1 = 0; i1 < ibmat; i1++) {
          iobj_2.PositionLimitsInternal[i1 + 7 * i] = poslim_data[i1 +
            poslim_size_idx_0 * i];
        }
      }

      for (i = 0; i < homepos_size_idx_1; i++) {
        iobj_2.HomePositionInternal[i] = homepos_data[i];
      }
    } else {
      iobj_2.PositionLimitsInternal[0] = poslim_data[0];
      iobj_2.PositionLimitsInternal[7] = poslim_data[1];
      iobj_2.HomePositionInternal[0] = homepos_data[0];
    }

    iobj_3.JointInternal = &iobj_2;
    iobj_3.Index = -1.0;
    iobj_3.ParentIndex = -1.0;
    iobj_3.MassInternal = 1.0;
    iobj_3.CenterOfMassInternal[0] = 0.0;
    iobj_3.CenterOfMassInternal[1] = 0.0;
    iobj_3.CenterOfMassInternal[2] = 0.0;
    for (i = 0; i < 9; i++) {
      c_I[i] = 0;
    }

    c_I[0] = 1;
    c_I[4] = 1;
    c_I[8] = 1;
    for (i = 0; i < 9; i++) {
      iobj_3.InertiaInternal[i] = c_I[i];
    }

    for (i = 0; i < 36; i++) {
      b_I[i] = 0;
    }

    for (ibmat = 0; ibmat < 6; ibmat++) {
      b_I[ibmat + 6 * ibmat] = 1;
    }

    for (i = 0; i < 36; i++) {
      iobj_3.SpatialInertia[i] = b_I[i];
    }

    iobj_3.CollisionsInternal = (&iobj_1)[0].init(static_cast<double>(0.0));
    iobj_3.matlabCodegenIsDeleted = false;
    b_default = iobj_0.init();
    iobj_3.CollisionsInternal = (&iobj_1)[1].init(1.0);
    obj->BodyInternal = &iobj_3;
    obj->TreeInternal = b_default;
    obj->matlabCodegenIsDeleted = false;
    return obj;
  }

  //
  // Arguments    : void
  // Return Type  : constraintPositionTarget *
  //
  constraintPositionTarget *constraintPositionTarget::init()
  {
    constraintPositionTarget *obj;
    obj = this;
    obj->ConstructorPropertyDefaultValues.f2[0] = 0.0;
    obj->ConstructorPropertyDefaultValues.f2[1] = 0.0;
    obj->ConstructorPropertyDefaultValues.f2[2] = 0.0;
    obj->ConstructorPropertyDefaultValues.f3 = 0.0;
    obj->ConstructorPropertyDefaultValues.f4 = 1.0;
    for (int i{0}; i < 9; i++) {
      obj->EndEffector[i] = cv4[i];
    }

    double d;
    double defaultValues_f3;
    double defaultValues_f4;
    defaultValues_f3 = obj->ConstructorPropertyDefaultValues.f3;
    defaultValues_f4 = obj->ConstructorPropertyDefaultValues.f4;
    obj->ReferenceBody.set_size(0, 0);
    d = obj->ConstructorPropertyDefaultValues.f2[0];
    obj->TargetPosition[0] = d;
    d = obj->ConstructorPropertyDefaultValues.f2[1];
    obj->TargetPosition[1] = d;
    d = obj->ConstructorPropertyDefaultValues.f2[2];
    obj->TargetPosition[2] = d;
    obj->PositionTolerance = defaultValues_f3;
    obj->Weights = defaultValues_f4;
    return obj;
  }

  //
  // Arguments    : void
  // Return Type  : rigidBodyJoint *
  //
  rigidBodyJoint *rigidBodyJoint::init()
  {
    static const char b_cv[8]{ 'b', 'a', 's', 'e', '_', 'j', 'n', 't' };

    static const char b_cv2[8]{ 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };

    static const char b_cv3[8]{ 'f', 'l', 'o', 'a', 't', 'i', 'n', 'g' };

    static const signed char iv2[7]{ 1, 0, 0, 0, 0, 0, 0 };

    static const signed char b_iv[6]{ 0, 0, 1, 0, 0, 0 };

    static const signed char b_iv1[6]{ 0, 0, 0, 0, 0, 1 };

    static const char b_cv1[5]{ 'f', 'i', 'x', 'e', 'd' };

    static const char b_cv4[5]{ 'f', 'i', 'x', 'e', 'd' };

    rigidBodyJoint *obj;
    robotics::manip::internal::CharacterVector s;
    double msubspace_data[36];
    double poslim_data[14];
    int exitg1;
    int homepos_size_idx_1;
    int i;
    int ibmat;
    int poslim_size_idx_0;
    signed char homepos_data[7];
    signed char b_tmp;
    bool result;
    obj = this;
    obj->InTree = false;
    for (i = 0; i < 16; i++) {
      b_tmp = iv[i];
      obj->JointToParentTransform[i] = b_tmp;
      obj->ChildToJointTransform[i] = b_tmp;
    }

    for (i = 0; i < 14; i++) {
      obj->PositionLimitsInternal[i] = 0.0;
    }

    for (i = 0; i < 7; i++) {
      obj->HomePositionInternal[i] = 0.0;
    }

    for (i = 0; i < 36; i++) {
      obj->MotionSubspaceInternal[i] = 0.0;
    }

    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    obj->NameInternal = s;
    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    obj->TypeInternal = s;
    s = obj->NameInternal;
    s.Length = 8.0;
    for (i = 0; i < 8; i++) {
      s.Vector[i] = b_cv[i];
    }

    obj->NameInternal = s;
    s = obj->TypeInternal;
    s.Length = 5.0;
    for (i = 0; i < 5; i++) {
      s.Vector[i] = b_cv1[i];
    }

    obj->TypeInternal = s;
    s = obj->TypeInternal;
    if (s.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(s.Length);
    }

    result = false;
    if (i == 8) {
      ibmat = 0;
      do {
        exitg1 = 0;
        if (ibmat < 8) {
          if (b_cv2[ibmat] != s.Vector[ibmat]) {
            exitg1 = 1;
          } else {
            ibmat++;
          }
        } else {
          result = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (result) {
      ibmat = 0;
    } else {
      result = false;
      if (i == 9) {
        ibmat = 0;
        do {
          exitg1 = 0;
          if (ibmat < 9) {
            if (cv1[ibmat] != s.Vector[ibmat]) {
              exitg1 = 1;
            } else {
              ibmat++;
            }
          } else {
            result = true;
            exitg1 = 1;
          }
        } while (exitg1 == 0);
      }

      if (result) {
        ibmat = 1;
      } else {
        result = false;
        if (i == 8) {
          ibmat = 0;
          do {
            exitg1 = 0;
            if (ibmat < 8) {
              if (b_cv3[ibmat] != s.Vector[ibmat]) {
                exitg1 = 1;
              } else {
                ibmat++;
              }
            } else {
              result = true;
              exitg1 = 1;
            }
          } while (exitg1 == 0);
        }

        if (result) {
          ibmat = 2;
        } else {
          ibmat = -1;
        }
      }
    }

    switch (ibmat) {
     case 0:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = b_iv[i];
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = -3.1415926535897931;
      poslim_data[1] = 3.1415926535897931;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      obj->VelocityNumber = 1.0;
      obj->PositionNumber = 1.0;
      obj->JointAxisInternal[0] = 0.0;
      obj->JointAxisInternal[1] = 0.0;
      obj->JointAxisInternal[2] = 1.0;
      break;

     case 1:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = b_iv1[i];
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = -0.5;
      poslim_data[1] = 0.5;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      obj->VelocityNumber = 1.0;
      obj->PositionNumber = 1.0;
      obj->JointAxisInternal[0] = 0.0;
      obj->JointAxisInternal[1] = 0.0;
      obj->JointAxisInternal[2] = 1.0;
      break;

     case 2:
      {
        signed char b_I[36];
        signed char b[6];
        for (i = 0; i < 36; i++) {
          b_I[i] = 0;
        }

        for (ibmat = 0; ibmat < 6; ibmat++) {
          b_I[ibmat + 6 * ibmat] = 1;
        }

        for (i = 0; i < 36; i++) {
          msubspace_data[i] = b_I[i];
        }

        poslim_size_idx_0 = 7;
        for (homepos_size_idx_1 = 0; homepos_size_idx_1 < 2; homepos_size_idx_1
             ++) {
          ibmat = homepos_size_idx_1 * 3;
          b_tmp = static_cast<signed char>(10 * homepos_size_idx_1 - 5);
          b[ibmat] = b_tmp;
          b[ibmat + 1] = b_tmp;
          b[ibmat + 2] = b_tmp;
          poslim_data[7 * homepos_size_idx_1] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 1] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 2] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 3] = rtNaN;
        }

        for (i = 0; i < 2; i++) {
          poslim_data[7 * i + 4] = b[3 * i];
          poslim_data[7 * i + 5] = b[3 * i + 1];
          poslim_data[7 * i + 6] = b[3 * i + 2];
        }

        homepos_size_idx_1 = 7;
        for (i = 0; i < 7; i++) {
          homepos_data[i] = iv2[i];
        }

        obj->VelocityNumber = 6.0;
        obj->PositionNumber = 7.0;
        obj->JointAxisInternal[0] = rtNaN;
        obj->JointAxisInternal[1] = rtNaN;
        obj->JointAxisInternal[2] = rtNaN;
      }
      break;

     default:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = 0.0;
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = 0.0;
      poslim_data[1] = 0.0;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      obj->VelocityNumber = 0.0;
      obj->PositionNumber = 0.0;
      obj->JointAxisInternal[0] = 0.0;
      obj->JointAxisInternal[1] = 0.0;
      obj->JointAxisInternal[2] = 0.0;
      break;
    }

    obj->set_MotionSubspace(msubspace_data);
    s = obj->TypeInternal;
    if (s.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(s.Length);
    }

    result = false;
    if (i == 5) {
      ibmat = 0;
      do {
        exitg1 = 0;
        if (ibmat < 5) {
          if (s.Vector[ibmat] != b_cv4[ibmat]) {
            exitg1 = 1;
          } else {
            ibmat++;
          }
        } else {
          result = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (!result) {
      double d;
      d = obj->PositionNumber;
      if (d < 1.0) {
        ibmat = 0;
      } else {
        ibmat = static_cast<int>(d);
      }

      for (i = 0; i < 2; i++) {
        for (int i1{0}; i1 < ibmat; i1++) {
          obj->PositionLimitsInternal[i1 + 7 * i] = poslim_data[i1 +
            poslim_size_idx_0 * i];
        }
      }

      for (i = 0; i < homepos_size_idx_1; i++) {
        obj->HomePositionInternal[i] = homepos_data[i];
      }
    } else {
      obj->PositionLimitsInternal[0] = poslim_data[0];
      obj->PositionLimitsInternal[7] = poslim_data[1];
      obj->HomePositionInternal[0] = homepos_data[0];
    }

    return obj;
  }

  //
  // Arguments    : void
  // Return Type  : rigidBodyTree *
  //
  rigidBodyTree *rigidBodyTree::init()
  {
    rigidBodyTree *obj;
    obj = this;
    obj->TreeInternal = obj->_pobj1.init();
    obj->TreeInternal->Base.CollisionsInternal = obj->_pobj0.init(10.0);
    obj->matlabCodegenIsDeleted = false;
    return obj;
  }

  //
  // Arguments    : void
  // Return Type  : constraintOrientationTarget *
  //
  constraintOrientationTarget *constraintOrientationTarget::init()
  {
    constraintOrientationTarget *obj;
    obj = this;
    obj->ConstructorPropertyDefaultValues.f2[0] = 1.0;
    obj->ConstructorPropertyDefaultValues.f2[1] = 0.0;
    obj->ConstructorPropertyDefaultValues.f2[2] = 0.0;
    obj->ConstructorPropertyDefaultValues.f2[3] = 0.0;
    obj->ConstructorPropertyDefaultValues.f3 = 0.0;
    obj->ConstructorPropertyDefaultValues.f4 = 1.0;
    for (int i{0}; i < 10; i++) {
      obj->EndEffector[i] = cv3[i];
    }

    double defaultValues_f2_idx_0;
    double defaultValues_f2_idx_1;
    double defaultValues_f2_idx_2;
    double defaultValues_f2_idx_3;
    double defaultValues_f3;
    double defaultValues_f4;
    double normRowMatrix_idx_0;
    double normRowMatrix_idx_1;
    double normRowMatrix_idx_2;
    defaultValues_f3 = obj->ConstructorPropertyDefaultValues.f3;
    defaultValues_f4 = obj->ConstructorPropertyDefaultValues.f4;
    obj->ReferenceBody.set_size(0, 0);
    defaultValues_f2_idx_3 = obj->ConstructorPropertyDefaultValues.f2[0];
    defaultValues_f2_idx_0 = defaultValues_f2_idx_3;
    normRowMatrix_idx_0 = defaultValues_f2_idx_3 * defaultValues_f2_idx_3;
    defaultValues_f2_idx_3 = obj->ConstructorPropertyDefaultValues.f2[1];
    defaultValues_f2_idx_1 = defaultValues_f2_idx_3;
    normRowMatrix_idx_1 = defaultValues_f2_idx_3 * defaultValues_f2_idx_3;
    defaultValues_f2_idx_3 = obj->ConstructorPropertyDefaultValues.f2[2];
    defaultValues_f2_idx_2 = defaultValues_f2_idx_3;
    normRowMatrix_idx_2 = defaultValues_f2_idx_3 * defaultValues_f2_idx_3;
    defaultValues_f2_idx_3 = obj->ConstructorPropertyDefaultValues.f2[3];
    normRowMatrix_idx_0 = 1.0 / std::sqrt(((normRowMatrix_idx_0 +
      normRowMatrix_idx_1) + normRowMatrix_idx_2) + defaultValues_f2_idx_3 *
      defaultValues_f2_idx_3);
    obj->TargetOrientation[0] = defaultValues_f2_idx_0 * normRowMatrix_idx_0;
    obj->TargetOrientation[1] = defaultValues_f2_idx_1 * normRowMatrix_idx_0;
    obj->TargetOrientation[2] = defaultValues_f2_idx_2 * normRowMatrix_idx_0;
    obj->TargetOrientation[3] = defaultValues_f2_idx_3 * normRowMatrix_idx_0;
    obj->OrientationTolerance = defaultValues_f3;
    obj->Weights = defaultValues_f4;
    return obj;
  }

  //
  // Arguments    : const char jname[14]
  // Return Type  : rigidBodyJoint *
  //
  rigidBodyJoint *rigidBodyJoint::init(const char jname[14])
  {
    static const char b_cv1[8]{ 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };

    static const char b_cv2[8]{ 'f', 'l', 'o', 'a', 't', 'i', 'n', 'g' };

    static const signed char iv2[7]{ 1, 0, 0, 0, 0, 0, 0 };

    static const signed char b_iv[6]{ 0, 0, 1, 0, 0, 0 };

    static const signed char b_iv1[6]{ 0, 0, 0, 0, 0, 1 };

    static const char b_cv[5]{ 'f', 'i', 'x', 'e', 'd' };

    static const char b_cv3[5]{ 'f', 'i', 'x', 'e', 'd' };

    rigidBodyJoint *obj;
    robotics::manip::internal::CharacterVector s;
    double msubspace_data[36];
    double poslim_data[14];
    int exitg1;
    int homepos_size_idx_1;
    int i;
    int ibmat;
    int poslim_size_idx_0;
    signed char homepos_data[7];
    signed char b_tmp;
    bool result;
    obj = this;
    obj->InTree = false;
    for (i = 0; i < 16; i++) {
      b_tmp = iv[i];
      obj->JointToParentTransform[i] = b_tmp;
      obj->ChildToJointTransform[i] = b_tmp;
    }

    for (i = 0; i < 14; i++) {
      obj->PositionLimitsInternal[i] = 0.0;
    }

    for (i = 0; i < 7; i++) {
      obj->HomePositionInternal[i] = 0.0;
    }

    for (i = 0; i < 36; i++) {
      obj->MotionSubspaceInternal[i] = 0.0;
    }

    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    obj->NameInternal = s;
    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    obj->TypeInternal = s;
    s = obj->NameInternal;
    s.Length = 14.0;
    for (i = 0; i < 14; i++) {
      s.Vector[i] = jname[i];
    }

    obj->NameInternal = s;
    s = obj->TypeInternal;
    s.Length = 5.0;
    for (i = 0; i < 5; i++) {
      s.Vector[i] = b_cv[i];
    }

    obj->TypeInternal = s;
    s = obj->TypeInternal;
    if (s.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(s.Length);
    }

    result = false;
    if (i == 8) {
      ibmat = 0;
      do {
        exitg1 = 0;
        if (ibmat < 8) {
          if (b_cv1[ibmat] != s.Vector[ibmat]) {
            exitg1 = 1;
          } else {
            ibmat++;
          }
        } else {
          result = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (result) {
      ibmat = 0;
    } else {
      result = false;
      if (i == 9) {
        ibmat = 0;
        do {
          exitg1 = 0;
          if (ibmat < 9) {
            if (cv1[ibmat] != s.Vector[ibmat]) {
              exitg1 = 1;
            } else {
              ibmat++;
            }
          } else {
            result = true;
            exitg1 = 1;
          }
        } while (exitg1 == 0);
      }

      if (result) {
        ibmat = 1;
      } else {
        result = false;
        if (i == 8) {
          ibmat = 0;
          do {
            exitg1 = 0;
            if (ibmat < 8) {
              if (b_cv2[ibmat] != s.Vector[ibmat]) {
                exitg1 = 1;
              } else {
                ibmat++;
              }
            } else {
              result = true;
              exitg1 = 1;
            }
          } while (exitg1 == 0);
        }

        if (result) {
          ibmat = 2;
        } else {
          ibmat = -1;
        }
      }
    }

    switch (ibmat) {
     case 0:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = b_iv[i];
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = -3.1415926535897931;
      poslim_data[1] = 3.1415926535897931;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      obj->VelocityNumber = 1.0;
      obj->PositionNumber = 1.0;
      obj->JointAxisInternal[0] = 0.0;
      obj->JointAxisInternal[1] = 0.0;
      obj->JointAxisInternal[2] = 1.0;
      break;

     case 1:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = b_iv1[i];
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = -0.5;
      poslim_data[1] = 0.5;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      obj->VelocityNumber = 1.0;
      obj->PositionNumber = 1.0;
      obj->JointAxisInternal[0] = 0.0;
      obj->JointAxisInternal[1] = 0.0;
      obj->JointAxisInternal[2] = 1.0;
      break;

     case 2:
      {
        signed char b_I[36];
        signed char b[6];
        for (i = 0; i < 36; i++) {
          b_I[i] = 0;
        }

        for (ibmat = 0; ibmat < 6; ibmat++) {
          b_I[ibmat + 6 * ibmat] = 1;
        }

        for (i = 0; i < 36; i++) {
          msubspace_data[i] = b_I[i];
        }

        poslim_size_idx_0 = 7;
        for (homepos_size_idx_1 = 0; homepos_size_idx_1 < 2; homepos_size_idx_1
             ++) {
          ibmat = homepos_size_idx_1 * 3;
          b_tmp = static_cast<signed char>(10 * homepos_size_idx_1 - 5);
          b[ibmat] = b_tmp;
          b[ibmat + 1] = b_tmp;
          b[ibmat + 2] = b_tmp;
          poslim_data[7 * homepos_size_idx_1] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 1] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 2] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 3] = rtNaN;
        }

        for (i = 0; i < 2; i++) {
          poslim_data[7 * i + 4] = b[3 * i];
          poslim_data[7 * i + 5] = b[3 * i + 1];
          poslim_data[7 * i + 6] = b[3 * i + 2];
        }

        homepos_size_idx_1 = 7;
        for (i = 0; i < 7; i++) {
          homepos_data[i] = iv2[i];
        }

        obj->VelocityNumber = 6.0;
        obj->PositionNumber = 7.0;
        obj->JointAxisInternal[0] = rtNaN;
        obj->JointAxisInternal[1] = rtNaN;
        obj->JointAxisInternal[2] = rtNaN;
      }
      break;

     default:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = 0.0;
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = 0.0;
      poslim_data[1] = 0.0;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      obj->VelocityNumber = 0.0;
      obj->PositionNumber = 0.0;
      obj->JointAxisInternal[0] = 0.0;
      obj->JointAxisInternal[1] = 0.0;
      obj->JointAxisInternal[2] = 0.0;
      break;
    }

    obj->set_MotionSubspace(msubspace_data);
    s = obj->TypeInternal;
    if (s.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(s.Length);
    }

    result = false;
    if (i == 5) {
      ibmat = 0;
      do {
        exitg1 = 0;
        if (ibmat < 5) {
          if (s.Vector[ibmat] != b_cv3[ibmat]) {
            exitg1 = 1;
          } else {
            ibmat++;
          }
        } else {
          result = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (!result) {
      double d;
      d = obj->PositionNumber;
      if (d < 1.0) {
        ibmat = 0;
      } else {
        ibmat = static_cast<int>(d);
      }

      for (i = 0; i < 2; i++) {
        for (int i1{0}; i1 < ibmat; i1++) {
          obj->PositionLimitsInternal[i1 + 7 * i] = poslim_data[i1 +
            poslim_size_idx_0 * i];
        }
      }

      for (i = 0; i < homepos_size_idx_1; i++) {
        obj->HomePositionInternal[i] = homepos_data[i];
      }
    } else {
      obj->PositionLimitsInternal[0] = poslim_data[0];
      obj->PositionLimitsInternal[7] = poslim_data[1];
      obj->HomePositionInternal[0] = homepos_data[0];
    }

    return obj;
  }

  //
  // Arguments    : rigidBodyTree &varargin_2
  // Return Type  : generalizedInverseKinematics *
  //
  generalizedInverseKinematics *generalizedInverseKinematics::init(rigidBodyTree
    &varargin_2)
  {
    static const char b_cv[22]{ 'B', 'F', 'G', 'S', 'G', 'r', 'a', 'd', 'i', 'e',
      'n', 't', 'P', 'r', 'o', 'j', 'e', 'c', 't', 'i', 'o', 'n' };

    void *copyGeometryInternal;
    generalizedInverseKinematics *obj;
    robotics::manip::internal::CharacterVector c_obj;
    robotics::manip::internal::CollisionGeometry b_newObj;
    robotics::manip::internal::CollisionGeometry e_obj;
    robotics::manip::internal::CollisionSet *d_obj;
    robotics::manip::internal::CollisionSet *newObj;
    robotics::manip::internal::RigidBody *body;
    robotics::manip::internal::RigidBody *parent;
    robotics::manip::internal::b_RigidBodyTree *b_obj;
    robotics::manip::internal::b_RigidBodyTree *newrobot;
    double pid;
    int obj_size[2];
    int loop_ub;
    char obj_data[200];
    obj = this;
    obj->EnforceJointLimits = true;
    obj->isInitialized = 0;
    obj->_pobj4.MaxNumIteration = 1500.0;
    obj->_pobj4.MaxTime = 10.0;
    obj->_pobj4.GradientTolerance = 1.0E-7;
    obj->_pobj4.SolutionTolerance = 1.0E-6;
    obj->_pobj4.ArmijoRuleBeta = 0.4;
    obj->_pobj4.ArmijoRuleSigma = 1.0E-5;
    obj->_pobj4.ConstraintsOn = true;
    obj->_pobj4.RandomRestart = true;
    obj->_pobj4.StepTolerance = 1.0E-14;
    for (loop_ub = 0; loop_ub < 22; loop_ub++) {
      obj->_pobj4.Name[loop_ub] = b_cv[loop_ub];
    }

    obj->_pobj4.ConstraintMatrix.set_size(0, 0);
    obj->_pobj4.ConstraintBound.set_size(0);
    obj->_pobj4.TimeObj.StartTime.tv_sec = 0.0;
    obj->_pobj4.TimeObj.StartTime.tv_nsec = 0.0;
    obj->_pobj4.TimeObjInternal.StartTime.tv_sec = 0.0;
    obj->_pobj4.TimeObjInternal.StartTime.tv_nsec = 0.0;
    obj->_pobj4.matlabCodegenIsDeleted = false;
    obj->Solver = &obj->_pobj4;
    b_obj = varargin_2.TreeInternal;
    newrobot = obj->_pobj3.init();
    c_obj = b_obj->Base.NameInternal;
    if (c_obj.Length < 1.0) {
      loop_ub = 0;
    } else {
      loop_ub = static_cast<int>(c_obj.Length);
    }

    obj_size[0] = 1;
    obj_size[1] = loop_ub;
    if (loop_ub - 1 >= 0) {
      ::std::copy(&c_obj.Vector[0], &c_obj.Vector[loop_ub], &obj_data[0]);
    }

    newrobot->set_BaseName(obj_data, obj_size);
    d_obj = b_obj->Base.CollisionsInternal;
    newObj = obj->_pobj2[0].init(d_obj->MaxElements);
    newObj->Size = d_obj->Size;
    pid = d_obj->Size;
    loop_ub = static_cast<int>(pid);
    for (int i{0}; i < loop_ub; i++) {
      e_obj = d_obj->CollisionGeometries[i];
      copyGeometryInternal = collisioncodegen_copyGeometry
        (e_obj.CollisionPrimitive);
      b_newObj.CollisionPrimitive = copyGeometryInternal;
      ::std::copy(&e_obj.LocalPose[0], &e_obj.LocalPose[16],
                  &b_newObj.LocalPose[0]);
      b_newObj.MeshScale[0] = e_obj.MeshScale[0];
      b_newObj.MeshScale[1] = e_obj.MeshScale[1];
      b_newObj.MeshScale[2] = e_obj.MeshScale[2];
      ::std::copy(&e_obj.WorldPose[0], &e_obj.WorldPose[16],
                  &b_newObj.WorldPose[0]);
      newObj->CollisionGeometries[i] = b_newObj;
    }

    double g_idx_1;
    double g_idx_2;
    newrobot->Base.CollisionsInternal = newObj;
    pid = b_obj->Gravity[0];
    g_idx_1 = b_obj->Gravity[1];
    g_idx_2 = b_obj->Gravity[2];
    newrobot->Gravity[0] = pid;
    newrobot->Gravity[1] = g_idx_1;
    newrobot->Gravity[2] = g_idx_2;
    if (b_obj->NumBodies >= 1.0) {
      body = b_obj->Bodies[0];
      pid = body->ParentIndex;
      if (pid > 0.0) {
        parent = b_obj->Bodies[static_cast<int>(pid) - 1];
      } else {
        parent = &b_obj->Base;
      }

      c_obj = parent->NameInternal;
      if (c_obj.Length < 1.0) {
        loop_ub = 0;
      } else {
        loop_ub = static_cast<int>(c_obj.Length);
      }

      obj_size[0] = 1;
      obj_size[1] = loop_ub;
      if (loop_ub - 1 >= 0) {
        ::std::copy(&c_obj.Vector[0], &c_obj.Vector[loop_ub], &obj_data[0]);
      }

      newrobot->addBody(body, obj_data, obj_size, obj->_pobj2[1], obj->_pobj0[0],
                        obj->_pobj1[0]);
    }

    if (b_obj->NumBodies >= 2.0) {
      body = b_obj->Bodies[1];
      pid = body->ParentIndex;
      if (pid > 0.0) {
        parent = b_obj->Bodies[static_cast<int>(pid) - 1];
      } else {
        parent = &b_obj->Base;
      }

      c_obj = parent->NameInternal;
      if (c_obj.Length < 1.0) {
        loop_ub = 0;
      } else {
        loop_ub = static_cast<int>(c_obj.Length);
      }

      obj_size[0] = 1;
      obj_size[1] = loop_ub;
      if (loop_ub - 1 >= 0) {
        ::std::copy(&c_obj.Vector[0], &c_obj.Vector[loop_ub], &obj_data[0]);
      }

      newrobot->addBody(body, obj_data, obj_size, obj->_pobj2[3], obj->_pobj0[2],
                        obj->_pobj1[1]);
    }

    if (b_obj->NumBodies >= 3.0) {
      body = b_obj->Bodies[2];
      pid = body->ParentIndex;
      if (pid > 0.0) {
        parent = b_obj->Bodies[static_cast<int>(pid) - 1];
      } else {
        parent = &b_obj->Base;
      }

      c_obj = parent->NameInternal;
      if (c_obj.Length < 1.0) {
        loop_ub = 0;
      } else {
        loop_ub = static_cast<int>(c_obj.Length);
      }

      obj_size[0] = 1;
      obj_size[1] = loop_ub;
      if (loop_ub - 1 >= 0) {
        ::std::copy(&c_obj.Vector[0], &c_obj.Vector[loop_ub], &obj_data[0]);
      }

      newrobot->addBody(body, obj_data, obj_size, obj->_pobj2[5], obj->_pobj0[4],
                        obj->_pobj1[2]);
    }

    if (b_obj->NumBodies >= 4.0) {
      body = b_obj->Bodies[3];
      pid = body->ParentIndex;
      if (pid > 0.0) {
        parent = b_obj->Bodies[static_cast<int>(pid) - 1];
      } else {
        parent = &b_obj->Base;
      }

      c_obj = parent->NameInternal;
      if (c_obj.Length < 1.0) {
        loop_ub = 0;
      } else {
        loop_ub = static_cast<int>(c_obj.Length);
      }

      obj_size[0] = 1;
      obj_size[1] = loop_ub;
      if (loop_ub - 1 >= 0) {
        ::std::copy(&c_obj.Vector[0], &c_obj.Vector[loop_ub], &obj_data[0]);
      }

      newrobot->addBody(body, obj_data, obj_size, obj->_pobj2[7], obj->_pobj0[6],
                        obj->_pobj1[3]);
    }

    if (b_obj->NumBodies >= 5.0) {
      body = b_obj->Bodies[4];
      pid = body->ParentIndex;
      if (pid > 0.0) {
        parent = b_obj->Bodies[static_cast<int>(pid) - 1];
      } else {
        parent = &b_obj->Base;
      }

      c_obj = parent->NameInternal;
      if (c_obj.Length < 1.0) {
        loop_ub = 0;
      } else {
        loop_ub = static_cast<int>(c_obj.Length);
      }

      obj_size[0] = 1;
      obj_size[1] = loop_ub;
      if (loop_ub - 1 >= 0) {
        ::std::copy(&c_obj.Vector[0], &c_obj.Vector[loop_ub], &obj_data[0]);
      }

      newrobot->addBody(body, obj_data, obj_size, obj->_pobj2[9], obj->_pobj0[8],
                        obj->_pobj1[4]);
    }

    if (b_obj->NumBodies >= 6.0) {
      body = b_obj->Bodies[5];
      pid = body->ParentIndex;
      if (pid > 0.0) {
        parent = b_obj->Bodies[static_cast<int>(pid) - 1];
      } else {
        parent = &b_obj->Base;
      }

      c_obj = parent->NameInternal;
      if (c_obj.Length < 1.0) {
        loop_ub = 0;
      } else {
        loop_ub = static_cast<int>(c_obj.Length);
      }

      obj_size[0] = 1;
      obj_size[1] = loop_ub;
      if (loop_ub - 1 >= 0) {
        ::std::copy(&c_obj.Vector[0], &c_obj.Vector[loop_ub], &obj_data[0]);
      }

      newrobot->addBody(body, obj_data, obj_size, obj->_pobj2[11], obj->_pobj0
                        [10], obj->_pobj1[5]);
    }

    if (b_obj->NumBodies >= 7.0) {
      body = b_obj->Bodies[6];
      pid = body->ParentIndex;
      if (pid > 0.0) {
        parent = b_obj->Bodies[static_cast<int>(pid) - 1];
      } else {
        parent = &b_obj->Base;
      }

      c_obj = parent->NameInternal;
      if (c_obj.Length < 1.0) {
        loop_ub = 0;
      } else {
        loop_ub = static_cast<int>(c_obj.Length);
      }

      obj_size[0] = 1;
      obj_size[1] = loop_ub;
      if (loop_ub - 1 >= 0) {
        ::std::copy(&c_obj.Vector[0], &c_obj.Vector[loop_ub], &obj_data[0]);
      }

      newrobot->addBody(body, obj_data, obj_size, obj->_pobj2[13], obj->_pobj0
                        [12], obj->_pobj1[6]);
    }

    if (b_obj->NumBodies >= 8.0) {
      body = b_obj->Bodies[7];
      pid = body->ParentIndex;
      if (pid > 0.0) {
        parent = b_obj->Bodies[static_cast<int>(pid) - 1];
      } else {
        parent = &b_obj->Base;
      }

      c_obj = parent->NameInternal;
      if (c_obj.Length < 1.0) {
        loop_ub = 0;
      } else {
        loop_ub = static_cast<int>(c_obj.Length);
      }

      obj_size[0] = 1;
      obj_size[1] = loop_ub;
      if (loop_ub - 1 >= 0) {
        ::std::copy(&c_obj.Vector[0], &c_obj.Vector[loop_ub], &obj_data[0]);
      }

      newrobot->addBody(body, obj_data, obj_size, obj->_pobj2[15], obj->_pobj0
                        [14], obj->_pobj1[7]);
    }

    if (b_obj->NumBodies >= 9.0) {
      body = b_obj->Bodies[8];
      pid = body->ParentIndex;
      if (pid > 0.0) {
        parent = b_obj->Bodies[static_cast<int>(pid) - 1];
      } else {
        parent = &b_obj->Base;
      }

      c_obj = parent->NameInternal;
      if (c_obj.Length < 1.0) {
        loop_ub = 0;
      } else {
        loop_ub = static_cast<int>(c_obj.Length);
      }

      obj_size[0] = 1;
      obj_size[1] = loop_ub;
      if (loop_ub - 1 >= 0) {
        ::std::copy(&c_obj.Vector[0], &c_obj.Vector[loop_ub], &obj_data[0]);
      }

      newrobot->addBody(body, obj_data, obj_size, obj->_pobj2[17], obj->_pobj0
                        [16], obj->_pobj1[8]);
    }

    if (b_obj->NumBodies >= 10.0) {
      body = b_obj->Bodies[9];
      pid = body->ParentIndex;
      if (pid > 0.0) {
        parent = b_obj->Bodies[static_cast<int>(pid) - 1];
      } else {
        parent = &b_obj->Base;
      }

      c_obj = parent->NameInternal;
      if (c_obj.Length < 1.0) {
        loop_ub = 0;
      } else {
        loop_ub = static_cast<int>(c_obj.Length);
      }

      obj_size[0] = 1;
      obj_size[1] = loop_ub;
      if (loop_ub - 1 >= 0) {
        ::std::copy(&c_obj.Vector[0], &c_obj.Vector[loop_ub], &obj_data[0]);
      }

      newrobot->addBody(body, obj_data, obj_size, obj->_pobj2[19], obj->_pobj0
                        [18], obj->_pobj1[9]);
    }

    if (b_obj->NumBodies >= 11.0) {
      body = b_obj->Bodies[10];
      pid = body->ParentIndex;
      if (pid > 0.0) {
        parent = b_obj->Bodies[static_cast<int>(pid) - 1];
      } else {
        parent = &b_obj->Base;
      }

      c_obj = parent->NameInternal;
      if (c_obj.Length < 1.0) {
        loop_ub = 0;
      } else {
        loop_ub = static_cast<int>(c_obj.Length);
      }

      obj_size[0] = 1;
      obj_size[1] = loop_ub;
      if (loop_ub - 1 >= 0) {
        ::std::copy(&c_obj.Vector[0], &c_obj.Vector[loop_ub], &obj_data[0]);
      }

      newrobot->addBody(body, obj_data, obj_size, obj->_pobj2[21], obj->_pobj0
                        [20], obj->_pobj1[10]);
    }

    if (b_obj->NumBodies >= 12.0) {
      body = b_obj->Bodies[11];
      pid = body->ParentIndex;
      if (pid > 0.0) {
        parent = b_obj->Bodies[static_cast<int>(pid) - 1];
      } else {
        parent = &b_obj->Base;
      }

      c_obj = parent->NameInternal;
      if (c_obj.Length < 1.0) {
        loop_ub = 0;
      } else {
        loop_ub = static_cast<int>(c_obj.Length);
      }

      obj_size[0] = 1;
      obj_size[1] = loop_ub;
      if (loop_ub - 1 >= 0) {
        ::std::copy(&c_obj.Vector[0], &c_obj.Vector[loop_ub], &obj_data[0]);
      }

      newrobot->addBody(body, obj_data, obj_size, obj->_pobj2[23], obj->_pobj0
                        [22], obj->_pobj1[11]);
    }

    obj->Tree = newrobot;
    obj->RigidBodyTreeHasBeenSet = true;
    obj->matlabCodegenIsDeleted = false;
    return obj;
  }

  //
  // Arguments    : robotics::manip::internal::RigidBodyTree &iobj_0
  //                robotics::manip::internal::CollisionSet &iobj_1
  //                rigidBodyJoint &iobj_2
  //                robotics::manip::internal::RigidBody &iobj_3
  // Return Type  : rigidBody *
  //
  rigidBody *rigidBody::j_init(robotics::manip::internal::RigidBodyTree &iobj_0,
    robotics::manip::internal::CollisionSet &iobj_1, rigidBodyJoint &iobj_2,
    robotics::manip::internal::RigidBody &iobj_3)
  {
    static const char b_cv[14]{ 'b', 'o', 'd', 'y', 'T', 'o', 'o', 'l', 'E', 'E',
      '_', 'j', 'n', 't' };

    static const char b_cv2[8]{ 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };

    static const char b_cv3[8]{ 'f', 'l', 'o', 'a', 't', 'i', 'n', 'g' };

    static const signed char iv2[7]{ 1, 0, 0, 0, 0, 0, 0 };

    static const signed char b_iv[6]{ 0, 0, 1, 0, 0, 0 };

    static const signed char b_iv1[6]{ 0, 0, 0, 0, 0, 1 };

    static const char b_cv1[5]{ 'f', 'i', 'x', 'e', 'd' };

    static const char b_cv4[5]{ 'f', 'i', 'x', 'e', 'd' };

    rigidBody *obj;
    robotics::manip::internal::CharacterVector s;
    robotics::manip::internal::RigidBodyTree *b_default;
    double msubspace_data[36];
    double poslim_data[14];
    int exitg1;
    int homepos_size_idx_1;
    int i;
    int i1;
    int ibmat;
    int poslim_size_idx_0;
    signed char b_I[36];
    signed char c_I[9];
    signed char homepos_data[7];
    bool result;
    obj = this;
    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    iobj_3.NameInternal = s;
    s = iobj_3.NameInternal;
    s.Length = 10.0;
    for (i = 0; i < 10; i++) {
      s.Vector[i] = cv3[i];
    }

    iobj_3.NameInternal = s;
    iobj_2.InTree = false;
    for (i = 0; i < 16; i++) {
      i1 = iv[i];
      iobj_2.JointToParentTransform[i] = i1;
      iobj_2.ChildToJointTransform[i] = i1;
    }

    for (i = 0; i < 14; i++) {
      iobj_2.PositionLimitsInternal[i] = 0.0;
    }

    for (i = 0; i < 7; i++) {
      iobj_2.HomePositionInternal[i] = 0.0;
    }

    for (i = 0; i < 36; i++) {
      iobj_2.MotionSubspaceInternal[i] = 0.0;
    }

    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    iobj_2.NameInternal = s;
    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    iobj_2.TypeInternal = s;
    s = iobj_2.NameInternal;
    s.Length = 14.0;
    for (i = 0; i < 14; i++) {
      s.Vector[i] = b_cv[i];
    }

    iobj_2.NameInternal = s;
    s = iobj_2.TypeInternal;
    s.Length = 5.0;
    for (i = 0; i < 5; i++) {
      s.Vector[i] = b_cv1[i];
    }

    iobj_2.TypeInternal = s;
    s = iobj_2.TypeInternal;
    if (s.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(s.Length);
    }

    result = false;
    if (i == 8) {
      ibmat = 0;
      do {
        exitg1 = 0;
        if (ibmat < 8) {
          if (b_cv2[ibmat] != s.Vector[ibmat]) {
            exitg1 = 1;
          } else {
            ibmat++;
          }
        } else {
          result = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (result) {
      ibmat = 0;
    } else {
      result = false;
      if (i == 9) {
        ibmat = 0;
        do {
          exitg1 = 0;
          if (ibmat < 9) {
            if (cv1[ibmat] != s.Vector[ibmat]) {
              exitg1 = 1;
            } else {
              ibmat++;
            }
          } else {
            result = true;
            exitg1 = 1;
          }
        } while (exitg1 == 0);
      }

      if (result) {
        ibmat = 1;
      } else {
        result = false;
        if (i == 8) {
          ibmat = 0;
          do {
            exitg1 = 0;
            if (ibmat < 8) {
              if (b_cv3[ibmat] != s.Vector[ibmat]) {
                exitg1 = 1;
              } else {
                ibmat++;
              }
            } else {
              result = true;
              exitg1 = 1;
            }
          } while (exitg1 == 0);
        }

        if (result) {
          ibmat = 2;
        } else {
          ibmat = -1;
        }
      }
    }

    switch (ibmat) {
     case 0:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = b_iv[i];
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = -3.1415926535897931;
      poslim_data[1] = 3.1415926535897931;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      iobj_2.VelocityNumber = 1.0;
      iobj_2.PositionNumber = 1.0;
      iobj_2.JointAxisInternal[0] = 0.0;
      iobj_2.JointAxisInternal[1] = 0.0;
      iobj_2.JointAxisInternal[2] = 1.0;
      break;

     case 1:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = b_iv1[i];
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = -0.5;
      poslim_data[1] = 0.5;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      iobj_2.VelocityNumber = 1.0;
      iobj_2.PositionNumber = 1.0;
      iobj_2.JointAxisInternal[0] = 0.0;
      iobj_2.JointAxisInternal[1] = 0.0;
      iobj_2.JointAxisInternal[2] = 1.0;
      break;

     case 2:
      {
        signed char b[6];
        for (i = 0; i < 36; i++) {
          b_I[i] = 0;
        }

        for (ibmat = 0; ibmat < 6; ibmat++) {
          b_I[ibmat + 6 * ibmat] = 1;
        }

        for (i = 0; i < 36; i++) {
          msubspace_data[i] = b_I[i];
        }

        poslim_size_idx_0 = 7;
        for (homepos_size_idx_1 = 0; homepos_size_idx_1 < 2; homepos_size_idx_1
             ++) {
          signed char b_tmp;
          ibmat = homepos_size_idx_1 * 3;
          b_tmp = static_cast<signed char>(10 * homepos_size_idx_1 - 5);
          b[ibmat] = b_tmp;
          b[ibmat + 1] = b_tmp;
          b[ibmat + 2] = b_tmp;
          poslim_data[7 * homepos_size_idx_1] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 1] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 2] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 3] = rtNaN;
        }

        for (i = 0; i < 2; i++) {
          poslim_data[7 * i + 4] = b[3 * i];
          poslim_data[7 * i + 5] = b[3 * i + 1];
          poslim_data[7 * i + 6] = b[3 * i + 2];
        }

        homepos_size_idx_1 = 7;
        for (i = 0; i < 7; i++) {
          homepos_data[i] = iv2[i];
        }

        iobj_2.VelocityNumber = 6.0;
        iobj_2.PositionNumber = 7.0;
        iobj_2.JointAxisInternal[0] = rtNaN;
        iobj_2.JointAxisInternal[1] = rtNaN;
        iobj_2.JointAxisInternal[2] = rtNaN;
      }
      break;

     default:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = 0.0;
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = 0.0;
      poslim_data[1] = 0.0;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      iobj_2.VelocityNumber = 0.0;
      iobj_2.PositionNumber = 0.0;
      iobj_2.JointAxisInternal[0] = 0.0;
      iobj_2.JointAxisInternal[1] = 0.0;
      iobj_2.JointAxisInternal[2] = 0.0;
      break;
    }

    iobj_2.set_MotionSubspace(msubspace_data);
    s = iobj_2.TypeInternal;
    if (s.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(s.Length);
    }

    result = false;
    if (i == 5) {
      ibmat = 0;
      do {
        exitg1 = 0;
        if (ibmat < 5) {
          if (s.Vector[ibmat] != b_cv4[ibmat]) {
            exitg1 = 1;
          } else {
            ibmat++;
          }
        } else {
          result = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (!result) {
      double d;
      d = iobj_2.PositionNumber;
      if (d < 1.0) {
        ibmat = 0;
      } else {
        ibmat = static_cast<int>(d);
      }

      for (i = 0; i < 2; i++) {
        for (i1 = 0; i1 < ibmat; i1++) {
          iobj_2.PositionLimitsInternal[i1 + 7 * i] = poslim_data[i1 +
            poslim_size_idx_0 * i];
        }
      }

      for (i = 0; i < homepos_size_idx_1; i++) {
        iobj_2.HomePositionInternal[i] = homepos_data[i];
      }
    } else {
      iobj_2.PositionLimitsInternal[0] = poslim_data[0];
      iobj_2.PositionLimitsInternal[7] = poslim_data[1];
      iobj_2.HomePositionInternal[0] = homepos_data[0];
    }

    iobj_3.JointInternal = &iobj_2;
    iobj_3.Index = -1.0;
    iobj_3.ParentIndex = -1.0;
    iobj_3.MassInternal = 1.0;
    iobj_3.CenterOfMassInternal[0] = 0.0;
    iobj_3.CenterOfMassInternal[1] = 0.0;
    iobj_3.CenterOfMassInternal[2] = 0.0;
    for (i = 0; i < 9; i++) {
      c_I[i] = 0;
    }

    c_I[0] = 1;
    c_I[4] = 1;
    c_I[8] = 1;
    for (i = 0; i < 9; i++) {
      iobj_3.InertiaInternal[i] = c_I[i];
    }

    for (i = 0; i < 36; i++) {
      b_I[i] = 0;
    }

    for (ibmat = 0; ibmat < 6; ibmat++) {
      b_I[ibmat + 6 * ibmat] = 1;
    }

    for (i = 0; i < 36; i++) {
      iobj_3.SpatialInertia[i] = b_I[i];
    }

    iobj_3.CollisionsInternal = iobj_1.init(static_cast<double>(0.0));
    iobj_3.matlabCodegenIsDeleted = false;
    b_default = iobj_0.init();
    obj->BodyInternal = &iobj_3;
    obj->TreeInternal = b_default;
    obj->matlabCodegenIsDeleted = false;
    return obj;
  }

  //
  // Arguments    : void
  // Return Type  : rigidBodyJoint *
  //
  rigidBodyJoint *rigidBodyJoint::j_init()
  {
    static const char b_cv2[8]{ 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };

    static const char b_cv3[8]{ 'f', 'l', 'o', 'a', 't', 'i', 'n', 'g' };

    static const char b_cv[7]{ 'j', 'n', 't', 'T', 'o', 'o', 'l' };

    static const signed char iv2[7]{ 1, 0, 0, 0, 0, 0, 0 };

    static const signed char b_iv[6]{ 0, 0, 1, 0, 0, 0 };

    static const signed char b_iv1[6]{ 0, 0, 0, 0, 0, 1 };

    static const char b_cv1[5]{ 'f', 'i', 'x', 'e', 'd' };

    static const char b_cv4[5]{ 'f', 'i', 'x', 'e', 'd' };

    rigidBodyJoint *obj;
    robotics::manip::internal::CharacterVector s;
    double msubspace_data[36];
    double poslim_data[14];
    int exitg1;
    int homepos_size_idx_1;
    int i;
    int ibmat;
    int poslim_size_idx_0;
    signed char homepos_data[7];
    signed char b_tmp;
    bool result;
    obj = this;
    obj->InTree = false;
    for (i = 0; i < 16; i++) {
      b_tmp = iv[i];
      obj->JointToParentTransform[i] = b_tmp;
      obj->ChildToJointTransform[i] = b_tmp;
    }

    for (i = 0; i < 14; i++) {
      obj->PositionLimitsInternal[i] = 0.0;
    }

    for (i = 0; i < 7; i++) {
      obj->HomePositionInternal[i] = 0.0;
    }

    for (i = 0; i < 36; i++) {
      obj->MotionSubspaceInternal[i] = 0.0;
    }

    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    obj->NameInternal = s;
    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    obj->TypeInternal = s;
    s = obj->NameInternal;
    s.Length = 7.0;
    for (i = 0; i < 7; i++) {
      s.Vector[i] = b_cv[i];
    }

    obj->NameInternal = s;
    s = obj->TypeInternal;
    s.Length = 5.0;
    for (i = 0; i < 5; i++) {
      s.Vector[i] = b_cv1[i];
    }

    obj->TypeInternal = s;
    s = obj->TypeInternal;
    if (s.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(s.Length);
    }

    result = false;
    if (i == 8) {
      ibmat = 0;
      do {
        exitg1 = 0;
        if (ibmat < 8) {
          if (b_cv2[ibmat] != s.Vector[ibmat]) {
            exitg1 = 1;
          } else {
            ibmat++;
          }
        } else {
          result = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (result) {
      ibmat = 0;
    } else {
      result = false;
      if (i == 9) {
        ibmat = 0;
        do {
          exitg1 = 0;
          if (ibmat < 9) {
            if (cv1[ibmat] != s.Vector[ibmat]) {
              exitg1 = 1;
            } else {
              ibmat++;
            }
          } else {
            result = true;
            exitg1 = 1;
          }
        } while (exitg1 == 0);
      }

      if (result) {
        ibmat = 1;
      } else {
        result = false;
        if (i == 8) {
          ibmat = 0;
          do {
            exitg1 = 0;
            if (ibmat < 8) {
              if (b_cv3[ibmat] != s.Vector[ibmat]) {
                exitg1 = 1;
              } else {
                ibmat++;
              }
            } else {
              result = true;
              exitg1 = 1;
            }
          } while (exitg1 == 0);
        }

        if (result) {
          ibmat = 2;
        } else {
          ibmat = -1;
        }
      }
    }

    switch (ibmat) {
     case 0:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = b_iv[i];
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = -3.1415926535897931;
      poslim_data[1] = 3.1415926535897931;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      obj->VelocityNumber = 1.0;
      obj->PositionNumber = 1.0;
      obj->JointAxisInternal[0] = 0.0;
      obj->JointAxisInternal[1] = 0.0;
      obj->JointAxisInternal[2] = 1.0;
      break;

     case 1:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = b_iv1[i];
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = -0.5;
      poslim_data[1] = 0.5;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      obj->VelocityNumber = 1.0;
      obj->PositionNumber = 1.0;
      obj->JointAxisInternal[0] = 0.0;
      obj->JointAxisInternal[1] = 0.0;
      obj->JointAxisInternal[2] = 1.0;
      break;

     case 2:
      {
        signed char b_I[36];
        signed char b[6];
        for (i = 0; i < 36; i++) {
          b_I[i] = 0;
        }

        for (ibmat = 0; ibmat < 6; ibmat++) {
          b_I[ibmat + 6 * ibmat] = 1;
        }

        for (i = 0; i < 36; i++) {
          msubspace_data[i] = b_I[i];
        }

        poslim_size_idx_0 = 7;
        for (homepos_size_idx_1 = 0; homepos_size_idx_1 < 2; homepos_size_idx_1
             ++) {
          ibmat = homepos_size_idx_1 * 3;
          b_tmp = static_cast<signed char>(10 * homepos_size_idx_1 - 5);
          b[ibmat] = b_tmp;
          b[ibmat + 1] = b_tmp;
          b[ibmat + 2] = b_tmp;
          poslim_data[7 * homepos_size_idx_1] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 1] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 2] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 3] = rtNaN;
        }

        for (i = 0; i < 2; i++) {
          poslim_data[7 * i + 4] = b[3 * i];
          poslim_data[7 * i + 5] = b[3 * i + 1];
          poslim_data[7 * i + 6] = b[3 * i + 2];
        }

        homepos_size_idx_1 = 7;
        for (i = 0; i < 7; i++) {
          homepos_data[i] = iv2[i];
        }

        obj->VelocityNumber = 6.0;
        obj->PositionNumber = 7.0;
        obj->JointAxisInternal[0] = rtNaN;
        obj->JointAxisInternal[1] = rtNaN;
        obj->JointAxisInternal[2] = rtNaN;
      }
      break;

     default:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = 0.0;
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = 0.0;
      poslim_data[1] = 0.0;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      obj->VelocityNumber = 0.0;
      obj->PositionNumber = 0.0;
      obj->JointAxisInternal[0] = 0.0;
      obj->JointAxisInternal[1] = 0.0;
      obj->JointAxisInternal[2] = 0.0;
      break;
    }

    obj->set_MotionSubspace(msubspace_data);
    s = obj->TypeInternal;
    if (s.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(s.Length);
    }

    result = false;
    if (i == 5) {
      ibmat = 0;
      do {
        exitg1 = 0;
        if (ibmat < 5) {
          if (s.Vector[ibmat] != b_cv4[ibmat]) {
            exitg1 = 1;
          } else {
            ibmat++;
          }
        } else {
          result = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (!result) {
      double d;
      d = obj->PositionNumber;
      if (d < 1.0) {
        ibmat = 0;
      } else {
        ibmat = static_cast<int>(d);
      }

      for (i = 0; i < 2; i++) {
        for (int i1{0}; i1 < ibmat; i1++) {
          obj->PositionLimitsInternal[i1 + 7 * i] = poslim_data[i1 +
            poslim_size_idx_0 * i];
        }
      }

      for (i = 0; i < homepos_size_idx_1; i++) {
        obj->HomePositionInternal[i] = homepos_data[i];
      }
    } else {
      obj->PositionLimitsInternal[0] = poslim_data[0];
      obj->PositionLimitsInternal[7] = poslim_data[1];
      obj->HomePositionInternal[0] = homepos_data[0];
    }

    return obj;
  }

  //
  // Arguments    : robotics::manip::internal::RigidBodyTree &iobj_0
  //                robotics::manip::internal::CollisionSet &iobj_1
  //                rigidBodyJoint &iobj_2
  //                robotics::manip::internal::RigidBody &iobj_3
  // Return Type  : rigidBody *
  //
  rigidBody *rigidBody::k_init(robotics::manip::internal::RigidBodyTree &iobj_0,
    robotics::manip::internal::CollisionSet &iobj_1, rigidBodyJoint &iobj_2,
    robotics::manip::internal::RigidBody &iobj_3)
  {
    static const char b_cv[13]{ 't', 'a', 'r', 'g', 'e', 't', 'F', 'i', 'n', '_',
      'j', 'n', 't' };

    static const char b_cv2[8]{ 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };

    static const char b_cv3[8]{ 'f', 'l', 'o', 'a', 't', 'i', 'n', 'g' };

    static const signed char iv2[7]{ 1, 0, 0, 0, 0, 0, 0 };

    static const signed char b_iv[6]{ 0, 0, 1, 0, 0, 0 };

    static const signed char b_iv1[6]{ 0, 0, 0, 0, 0, 1 };

    static const char b_cv1[5]{ 'f', 'i', 'x', 'e', 'd' };

    static const char b_cv4[5]{ 'f', 'i', 'x', 'e', 'd' };

    rigidBody *obj;
    robotics::manip::internal::CharacterVector s;
    robotics::manip::internal::RigidBodyTree *b_default;
    double msubspace_data[36];
    double poslim_data[14];
    int exitg1;
    int homepos_size_idx_1;
    int i;
    int i1;
    int ibmat;
    int poslim_size_idx_0;
    signed char b_I[36];
    signed char c_I[9];
    signed char homepos_data[7];
    bool result;
    obj = this;
    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    iobj_3.NameInternal = s;
    s = iobj_3.NameInternal;
    s.Length = 9.0;
    for (i = 0; i < 9; i++) {
      s.Vector[i] = cv4[i];
    }

    iobj_3.NameInternal = s;
    iobj_2.InTree = false;
    for (i = 0; i < 16; i++) {
      i1 = iv[i];
      iobj_2.JointToParentTransform[i] = i1;
      iobj_2.ChildToJointTransform[i] = i1;
    }

    for (i = 0; i < 14; i++) {
      iobj_2.PositionLimitsInternal[i] = 0.0;
    }

    for (i = 0; i < 7; i++) {
      iobj_2.HomePositionInternal[i] = 0.0;
    }

    for (i = 0; i < 36; i++) {
      iobj_2.MotionSubspaceInternal[i] = 0.0;
    }

    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    iobj_2.NameInternal = s;
    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    iobj_2.TypeInternal = s;
    s = iobj_2.NameInternal;
    s.Length = 13.0;
    for (i = 0; i < 13; i++) {
      s.Vector[i] = b_cv[i];
    }

    iobj_2.NameInternal = s;
    s = iobj_2.TypeInternal;
    s.Length = 5.0;
    for (i = 0; i < 5; i++) {
      s.Vector[i] = b_cv1[i];
    }

    iobj_2.TypeInternal = s;
    s = iobj_2.TypeInternal;
    if (s.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(s.Length);
    }

    result = false;
    if (i == 8) {
      ibmat = 0;
      do {
        exitg1 = 0;
        if (ibmat < 8) {
          if (b_cv2[ibmat] != s.Vector[ibmat]) {
            exitg1 = 1;
          } else {
            ibmat++;
          }
        } else {
          result = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (result) {
      ibmat = 0;
    } else {
      result = false;
      if (i == 9) {
        ibmat = 0;
        do {
          exitg1 = 0;
          if (ibmat < 9) {
            if (cv1[ibmat] != s.Vector[ibmat]) {
              exitg1 = 1;
            } else {
              ibmat++;
            }
          } else {
            result = true;
            exitg1 = 1;
          }
        } while (exitg1 == 0);
      }

      if (result) {
        ibmat = 1;
      } else {
        result = false;
        if (i == 8) {
          ibmat = 0;
          do {
            exitg1 = 0;
            if (ibmat < 8) {
              if (b_cv3[ibmat] != s.Vector[ibmat]) {
                exitg1 = 1;
              } else {
                ibmat++;
              }
            } else {
              result = true;
              exitg1 = 1;
            }
          } while (exitg1 == 0);
        }

        if (result) {
          ibmat = 2;
        } else {
          ibmat = -1;
        }
      }
    }

    switch (ibmat) {
     case 0:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = b_iv[i];
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = -3.1415926535897931;
      poslim_data[1] = 3.1415926535897931;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      iobj_2.VelocityNumber = 1.0;
      iobj_2.PositionNumber = 1.0;
      iobj_2.JointAxisInternal[0] = 0.0;
      iobj_2.JointAxisInternal[1] = 0.0;
      iobj_2.JointAxisInternal[2] = 1.0;
      break;

     case 1:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = b_iv1[i];
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = -0.5;
      poslim_data[1] = 0.5;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      iobj_2.VelocityNumber = 1.0;
      iobj_2.PositionNumber = 1.0;
      iobj_2.JointAxisInternal[0] = 0.0;
      iobj_2.JointAxisInternal[1] = 0.0;
      iobj_2.JointAxisInternal[2] = 1.0;
      break;

     case 2:
      {
        signed char b[6];
        for (i = 0; i < 36; i++) {
          b_I[i] = 0;
        }

        for (ibmat = 0; ibmat < 6; ibmat++) {
          b_I[ibmat + 6 * ibmat] = 1;
        }

        for (i = 0; i < 36; i++) {
          msubspace_data[i] = b_I[i];
        }

        poslim_size_idx_0 = 7;
        for (homepos_size_idx_1 = 0; homepos_size_idx_1 < 2; homepos_size_idx_1
             ++) {
          signed char b_tmp;
          ibmat = homepos_size_idx_1 * 3;
          b_tmp = static_cast<signed char>(10 * homepos_size_idx_1 - 5);
          b[ibmat] = b_tmp;
          b[ibmat + 1] = b_tmp;
          b[ibmat + 2] = b_tmp;
          poslim_data[7 * homepos_size_idx_1] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 1] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 2] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 3] = rtNaN;
        }

        for (i = 0; i < 2; i++) {
          poslim_data[7 * i + 4] = b[3 * i];
          poslim_data[7 * i + 5] = b[3 * i + 1];
          poslim_data[7 * i + 6] = b[3 * i + 2];
        }

        homepos_size_idx_1 = 7;
        for (i = 0; i < 7; i++) {
          homepos_data[i] = iv2[i];
        }

        iobj_2.VelocityNumber = 6.0;
        iobj_2.PositionNumber = 7.0;
        iobj_2.JointAxisInternal[0] = rtNaN;
        iobj_2.JointAxisInternal[1] = rtNaN;
        iobj_2.JointAxisInternal[2] = rtNaN;
      }
      break;

     default:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = 0.0;
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = 0.0;
      poslim_data[1] = 0.0;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      iobj_2.VelocityNumber = 0.0;
      iobj_2.PositionNumber = 0.0;
      iobj_2.JointAxisInternal[0] = 0.0;
      iobj_2.JointAxisInternal[1] = 0.0;
      iobj_2.JointAxisInternal[2] = 0.0;
      break;
    }

    iobj_2.set_MotionSubspace(msubspace_data);
    s = iobj_2.TypeInternal;
    if (s.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(s.Length);
    }

    result = false;
    if (i == 5) {
      ibmat = 0;
      do {
        exitg1 = 0;
        if (ibmat < 5) {
          if (s.Vector[ibmat] != b_cv4[ibmat]) {
            exitg1 = 1;
          } else {
            ibmat++;
          }
        } else {
          result = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (!result) {
      double d;
      d = iobj_2.PositionNumber;
      if (d < 1.0) {
        ibmat = 0;
      } else {
        ibmat = static_cast<int>(d);
      }

      for (i = 0; i < 2; i++) {
        for (i1 = 0; i1 < ibmat; i1++) {
          iobj_2.PositionLimitsInternal[i1 + 7 * i] = poslim_data[i1 +
            poslim_size_idx_0 * i];
        }
      }

      for (i = 0; i < homepos_size_idx_1; i++) {
        iobj_2.HomePositionInternal[i] = homepos_data[i];
      }
    } else {
      iobj_2.PositionLimitsInternal[0] = poslim_data[0];
      iobj_2.PositionLimitsInternal[7] = poslim_data[1];
      iobj_2.HomePositionInternal[0] = homepos_data[0];
    }

    iobj_3.JointInternal = &iobj_2;
    iobj_3.Index = -1.0;
    iobj_3.ParentIndex = -1.0;
    iobj_3.MassInternal = 1.0;
    iobj_3.CenterOfMassInternal[0] = 0.0;
    iobj_3.CenterOfMassInternal[1] = 0.0;
    iobj_3.CenterOfMassInternal[2] = 0.0;
    for (i = 0; i < 9; i++) {
      c_I[i] = 0;
    }

    c_I[0] = 1;
    c_I[4] = 1;
    c_I[8] = 1;
    for (i = 0; i < 9; i++) {
      iobj_3.InertiaInternal[i] = c_I[i];
    }

    for (i = 0; i < 36; i++) {
      b_I[i] = 0;
    }

    for (ibmat = 0; ibmat < 6; ibmat++) {
      b_I[ibmat + 6 * ibmat] = 1;
    }

    for (i = 0; i < 36; i++) {
      iobj_3.SpatialInertia[i] = b_I[i];
    }

    iobj_3.CollisionsInternal = iobj_1.init(static_cast<double>(0.0));
    iobj_3.matlabCodegenIsDeleted = false;
    b_default = iobj_0.init();
    obj->BodyInternal = &iobj_3;
    obj->TreeInternal = b_default;
    obj->matlabCodegenIsDeleted = false;
    return obj;
  }

  //
  // Arguments    : void
  // Return Type  : rigidBodyJoint *
  //
  rigidBodyJoint *rigidBodyJoint::k_init()
  {
    static const char b_cv[9]{ 'j', 'n', 't', 'T', 'o', 'o', 'l', 'E', 'E' };

    static const char b_cv2[8]{ 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };

    static const char b_cv3[8]{ 'f', 'l', 'o', 'a', 't', 'i', 'n', 'g' };

    static const signed char iv2[7]{ 1, 0, 0, 0, 0, 0, 0 };

    static const signed char b_iv[6]{ 0, 0, 1, 0, 0, 0 };

    static const signed char b_iv1[6]{ 0, 0, 0, 0, 0, 1 };

    static const char b_cv1[5]{ 'f', 'i', 'x', 'e', 'd' };

    static const char b_cv4[5]{ 'f', 'i', 'x', 'e', 'd' };

    rigidBodyJoint *obj;
    robotics::manip::internal::CharacterVector s;
    double msubspace_data[36];
    double poslim_data[14];
    int exitg1;
    int homepos_size_idx_1;
    int i;
    int ibmat;
    int poslim_size_idx_0;
    signed char homepos_data[7];
    signed char b_tmp;
    bool result;
    obj = this;
    obj->InTree = false;
    for (i = 0; i < 16; i++) {
      b_tmp = iv[i];
      obj->JointToParentTransform[i] = b_tmp;
      obj->ChildToJointTransform[i] = b_tmp;
    }

    for (i = 0; i < 14; i++) {
      obj->PositionLimitsInternal[i] = 0.0;
    }

    for (i = 0; i < 7; i++) {
      obj->HomePositionInternal[i] = 0.0;
    }

    for (i = 0; i < 36; i++) {
      obj->MotionSubspaceInternal[i] = 0.0;
    }

    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    obj->NameInternal = s;
    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    obj->TypeInternal = s;
    s = obj->NameInternal;
    s.Length = 9.0;
    for (i = 0; i < 9; i++) {
      s.Vector[i] = b_cv[i];
    }

    obj->NameInternal = s;
    s = obj->TypeInternal;
    s.Length = 5.0;
    for (i = 0; i < 5; i++) {
      s.Vector[i] = b_cv1[i];
    }

    obj->TypeInternal = s;
    s = obj->TypeInternal;
    if (s.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(s.Length);
    }

    result = false;
    if (i == 8) {
      ibmat = 0;
      do {
        exitg1 = 0;
        if (ibmat < 8) {
          if (b_cv2[ibmat] != s.Vector[ibmat]) {
            exitg1 = 1;
          } else {
            ibmat++;
          }
        } else {
          result = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (result) {
      ibmat = 0;
    } else {
      result = false;
      if (i == 9) {
        ibmat = 0;
        do {
          exitg1 = 0;
          if (ibmat < 9) {
            if (cv1[ibmat] != s.Vector[ibmat]) {
              exitg1 = 1;
            } else {
              ibmat++;
            }
          } else {
            result = true;
            exitg1 = 1;
          }
        } while (exitg1 == 0);
      }

      if (result) {
        ibmat = 1;
      } else {
        result = false;
        if (i == 8) {
          ibmat = 0;
          do {
            exitg1 = 0;
            if (ibmat < 8) {
              if (b_cv3[ibmat] != s.Vector[ibmat]) {
                exitg1 = 1;
              } else {
                ibmat++;
              }
            } else {
              result = true;
              exitg1 = 1;
            }
          } while (exitg1 == 0);
        }

        if (result) {
          ibmat = 2;
        } else {
          ibmat = -1;
        }
      }
    }

    switch (ibmat) {
     case 0:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = b_iv[i];
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = -3.1415926535897931;
      poslim_data[1] = 3.1415926535897931;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      obj->VelocityNumber = 1.0;
      obj->PositionNumber = 1.0;
      obj->JointAxisInternal[0] = 0.0;
      obj->JointAxisInternal[1] = 0.0;
      obj->JointAxisInternal[2] = 1.0;
      break;

     case 1:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = b_iv1[i];
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = -0.5;
      poslim_data[1] = 0.5;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      obj->VelocityNumber = 1.0;
      obj->PositionNumber = 1.0;
      obj->JointAxisInternal[0] = 0.0;
      obj->JointAxisInternal[1] = 0.0;
      obj->JointAxisInternal[2] = 1.0;
      break;

     case 2:
      {
        signed char b_I[36];
        signed char b[6];
        for (i = 0; i < 36; i++) {
          b_I[i] = 0;
        }

        for (ibmat = 0; ibmat < 6; ibmat++) {
          b_I[ibmat + 6 * ibmat] = 1;
        }

        for (i = 0; i < 36; i++) {
          msubspace_data[i] = b_I[i];
        }

        poslim_size_idx_0 = 7;
        for (homepos_size_idx_1 = 0; homepos_size_idx_1 < 2; homepos_size_idx_1
             ++) {
          ibmat = homepos_size_idx_1 * 3;
          b_tmp = static_cast<signed char>(10 * homepos_size_idx_1 - 5);
          b[ibmat] = b_tmp;
          b[ibmat + 1] = b_tmp;
          b[ibmat + 2] = b_tmp;
          poslim_data[7 * homepos_size_idx_1] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 1] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 2] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 3] = rtNaN;
        }

        for (i = 0; i < 2; i++) {
          poslim_data[7 * i + 4] = b[3 * i];
          poslim_data[7 * i + 5] = b[3 * i + 1];
          poslim_data[7 * i + 6] = b[3 * i + 2];
        }

        homepos_size_idx_1 = 7;
        for (i = 0; i < 7; i++) {
          homepos_data[i] = iv2[i];
        }

        obj->VelocityNumber = 6.0;
        obj->PositionNumber = 7.0;
        obj->JointAxisInternal[0] = rtNaN;
        obj->JointAxisInternal[1] = rtNaN;
        obj->JointAxisInternal[2] = rtNaN;
      }
      break;

     default:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = 0.0;
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = 0.0;
      poslim_data[1] = 0.0;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      obj->VelocityNumber = 0.0;
      obj->PositionNumber = 0.0;
      obj->JointAxisInternal[0] = 0.0;
      obj->JointAxisInternal[1] = 0.0;
      obj->JointAxisInternal[2] = 0.0;
      break;
    }

    obj->set_MotionSubspace(msubspace_data);
    s = obj->TypeInternal;
    if (s.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(s.Length);
    }

    result = false;
    if (i == 5) {
      ibmat = 0;
      do {
        exitg1 = 0;
        if (ibmat < 5) {
          if (s.Vector[ibmat] != b_cv4[ibmat]) {
            exitg1 = 1;
          } else {
            ibmat++;
          }
        } else {
          result = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (!result) {
      double d;
      d = obj->PositionNumber;
      if (d < 1.0) {
        ibmat = 0;
      } else {
        ibmat = static_cast<int>(d);
      }

      for (i = 0; i < 2; i++) {
        for (int i1{0}; i1 < ibmat; i1++) {
          obj->PositionLimitsInternal[i1 + 7 * i] = poslim_data[i1 +
            poslim_size_idx_0 * i];
        }
      }

      for (i = 0; i < homepos_size_idx_1; i++) {
        obj->HomePositionInternal[i] = homepos_data[i];
      }
    } else {
      obj->PositionLimitsInternal[0] = poslim_data[0];
      obj->PositionLimitsInternal[7] = poslim_data[1];
      obj->HomePositionInternal[0] = homepos_data[0];
    }

    return obj;
  }

  //
  // Arguments    : robotics::manip::internal::RigidBodyTree &iobj_0
  //                robotics::manip::internal::CollisionSet &iobj_1
  //                rigidBodyJoint &iobj_2
  //                robotics::manip::internal::RigidBody &iobj_3
  // Return Type  : rigidBody *
  //
  rigidBody *rigidBody::l_init(robotics::manip::internal::RigidBodyTree &iobj_0,
    robotics::manip::internal::CollisionSet &iobj_1, rigidBodyJoint &iobj_2,
    robotics::manip::internal::RigidBody &iobj_3)
  {
    static const char b_cv[13]{ 't', 'a', 'r', 'g', 'e', 't', 'A', 'p', 'r', '_',
      'j', 'n', 't' };

    static const char b_cv2[8]{ 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };

    static const char b_cv3[8]{ 'f', 'l', 'o', 'a', 't', 'i', 'n', 'g' };

    static const signed char iv2[7]{ 1, 0, 0, 0, 0, 0, 0 };

    static const signed char b_iv[6]{ 0, 0, 1, 0, 0, 0 };

    static const signed char b_iv1[6]{ 0, 0, 0, 0, 0, 1 };

    static const char b_cv1[5]{ 'f', 'i', 'x', 'e', 'd' };

    static const char b_cv4[5]{ 'f', 'i', 'x', 'e', 'd' };

    rigidBody *obj;
    robotics::manip::internal::CharacterVector s;
    robotics::manip::internal::RigidBodyTree *b_default;
    double msubspace_data[36];
    double poslim_data[14];
    int exitg1;
    int homepos_size_idx_1;
    int i;
    int i1;
    int ibmat;
    int poslim_size_idx_0;
    signed char b_I[36];
    signed char c_I[9];
    signed char homepos_data[7];
    bool result;
    obj = this;
    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    iobj_3.NameInternal = s;
    s = iobj_3.NameInternal;
    s.Length = 9.0;
    for (i = 0; i < 9; i++) {
      s.Vector[i] = cv5[i];
    }

    iobj_3.NameInternal = s;
    iobj_2.InTree = false;
    for (i = 0; i < 16; i++) {
      i1 = iv[i];
      iobj_2.JointToParentTransform[i] = i1;
      iobj_2.ChildToJointTransform[i] = i1;
    }

    for (i = 0; i < 14; i++) {
      iobj_2.PositionLimitsInternal[i] = 0.0;
    }

    for (i = 0; i < 7; i++) {
      iobj_2.HomePositionInternal[i] = 0.0;
    }

    for (i = 0; i < 36; i++) {
      iobj_2.MotionSubspaceInternal[i] = 0.0;
    }

    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    iobj_2.NameInternal = s;
    s.Length = 200.0;
    for (i = 0; i < 200; i++) {
      s.Vector[i] = ' ';
    }

    iobj_2.TypeInternal = s;
    s = iobj_2.NameInternal;
    s.Length = 13.0;
    for (i = 0; i < 13; i++) {
      s.Vector[i] = b_cv[i];
    }

    iobj_2.NameInternal = s;
    s = iobj_2.TypeInternal;
    s.Length = 5.0;
    for (i = 0; i < 5; i++) {
      s.Vector[i] = b_cv1[i];
    }

    iobj_2.TypeInternal = s;
    s = iobj_2.TypeInternal;
    if (s.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(s.Length);
    }

    result = false;
    if (i == 8) {
      ibmat = 0;
      do {
        exitg1 = 0;
        if (ibmat < 8) {
          if (b_cv2[ibmat] != s.Vector[ibmat]) {
            exitg1 = 1;
          } else {
            ibmat++;
          }
        } else {
          result = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (result) {
      ibmat = 0;
    } else {
      result = false;
      if (i == 9) {
        ibmat = 0;
        do {
          exitg1 = 0;
          if (ibmat < 9) {
            if (cv1[ibmat] != s.Vector[ibmat]) {
              exitg1 = 1;
            } else {
              ibmat++;
            }
          } else {
            result = true;
            exitg1 = 1;
          }
        } while (exitg1 == 0);
      }

      if (result) {
        ibmat = 1;
      } else {
        result = false;
        if (i == 8) {
          ibmat = 0;
          do {
            exitg1 = 0;
            if (ibmat < 8) {
              if (b_cv3[ibmat] != s.Vector[ibmat]) {
                exitg1 = 1;
              } else {
                ibmat++;
              }
            } else {
              result = true;
              exitg1 = 1;
            }
          } while (exitg1 == 0);
        }

        if (result) {
          ibmat = 2;
        } else {
          ibmat = -1;
        }
      }
    }

    switch (ibmat) {
     case 0:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = b_iv[i];
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = -3.1415926535897931;
      poslim_data[1] = 3.1415926535897931;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      iobj_2.VelocityNumber = 1.0;
      iobj_2.PositionNumber = 1.0;
      iobj_2.JointAxisInternal[0] = 0.0;
      iobj_2.JointAxisInternal[1] = 0.0;
      iobj_2.JointAxisInternal[2] = 1.0;
      break;

     case 1:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = b_iv1[i];
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = -0.5;
      poslim_data[1] = 0.5;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      iobj_2.VelocityNumber = 1.0;
      iobj_2.PositionNumber = 1.0;
      iobj_2.JointAxisInternal[0] = 0.0;
      iobj_2.JointAxisInternal[1] = 0.0;
      iobj_2.JointAxisInternal[2] = 1.0;
      break;

     case 2:
      {
        signed char b[6];
        for (i = 0; i < 36; i++) {
          b_I[i] = 0;
        }

        for (ibmat = 0; ibmat < 6; ibmat++) {
          b_I[ibmat + 6 * ibmat] = 1;
        }

        for (i = 0; i < 36; i++) {
          msubspace_data[i] = b_I[i];
        }

        poslim_size_idx_0 = 7;
        for (homepos_size_idx_1 = 0; homepos_size_idx_1 < 2; homepos_size_idx_1
             ++) {
          signed char b_tmp;
          ibmat = homepos_size_idx_1 * 3;
          b_tmp = static_cast<signed char>(10 * homepos_size_idx_1 - 5);
          b[ibmat] = b_tmp;
          b[ibmat + 1] = b_tmp;
          b[ibmat + 2] = b_tmp;
          poslim_data[7 * homepos_size_idx_1] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 1] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 2] = rtNaN;
          poslim_data[7 * homepos_size_idx_1 + 3] = rtNaN;
        }

        for (i = 0; i < 2; i++) {
          poslim_data[7 * i + 4] = b[3 * i];
          poslim_data[7 * i + 5] = b[3 * i + 1];
          poslim_data[7 * i + 6] = b[3 * i + 2];
        }

        homepos_size_idx_1 = 7;
        for (i = 0; i < 7; i++) {
          homepos_data[i] = iv2[i];
        }

        iobj_2.VelocityNumber = 6.0;
        iobj_2.PositionNumber = 7.0;
        iobj_2.JointAxisInternal[0] = rtNaN;
        iobj_2.JointAxisInternal[1] = rtNaN;
        iobj_2.JointAxisInternal[2] = rtNaN;
      }
      break;

     default:
      for (i = 0; i < 6; i++) {
        msubspace_data[i] = 0.0;
      }

      poslim_size_idx_0 = 1;
      poslim_data[0] = 0.0;
      poslim_data[1] = 0.0;
      homepos_size_idx_1 = 1;
      homepos_data[0] = 0;
      iobj_2.VelocityNumber = 0.0;
      iobj_2.PositionNumber = 0.0;
      iobj_2.JointAxisInternal[0] = 0.0;
      iobj_2.JointAxisInternal[1] = 0.0;
      iobj_2.JointAxisInternal[2] = 0.0;
      break;
    }

    iobj_2.set_MotionSubspace(msubspace_data);
    s = iobj_2.TypeInternal;
    if (s.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(s.Length);
    }

    result = false;
    if (i == 5) {
      ibmat = 0;
      do {
        exitg1 = 0;
        if (ibmat < 5) {
          if (s.Vector[ibmat] != b_cv4[ibmat]) {
            exitg1 = 1;
          } else {
            ibmat++;
          }
        } else {
          result = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (!result) {
      double d;
      d = iobj_2.PositionNumber;
      if (d < 1.0) {
        ibmat = 0;
      } else {
        ibmat = static_cast<int>(d);
      }

      for (i = 0; i < 2; i++) {
        for (i1 = 0; i1 < ibmat; i1++) {
          iobj_2.PositionLimitsInternal[i1 + 7 * i] = poslim_data[i1 +
            poslim_size_idx_0 * i];
        }
      }

      for (i = 0; i < homepos_size_idx_1; i++) {
        iobj_2.HomePositionInternal[i] = homepos_data[i];
      }
    } else {
      iobj_2.PositionLimitsInternal[0] = poslim_data[0];
      iobj_2.PositionLimitsInternal[7] = poslim_data[1];
      iobj_2.HomePositionInternal[0] = homepos_data[0];
    }

    iobj_3.JointInternal = &iobj_2;
    iobj_3.Index = -1.0;
    iobj_3.ParentIndex = -1.0;
    iobj_3.MassInternal = 1.0;
    iobj_3.CenterOfMassInternal[0] = 0.0;
    iobj_3.CenterOfMassInternal[1] = 0.0;
    iobj_3.CenterOfMassInternal[2] = 0.0;
    for (i = 0; i < 9; i++) {
      c_I[i] = 0;
    }

    c_I[0] = 1;
    c_I[4] = 1;
    c_I[8] = 1;
    for (i = 0; i < 9; i++) {
      iobj_3.InertiaInternal[i] = c_I[i];
    }

    for (i = 0; i < 36; i++) {
      b_I[i] = 0;
    }

    for (ibmat = 0; ibmat < 6; ibmat++) {
      b_I[ibmat + 6 * ibmat] = 1;
    }

    for (i = 0; i < 36; i++) {
      iobj_3.SpatialInertia[i] = b_I[i];
    }

    iobj_3.CollisionsInternal = iobj_1.init(static_cast<double>(0.0));
    iobj_3.matlabCodegenIsDeleted = false;
    b_default = iobj_0.init();
    obj->BodyInternal = &iobj_3;
    obj->TreeInternal = b_default;
    obj->matlabCodegenIsDeleted = false;
    return obj;
  }

  //
  // Arguments    : void
  // Return Type  : void
  //
  void collisionCapsule::matlabCodegenDestructor()
  {
    void *geometryInternal;
    if (!matlabCodegenIsDeleted) {
      matlabCodegenIsDeleted = true;
      geometryInternal = GeometryInternal;
      collisioncodegen_destructGeometry(&geometryInternal);
    }
  }

  //
  // Arguments    : void
  // Return Type  : void
  //
  void rigidBodyTree::matlabCodegenDestructor()
  {
    if (!matlabCodegenIsDeleted) {
      matlabCodegenIsDeleted = true;
    }
  }

  //
  // Arguments    : void
  // Return Type  : void
  //
  void generalizedInverseKinematics::matlabCodegenDestructor()
  {
    if (!matlabCodegenIsDeleted) {
      matlabCodegenIsDeleted = true;
      if (isInitialized == 1) {
        isInitialized = 2;
      }
    }
  }

  //
  // Arguments    : void
  // Return Type  : void
  //
  void rigidBody::matlabCodegenDestructor()
  {
    if (!matlabCodegenIsDeleted) {
      matlabCodegenIsDeleted = true;
    }
  }

  //
  // Arguments    : robotics::manip::internal::GIKProblem *problem
  //                array<double, 1U> &rc
  // Return Type  : void
  //
  void rigidBodyJoint::randomConfig(robotics::manip::internal::GIKProblem
    *problem, array<double, 1U> &rc)
  {
    static const char b_cv[5]{ 'f', 'i', 'x', 'e', 'd' };

    rigidBodyJoint *b_obj;
    robotics::manip::internal::b_RigidBodyTree *obj;
    array<double, 2U> r;
    array<double, 1U> r1;
    array<double, 1U> x;
    array<double, 1U> y;
    array<bool, 1U> b_x;
    double qr_data[84];
    double qi_data[49];
    double n;
    double p_idx_0;
    double posnum;
    int bounds_size[2];
    int i;
    int i1;
    int i2;
    int kstr;
    int loop_ub_tmp;
    obj = problem->Tree;
    posnum = obj->PositionNumber;
    loop_ub_tmp = static_cast<int>(posnum);
    if (loop_ub_tmp - 1 >= 0) {
      std::memset(&qr_data[0], 0, static_cast<unsigned int>(loop_ub_tmp) *
                  sizeof(double));
    }

    n = obj->NumBodies;
    i = static_cast<int>(n);
    for (int b_i{0}; b_i < i; b_i++) {
      double p_idx_1;
      p_idx_0 = obj->PositionDoFMap[b_i];
      p_idx_1 = obj->PositionDoFMap[b_i + 12];
      if (p_idx_0 <= p_idx_1) {
        robotics::manip::internal::CharacterVector c_obj;
        signed char unnamed_idx_1;
        bool b_bool;
        b_obj = obj->Bodies[b_i]->JointInternal;
        c_obj = b_obj->TypeInternal;
        if (c_obj.Length < 1.0) {
          i1 = 0;
        } else {
          i1 = static_cast<int>(c_obj.Length);
        }

        b_bool = false;
        if (i1 == 5) {
          kstr = 0;
          int exitg1;
          do {
            exitg1 = 0;
            if (kstr < 5) {
              if (c_obj.Vector[kstr] != b_cv[kstr]) {
                exitg1 = 1;
              } else {
                kstr++;
              }
            } else {
              b_bool = true;
              exitg1 = 1;
            }
          } while (exitg1 == 0);
        }

        if (!b_bool) {
          n = b_obj->PositionNumber;
          if (n < 1.0) {
            unnamed_idx_1 = 0;
          } else {
            unnamed_idx_1 = static_cast<signed char>(static_cast<int>(n));
          }
        } else {
          unnamed_idx_1 = 1;
        }

        kstr = unnamed_idx_1;
        if (kstr - 1 >= 0) {
          std::memset(&qi_data[0], 0, static_cast<unsigned int>(kstr) * sizeof
                      (double));
        }

        switch (static_cast<int>(b_obj->PositionNumber)) {
         case 0:
          qi_data[0] = rtNaN;
          break;

         case 7:
          {
            double translbounds[6];
            double b_r[4];
            double rn[3];
            int k;
            bool x_data[12];
            bool b_b[3];
            bool bv[3];
            bool c_b[3];
            bool b;
            bool exitg2;
            bool guard1;
            bool guard2;
            bool guard3;
            randn(b_r);
            n = std::sqrt(((b_r[0] * b_r[0] + b_r[1] * b_r[1]) + b_r[2] * b_r[2])
                          + b_r[3] * b_r[3]);
            qi_data[0] = b_r[0] / n;
            qi_data[1] = b_r[1] / n;
            qi_data[2] = b_r[2] / n;
            qi_data[3] = b_r[3] / n;
            for (i1 = 0; i1 < 2; i1++) {
              translbounds[3 * i1] = b_obj->PositionLimitsInternal[7 * i1 + 4];
              translbounds[3 * i1 + 1] = b_obj->PositionLimitsInternal[7 * i1 +
                5];
              translbounds[3 * i1 + 2] = b_obj->PositionLimitsInternal[7 * i1 +
                6];
            }

            if (unnamed_idx_1 < 5) {
              i1 = 0;
              i2 = 0;
            } else {
              i1 = 4;
              i2 = unnamed_idx_1;
            }

            bv[0] = ((!std::isinf(translbounds[0])) && (!std::isnan
                      (translbounds[0])));
            bv[1] = ((!std::isinf(translbounds[1])) && (!std::isnan
                      (translbounds[1])));
            bv[2] = ((!std::isinf(translbounds[2])) && (!std::isnan
                      (translbounds[2])));
            b = true;
            k = 0;
            exitg2 = false;
            while ((!exitg2) && (k <= 2)) {
              if (!bv[k]) {
                b = false;
                exitg2 = true;
              } else {
                k++;
              }
            }

            guard1 = false;
            guard2 = false;
            guard3 = false;
            if (b) {
              b_b[0] = std::isinf(translbounds[3]);
              c_b[0] = std::isnan(translbounds[3]);
              b_b[1] = std::isinf(translbounds[4]);
              c_b[1] = std::isnan(translbounds[4]);
              b_b[2] = std::isinf(translbounds[5]);
              c_b[2] = std::isnan(translbounds[5]);
              b_bool = true;
              k = 0;
              exitg2 = false;
              while ((!exitg2) && (k <= 2)) {
                if (b_b[k] || c_b[k]) {
                  b_bool = false;
                  exitg2 = true;
                } else {
                  k++;
                }
              }

              if (b_bool) {
                c_rand(rn);
                rn[0] = translbounds[0] + rn[0] * (translbounds[3] -
                  translbounds[0]);
                rn[1] = translbounds[1] + rn[1] * (translbounds[4] -
                  translbounds[1]);
                rn[2] = translbounds[2] + rn[2] * (translbounds[5] -
                  translbounds[2]);
              } else {
                guard3 = true;
              }
            } else {
              guard3 = true;
            }

            if (guard3) {
              if (b) {
                x_data[0] = (std::isinf(translbounds[3]) || std::isnan
                             (translbounds[3]));
                x_data[1] = (std::isinf(translbounds[4]) || std::isnan
                             (translbounds[4]));
                x_data[2] = (std::isinf(translbounds[5]) || std::isnan
                             (translbounds[5]));
                b_bool = false;
                k = 0;
                exitg2 = false;
                while ((!exitg2) && (k <= 2)) {
                  if (x_data[k]) {
                    b_bool = true;
                    exitg2 = true;
                  } else {
                    k++;
                  }
                }

                if (b_bool) {
                  b_randn(rn);
                  rn[0] = translbounds[0] + std::abs(rn[0]);
                  rn[1] = translbounds[1] + std::abs(rn[1]);
                  rn[2] = translbounds[2] + std::abs(rn[2]);
                } else {
                  guard2 = true;
                }
              } else {
                guard2 = true;
              }
            }

            if (guard2) {
              x_data[0] = !bv[0];
              x_data[1] = !bv[1];
              x_data[2] = !bv[2];
              b_bool = false;
              k = 0;
              exitg2 = false;
              while ((!exitg2) && (k <= 2)) {
                if (x_data[k]) {
                  b_bool = true;
                  exitg2 = true;
                } else {
                  k++;
                }
              }

              if (b_bool) {
                b_b[0] = std::isinf(translbounds[3]);
                c_b[0] = std::isnan(translbounds[3]);
                b_b[1] = std::isinf(translbounds[4]);
                c_b[1] = std::isnan(translbounds[4]);
                b_b[2] = std::isinf(translbounds[5]);
                c_b[2] = std::isnan(translbounds[5]);
                b_bool = true;
                k = 0;
                exitg2 = false;
                while ((!exitg2) && (k <= 2)) {
                  if (b_b[k] || c_b[k]) {
                    b_bool = false;
                    exitg2 = true;
                  } else {
                    k++;
                  }
                }

                if (b_bool) {
                  b_randn(rn);
                  rn[0] = translbounds[3] - std::abs(rn[0]);
                  rn[1] = translbounds[4] - std::abs(rn[1]);
                  rn[2] = translbounds[5] - std::abs(rn[2]);
                } else {
                  guard1 = true;
                }
              } else {
                guard1 = true;
              }
            }

            if (guard1) {
              b_randn(rn);
            }

            kstr = i2 - i1;
            for (i2 = 0; i2 < kstr; i2++) {
              qi_data[i1 + i2] = rn[i2];
            }
          }
          break;

         default:
          {
            double bounds_data[14];
            double bounds[2];
            int b_loop_ub_tmp;
            bool exitg2;
            bool guard1;
            bool guard2;
            bool guard3;
            n = b_obj->PositionNumber;
            if (n < 1.0) {
              b_loop_ub_tmp = 0;
            } else {
              b_loop_ub_tmp = static_cast<int>(n);
            }

            bounds_size[0] = b_loop_ub_tmp;
            bounds_size[1] = 2;
            for (i1 = 0; i1 < 2; i1++) {
              for (i2 = 0; i2 < b_loop_ub_tmp; i2++) {
                bounds_data[i2 + b_loop_ub_tmp * i1] =
                  b_obj->PositionLimitsInternal[i2 + 7 * i1];
              }
            }

            b_x.set_size(b_loop_ub_tmp);
            for (i1 = 0; i1 < b_loop_ub_tmp; i1++) {
              n = bounds_data[i1];
              b_x[i1] = ((!std::isinf(n)) && (!std::isnan(n)));
            }

            b_bool = true;
            kstr = 1;
            exitg2 = false;
            while ((!exitg2) && (kstr <= b_x.size(0))) {
              if (!b_x[kstr - 1]) {
                b_bool = false;
                exitg2 = true;
              } else {
                kstr++;
              }
            }

            guard1 = false;
            guard2 = false;
            guard3 = false;
            if (b_bool) {
              b_x.set_size(b_loop_ub_tmp);
              for (i1 = 0; i1 < b_loop_ub_tmp; i1++) {
                n = bounds_data[i1 + b_loop_ub_tmp];
                b_x[i1] = ((!std::isinf(n)) && (!std::isnan(n)));
              }

              b_bool = true;
              kstr = 1;
              exitg2 = false;
              while ((!exitg2) && (kstr <= b_x.size(0))) {
                if (!b_x[kstr - 1]) {
                  b_bool = false;
                  exitg2 = true;
                } else {
                  kstr++;
                }
              }

              if (b_bool) {
                x.reserve(7);
                i1 = b_rand(static_cast<double>(b_loop_ub_tmp), (double *)x.data
                            ());
                (*(int (*)[1])x.size())[0] = i1;
                x.set_size(x.size(0));
                if (x.size(0) == 1) {
                  i1 = b_loop_ub_tmp;
                } else {
                  i1 = x.size(0);
                }

                if ((x.size(0) == b_loop_ub_tmp) && (b_loop_ub_tmp == i1)) {
                  x.set_size(b_loop_ub_tmp);
                  for (i1 = 0; i1 < b_loop_ub_tmp; i1++) {
                    n = bounds_data[i1];
                    x[i1] = n + x[i1] * (bounds_data[i1 + b_loop_ub_tmp] - n);
                  }
                } else {
                  binary_expand_op_16(x, bounds_data, bounds_size);
                }
              } else {
                guard3 = true;
              }
            } else {
              guard3 = true;
            }

            if (guard3) {
              b_x.set_size(b_loop_ub_tmp);
              for (i1 = 0; i1 < b_loop_ub_tmp; i1++) {
                n = bounds_data[i1];
                b_x[i1] = ((!std::isinf(n)) && (!std::isnan(n)));
              }

              b_bool = true;
              kstr = 1;
              exitg2 = false;
              while ((!exitg2) && (kstr <= b_x.size(0))) {
                if (!b_x[kstr - 1]) {
                  b_bool = false;
                  exitg2 = true;
                } else {
                  kstr++;
                }
              }

              if (b_bool) {
                b_x.set_size(b_loop_ub_tmp);
                for (i1 = 0; i1 < b_loop_ub_tmp; i1++) {
                  n = bounds_data[i1 + b_loop_ub_tmp];
                  b_x[i1] = (std::isinf(n) || std::isnan(n));
                }

                b_bool = false;
                kstr = 1;
                exitg2 = false;
                while ((!exitg2) && (kstr <= b_x.size(0))) {
                  if (b_x[kstr - 1]) {
                    b_bool = true;
                    exitg2 = true;
                  } else {
                    kstr++;
                  }
                }

                if (b_bool) {
                  bounds[0] = b_loop_ub_tmp;
                  bounds[1] = 1.0;
                  x.reserve(7);
                  i1 = randn(bounds, (double *)x.data());
                  (*(int (*)[1])x.size())[0] = i1;
                  x.set_size(x.size(0));
                  kstr = x.size(0);
                  y.set_size(x.size(0));
                  for (int k{0}; k < kstr; k++) {
                    y[k] = std::abs(x[k]);
                  }

                  if (b_loop_ub_tmp == y.size(0)) {
                    x.set_size(b_loop_ub_tmp);
                    for (i1 = 0; i1 < b_loop_ub_tmp; i1++) {
                      x[i1] = bounds_data[i1] + y[i1];
                    }
                  } else {
                    binary_expand_op_17(x, bounds_data, bounds_size, y);
                  }
                } else {
                  guard2 = true;
                }
              } else {
                guard2 = true;
              }
            }

            if (guard2) {
              b_x.set_size(b_loop_ub_tmp);
              for (i1 = 0; i1 < b_loop_ub_tmp; i1++) {
                n = bounds_data[i1];
                b_x[i1] = (std::isinf(n) || std::isnan(n));
              }

              b_bool = false;
              kstr = 1;
              exitg2 = false;
              while ((!exitg2) && (kstr <= b_x.size(0))) {
                if (b_x[kstr - 1]) {
                  b_bool = true;
                  exitg2 = true;
                } else {
                  kstr++;
                }
              }

              if (b_bool) {
                b_x.set_size(b_loop_ub_tmp);
                for (i1 = 0; i1 < b_loop_ub_tmp; i1++) {
                  n = bounds_data[i1 + b_loop_ub_tmp];
                  b_x[i1] = ((!std::isinf(n)) && (!std::isnan(n)));
                }

                b_bool = true;
                kstr = 1;
                exitg2 = false;
                while ((!exitg2) && (kstr <= b_x.size(0))) {
                  if (!b_x[kstr - 1]) {
                    b_bool = false;
                    exitg2 = true;
                  } else {
                    kstr++;
                  }
                }

                if (b_bool) {
                  bounds[0] = b_loop_ub_tmp;
                  bounds[1] = 1.0;
                  x.reserve(7);
                  i1 = randn(bounds, (double *)x.data());
                  (*(int (*)[1])x.size())[0] = i1;
                  x.set_size(x.size(0));
                  kstr = x.size(0);
                  y.set_size(x.size(0));
                  for (int k{0}; k < kstr; k++) {
                    y[k] = std::abs(x[k]);
                  }

                  if (b_loop_ub_tmp == y.size(0)) {
                    x.set_size(b_loop_ub_tmp);
                    for (i1 = 0; i1 < b_loop_ub_tmp; i1++) {
                      x[i1] = bounds_data[i1 + b_loop_ub_tmp] - y[i1];
                    }
                  } else {
                    binary_expand_op_18(x, bounds_data, bounds_size, y);
                  }
                } else {
                  guard1 = true;
                }
              } else {
                guard1 = true;
              }
            }

            if (guard1) {
              bounds[0] = b_loop_ub_tmp;
              bounds[1] = 1.0;
              x.reserve(7);
              i1 = randn(bounds, (double *)x.data());
              (*(int (*)[1])x.size())[0] = i1;
              x.set_size(x.size(0));
            }

            kstr = x.size(0);
            for (i1 = 0; i1 < kstr; i1++) {
              qi_data[i1] = x[i1];
            }
          }
          break;
        }

        if (p_idx_0 > p_idx_1) {
          i1 = 0;
          i2 = 0;
        } else {
          i1 = static_cast<int>(p_idx_0) - 1;
          i2 = static_cast<int>(p_idx_1);
        }

        kstr = i2 - i1;
        for (i2 = 0; i2 < kstr; i2++) {
          qr_data[i1 + i2] = qi_data[i2];
        }
      }
    }

    r.set_size(problem->DesignVariableBoundsInternal.size(0), 2);
    kstr = problem->DesignVariableBoundsInternal.size(0) << 1;
    for (i = 0; i < kstr; i++) {
      r[i] = problem->DesignVariableBoundsInternal[i];
    }

    n = problem->NumPositions + 1.0;
    if (n > r.size(0)) {
      i = 0;
      i1 = -1;
    } else {
      i = static_cast<int>(n) - 1;
      i1 = r.size(0) - 1;
    }

    kstr = static_cast<int>(problem->NumSlacks);
    y.set_size(static_cast<int>(posnum) + kstr);
    for (i2 = 0; i2 < loop_ub_tmp; i2++) {
      y[i2] = qr_data[i2];
    }

    for (i2 = 0; i2 < kstr; i2++) {
      y[i2 + static_cast<int>(posnum)] = 0.0;
    }

    problem->residuals(y, x);
    kstr = i1 - i;
    if (kstr + 1 == x.size(0)) {
      y.set_size(kstr + 1);
      for (i1 = 0; i1 <= kstr; i1++) {
        n = r[i + i1];
        p_idx_0 = x[i1];
        y[i1] = std::fmax(n, p_idx_0);
      }
    } else {
      r1.set_size(kstr + 1);
      for (i1 = 0; i1 <= kstr; i1++) {
        r1[i1] = r[i + i1];
      }

      internal::expand_max(r1, x, y);
    }

    if (kstr + 1 == y.size(0)) {
      x.set_size(kstr + 1);
      for (i1 = 0; i1 <= kstr; i1++) {
        n = r[(i + i1) + r.size(0)];
        p_idx_0 = y[i1];
        x[i1] = std::fmin(n, p_idx_0);
      }
    } else {
      r1.set_size(kstr + 1);
      for (i1 = 0; i1 <= kstr; i1++) {
        r1[i1] = r[(i + i1) + r.size(0)];
      }

      internal::expand_min(r1, y, x);
    }

    rc.set_size(static_cast<int>(posnum) + x.size(0));
    for (i = 0; i < loop_ub_tmp; i++) {
      rc[i] = qr_data[i];
    }

    kstr = x.size(0);
    for (i = 0; i < kstr; i++) {
      rc[i + static_cast<int>(posnum)] = x[i];
    }
  }

  //
  // Arguments    : void
  // Return Type  : void
  //
  void rigidBodyJoint::resetHomePosition()
  {
    array<bool, 1U> x;
    double ub_data[7];
    double d;
    int loop_ub_tmp;
    d = PositionNumber;
    if (d < 1.0) {
      loop_ub_tmp = 0;
    } else {
      loop_ub_tmp = static_cast<int>(d);
    }

    if (loop_ub_tmp - 1 >= 0) {
      ::std::copy(&PositionLimitsInternal[7], &PositionLimitsInternal[7 +
                  loop_ub_tmp], &ub_data[0]);
    }

    if (PositionNumber == 1.0) {
      double d1;
      int ix;
      bool exitg1;
      bool guard1;
      bool guard2;
      bool guard3;
      bool y;
      x.set_size(loop_ub_tmp);
      for (ix = 0; ix < loop_ub_tmp; ix++) {
        d1 = PositionLimitsInternal[ix];
        x[ix] = ((!std::isinf(d1)) && (!std::isnan(d1)));
      }

      y = true;
      ix = 1;
      exitg1 = false;
      while ((!exitg1) && (ix <= x.size(0))) {
        if (!x[ix - 1]) {
          y = false;
          exitg1 = true;
        } else {
          ix++;
        }
      }

      guard1 = false;
      guard2 = false;
      guard3 = false;
      if (y) {
        x.set_size(loop_ub_tmp);
        for (ix = 0; ix < loop_ub_tmp; ix++) {
          d1 = PositionLimitsInternal[ix + 7];
          x[ix] = ((!std::isinf(d1)) && (!std::isnan(d1)));
        }

        y = true;
        ix = 1;
        exitg1 = false;
        while ((!exitg1) && (ix <= x.size(0))) {
          if (!x[ix - 1]) {
            y = false;
            exitg1 = true;
          } else {
            ix++;
          }
        }

        if (y) {
          for (ix = 0; ix < loop_ub_tmp; ix++) {
            ub_data[ix] = 0.5 * (PositionLimitsInternal[ix] +
                                 PositionLimitsInternal[ix + 7]);
          }
        } else {
          guard3 = true;
        }
      } else {
        guard3 = true;
      }

      if (guard3) {
        x.set_size(loop_ub_tmp);
        for (ix = 0; ix < loop_ub_tmp; ix++) {
          d1 = PositionLimitsInternal[ix];
          x[ix] = ((!std::isinf(d1)) && (!std::isnan(d1)));
        }

        y = true;
        ix = 1;
        exitg1 = false;
        while ((!exitg1) && (ix <= x.size(0))) {
          if (!x[ix - 1]) {
            y = false;
            exitg1 = true;
          } else {
            ix++;
          }
        }

        if (y) {
          x.set_size(loop_ub_tmp);
          for (ix = 0; ix < loop_ub_tmp; ix++) {
            d1 = PositionLimitsInternal[ix + 7];
            x[ix] = (std::isinf(d1) || std::isnan(d1));
          }

          y = false;
          ix = 1;
          exitg1 = false;
          while ((!exitg1) && (ix <= x.size(0))) {
            if (x[ix - 1]) {
              y = true;
              exitg1 = true;
            } else {
              ix++;
            }
          }

          if (y) {
            if (loop_ub_tmp - 1 >= 0) {
              ::std::copy(&PositionLimitsInternal[0],
                          &PositionLimitsInternal[loop_ub_tmp], &ub_data[0]);
            }
          } else {
            guard2 = true;
          }
        } else {
          guard2 = true;
        }
      }

      if (guard2) {
        x.set_size(loop_ub_tmp);
        for (ix = 0; ix < loop_ub_tmp; ix++) {
          d1 = PositionLimitsInternal[ix];
          x[ix] = (std::isinf(d1) || std::isnan(d1));
        }

        y = false;
        ix = 1;
        exitg1 = false;
        while ((!exitg1) && (ix <= x.size(0))) {
          if (x[ix - 1]) {
            y = true;
            exitg1 = true;
          } else {
            ix++;
          }
        }

        if (y) {
          x.set_size(loop_ub_tmp);
          for (ix = 0; ix < loop_ub_tmp; ix++) {
            d1 = PositionLimitsInternal[ix + 7];
            x[ix] = ((!std::isinf(d1)) && (!std::isnan(d1)));
          }

          y = true;
          ix = 1;
          exitg1 = false;
          while ((!exitg1) && (ix <= x.size(0))) {
            if (!x[ix - 1]) {
              y = false;
              exitg1 = true;
            } else {
              ix++;
            }
          }

          if (!y) {
            guard1 = true;
          }
        } else {
          guard1 = true;
        }
      }

      if (guard1) {
        if (loop_ub_tmp - 1 >= 0) {
          std::memset(&ub_data[0], 0, static_cast<unsigned int>(loop_ub_tmp) *
                      sizeof(double));
        }
      }

      if (d < 1.0) {
        ix = 0;
      } else {
        ix = static_cast<int>(d);
      }

      if (ix - 1 >= 0) {
        ::std::copy(&ub_data[0], &ub_data[ix], &HomePositionInternal[0]);
      }
    }
  }

  //
  // Arguments    : const array<double, 1U> &x
  //                array<bool, 1U> &activeSet
  //                array<double, 2U> &A
  // Return Type  : void
  //
  namespace robotics
  {
    namespace core
    {
      namespace internal
      {
        void DampedBFGSwGradientProjection::identifyActiveSet(const array<double,
          1U> &x, array<bool, 1U> &activeSet, array<double, 2U> &A) const
        {
          array<double, 2U> A_;
          array<double, 2U> b_A_;
          array<double, 1U> s;
          array<int, 2U> jpvt;
          array<int, 2U> jpvt1;
          array<int, 1U> activeSetCols;
          array<int, 1U> b_activeSetCols;
          array<bool, 1U> b_s;
          int exponent;
          int k;
          int loop_ub;
          loop_ub = ConstraintBound.size(0);
          activeSet.set_size(loop_ub);
          for (k = 0; k < loop_ub; k++) {
            activeSet[k] = false;
          }

          A.set_size(x.size(0), 0);
          if (ConstraintsOn) {
            int i;
            int inner_tmp;
            int irank;
            int mc_tmp;
            mc_tmp = ConstraintMatrix.size(1);
            inner_tmp = ConstraintMatrix.size(0);
            s.set_size(mc_tmp);
            for (i = 0; i < mc_tmp; i++) {
              s[i] = 0.0;
            }

            for (k = 0; k < inner_tmp; k++) {
              for (i = 0; i < mc_tmp; i++) {
                s[i] = s[i] + ConstraintMatrix[i * ConstraintMatrix.size(0) + k]
                  * x[k];
              }
            }

            if (s.size(0) == ConstraintBound.size(0)) {
              b_s.set_size(mc_tmp);
              for (k = 0; k < mc_tmp; k++) {
                b_s[k] = (s[k] >= ConstraintBound[k]);
              }

              c_eml_find(b_s, activeSetCols);
            } else {
              binary_expand_op_14(activeSetCols, s, this);
            }

            loop_ub = activeSetCols.size(0);
            A_.set_size(inner_tmp, activeSetCols.size(0));
            for (k = 0; k < loop_ub; k++) {
              for (mc_tmp = 0; mc_tmp < inner_tmp; mc_tmp++) {
                A_[mc_tmp + A_.size(0) * k] = ConstraintMatrix[mc_tmp +
                  ConstraintMatrix.size(0) * (activeSetCols[k] - 1)];
              }
            }

            irank = 0;
            if ((ConstraintMatrix.size(0) != 0) && (activeSetCols.size(0) != 0))
            {
              double absx;
              bool p;
              mc_tmp = ConstraintMatrix.size(0) * activeSetCols.size(0);
              p = true;
              for (k = 0; k < mc_tmp; k++) {
                if ((!p) || (std::isinf(A_[k]) || std::isnan(A_[k]))) {
                  p = false;
                }
              }

              if (p) {
                if (ConstraintMatrix.size(0) == 0) {
                  s.set_size(0);
                } else {
                  b_A_.set_size(A_.size(0), A_.size(1));
                  mc_tmp = A_.size(0) * A_.size(1) - 1;
                  for (k = 0; k <= mc_tmp; k++) {
                    b_A_[k] = A_[k];
                  }

                  ::coder::internal::reflapack::xzsvdc(b_A_, s);
                }
              } else {
                mc_tmp = static_cast<int>(std::fmin(static_cast<double>
                  (ConstraintMatrix.size(0)), static_cast<double>
                  (activeSetCols.size(0))));
                s.set_size(static_cast<int>(std::fmin(static_cast<double>
                  (ConstraintMatrix.size(0)), static_cast<double>
                  (activeSetCols.size(0)))));
                for (k = 0; k < mc_tmp; k++) {
                  s[k] = rtNaN;
                }
              }

              mc_tmp = ConstraintMatrix.size(0);
              k = activeSetCols.size(0);
              if (mc_tmp >= k) {
                k = mc_tmp;
              }

              if (ConstraintMatrix.size(0) == 0) {
                mc_tmp = 0;
              } else {
                mc_tmp = k;
              }

              if (s.size(0) == 0) {
                absx = 0.0;
              } else {
                bool exitg1;
                absx = std::abs(s[0]);
                if (std::isinf(absx) || std::isnan(absx)) {
                  absx = rtNaN;
                } else if (absx < 4.4501477170144028E-308) {
                  absx = 4.94065645841247E-324;
                } else {
                  std::frexp(absx, &exponent);
                  absx = std::ldexp(1.0, exponent - 53);
                }

                absx *= static_cast<double>(mc_tmp);
                i = 0;
                exitg1 = false;
                while ((!exitg1) && (i <= s.size(0) - 1)) {
                  if (std::isinf(s[i]) || std::isnan(s[i])) {
                    absx = 1.7976931348623157E+308;
                    exitg1 = true;
                  } else {
                    i++;
                  }
                }
              }

              k = 0;
              while ((k <= s.size(0) - 1) && (s[k] > absx)) {
                irank++;
                k++;
              }
            }

            if (irank < activeSetCols.size(0)) {
              b_A_.set_size(inner_tmp, inner_tmp);
              if (ConstraintMatrix.size(0) > activeSetCols.size(0)) {
                for (mc_tmp = 0; mc_tmp < loop_ub; mc_tmp++) {
                  for (i = 0; i < inner_tmp; i++) {
                    b_A_[i + b_A_.size(0) * mc_tmp] = ConstraintMatrix[i +
                      ConstraintMatrix.size(0) * (activeSetCols[mc_tmp] - 1)];
                  }
                }

                k = activeSetCols.size(0) + 1;
                for (mc_tmp = k; mc_tmp <= inner_tmp; mc_tmp++) {
                  for (i = 0; i < inner_tmp; i++) {
                    b_A_[i + b_A_.size(0) * (mc_tmp - 1)] = 0.0;
                  }
                }

                ::coder::internal::lapack::xgeqp3(b_A_, s, jpvt1);
                jpvt.set_size(1, activeSetCols.size(0));
                for (mc_tmp = 0; mc_tmp < loop_ub; mc_tmp++) {
                  jpvt[mc_tmp] = jpvt1[mc_tmp];
                }
              } else {
                ::coder::internal::lapack::xgeqp3(A_, s, jpvt);
              }

              if (irank < 1) {
                mc_tmp = 0;
              } else {
                mc_tmp = irank;
              }

              b_activeSetCols.set_size(mc_tmp);
              for (k = 0; k < mc_tmp; k++) {
                b_activeSetCols[k] = activeSetCols[jpvt[k] - 1];
              }

              activeSetCols.set_size(mc_tmp);
              for (k = 0; k < mc_tmp; k++) {
                activeSetCols[k] = b_activeSetCols[k];
              }
            }

            loop_ub = activeSetCols.size(0);
            A.set_size(inner_tmp, activeSetCols.size(0));
            for (k = 0; k < loop_ub; k++) {
              for (mc_tmp = 0; mc_tmp < inner_tmp; mc_tmp++) {
                A[mc_tmp + A.size(0) * k] = ConstraintMatrix[mc_tmp +
                  ConstraintMatrix.size(0) * (activeSetCols[k] - 1)];
              }

              activeSet[activeSetCols[k] - 1] = true;
            }
          }
        }

        //
        // Arguments    : void
        // Return Type  : void
        //
        void DampedBFGSwGradientProjection::matlabCodegenDestructor()
        {
          if (!matlabCodegenIsDeleted) {
            matlabCodegenIsDeleted = true;
          }
        }

        //
        // Arguments    : const array<double, 1U> &xNew
        // Return Type  : bool
        //
        bool DampedBFGSwGradientProjection::searchDirectionInvalid(const array<
          double, 1U> &xNew) const
        {
          array<double, 1U> C;
          array<bool, 1U> x;
          bool flag;
          if (ConstraintsOn) {
            int inner;
            int mc_tmp;
            bool exitg1;
            mc_tmp = ConstraintMatrix.size(1);
            inner = ConstraintMatrix.size(0);
            C.set_size(mc_tmp);
            for (int i{0}; i < mc_tmp; i++) {
              C[i] = 0.0;
            }

            for (int k{0}; k < inner; k++) {
              for (int i{0}; i < mc_tmp; i++) {
                C[i] = C[i] + ConstraintMatrix[i * ConstraintMatrix.size(0) + k]
                  * xNew[k];
              }
            }

            if (C.size(0) == ConstraintBound.size(0)) {
              x.set_size(mc_tmp);
              for (inner = 0; inner < mc_tmp; inner++) {
                x[inner] = (C[inner] - ConstraintBound[inner] >
                            1.4901161193847656E-8);
              }
            } else {
              binary_expand_op_15(x, C, this);
            }

            flag = false;
            inner = 1;
            exitg1 = false;
            while ((!exitg1) && (inner <= x.size(0))) {
              if (x[inner - 1]) {
                flag = true;
                exitg1 = true;
              } else {
                inner++;
              }
            }

            if (flag) {
              flag = true;
            } else {
              flag = false;
            }
          } else {
            flag = false;
          }

          return flag;
        }

        //
        // Arguments    : array<double, 1U> &xSol
        //                double &err
        //                double &iter
        // Return Type  : NLPSolverExitFlags
        //
        NLPSolverExitFlags DampedBFGSwGradientProjection::solveInternal(array<
          double, 1U> &xSol, double &err, double &iter)
        {
          manip::internal::GIKProblem *r;
          manip::internal::GIKProblem *r2;
          manip::internal::GIKProblem *r3;
          manip::internal::GIKProblem *r6;
          manip::internal::GIKProblem *r7;
          array<double, 2U> A;
          array<double, 2U> AIn;
          array<double, 2U> C;
          array<double, 2U> H;
          array<double, 2U> P;
          array<double, 2U> V;
          array<double, 2U> a;
          array<double, 2U> b_A;
          array<double, 2U> b_H;
          array<double, 2U> c_A;
          array<double, 1U> Hg;
          array<double, 1U> alpha;
          array<double, 1U> bIn;
          array<double, 1U> grad;
          array<double, 1U> gradNew;
          array<double, 1U> x;
          array<int, 1U> inactiveConstraintIndices;
          array<int, 1U> r1;
          array<int, 1U> r4;
          array<int, 1U> r5;
          array<int, 1U> r8;
          array<int, 1U> r9;
          array<bool, 1U> activeSet;
          array<bool, 1U> b_x;
          double beta;
          double cost;
          double costNew;
          double lambda;
          int aoffset;
          int b_i;
          int b_loop_ub_tmp;
          int boffset;
          int i;
          int i1;
          int j;
          int loop_ub;
          int loop_ub_tmp;
          int n;
          int nc_tmp;
          int nx;
          NLPSolverExitFlags exitFlag;
          n = SeedInternal.size(0);
          x.set_size(n);
          loop_ub = SeedInternal.size(0);
          for (i = 0; i < loop_ub; i++) {
            x[i] = SeedInternal[i];
          }

          TimeObjInternal.StartTime.tv_sec = tic
            (TimeObjInternal.StartTime.tv_nsec);
          cost = manip::internal::GIKHelpers::computeCost(x, ExtraArgs, AIn, P,
            &r);
          ExtraArgs = r;
          manip::internal::GIKHelpers::computeGradient(x, ExtraArgs, grad);
          H.set_size(n, n);
          loop_ub_tmp = x.size(0) * x.size(0);
          for (i = 0; i < loop_ub_tmp; i++) {
            H[i] = 0.0;
          }

          if (x.size(0) > 0) {
            for (i1 = 0; i1 < n; i1++) {
              H[i1 + H.size(0) * i1] = 1.0;
            }
          }

          identifyActiveSet(x, activeSet, A);
          i = A.size(1);
          for (i1 = 0; i1 < i; i1++) {
            aoffset = A.size(0);
            nc_tmp = H.size(1);
            C.set_size(1, H.size(1));
            for (j = 0; j < nc_tmp; j++) {
              boffset = j * H.size(0);
              C[j] = 0.0;
              for (nx = 0; nx < aoffset; nx++) {
                C[j] = C[j] + A[nx + A.size(0) * i1] * H[boffset + nx];
              }
            }

            beta = 0.0;
            for (int i2{0}; i2 < nc_tmp; i2++) {
              beta += C[i2] * A[i2 + A.size(0) * i1];
            }

            lambda = 1.0 / beta;
            a.set_size(H.size(0), H.size(1));
            b_loop_ub_tmp = H.size(0) * H.size(1);
            for (int i2{0}; i2 < b_loop_ub_tmp; i2++) {
              a[i2] = lambda * H[i2];
            }

            b_A.set_size(A.size(0), A.size(0));
            for (int i2{0}; i2 < aoffset; i2++) {
              for (int i3{0}; i3 < aoffset; i3++) {
                b_A[i3 + b_A.size(0) * i2] = A[i3 + A.size(0) * i1] * A[i2 +
                  A.size(0) * i1];
              }
            }

            ::coder::internal::blas::mtimes(a, b_A, AIn);
            ::coder::internal::blas::mtimes(AIn, H, b_H);
            if ((H.size(0) == b_H.size(0)) && (H.size(1) == b_H.size(1))) {
              for (int i2{0}; i2 < b_loop_ub_tmp; i2++) {
                H[i2] = H[i2] - b_H[i2];
              }
            } else {
              minus(H, b_H);
            }
          }

          xSol.set_size(n);
          for (i = 0; i < n; i++) {
            xSol[i] = x[i];
          }

          lambda = MaxNumIterationInternal;
          i = static_cast<int>(lambda);
          b_i = 0;
          int exitg2;
          do {
            exitg2 = 0;
            if (b_i <= i - 1) {
              bool flag;
              iter = static_cast<double>(b_i) + 1.0;
              lambda = toc(TimeObjInternal.StartTime.tv_sec,
                           TimeObjInternal.StartTime.tv_nsec);
              flag = (lambda > MaxTimeInternal);
              if (flag) {
                exitFlag = NLPSolverExitFlags::TimeLimitExceeded;
                err = manip::internal::GIKHelpers::evaluateSolution(x, ExtraArgs);
                exitg2 = 1;
              } else {
                double b_gamma;
                int b_loop_ub;
                int inner;
                bool exitg3;
                bool guard1;
                bool guard2;
                bool guard3;
                if ((A.size(0) == 0) || (A.size(1) == 0)) {
                  alpha.set_size(1);
                  alpha[0] = 0.0;
                } else {
                  ::coder::internal::blas::b_mtimes(A, A, AIn);
                  loop_ub = A.size(1);
                  b_loop_ub = A.size(0);
                  b_A.set_size(A.size(1), A.size(0));
                  for (int i2{0}; i2 < b_loop_ub; i2++) {
                    for (int i3{0}; i3 < loop_ub; i3++) {
                      b_A[i3 + b_A.size(0) * i2] = A[i2 + A.size(0) * i3];
                    }
                  }

                  mldivide(AIn, b_A, b_H);
                  nx = b_H.size(0);
                  inner = b_H.size(1);
                  alpha.set_size(b_H.size(0));
                  for (nc_tmp = 0; nc_tmp < nx; nc_tmp++) {
                    alpha[nc_tmp] = 0.0;
                  }

                  for (i1 = 0; i1 < inner; i1++) {
                    aoffset = i1 * b_H.size(0);
                    for (nc_tmp = 0; nc_tmp < nx; nc_tmp++) {
                      alpha[nc_tmp] = alpha[nc_tmp] + b_H[aoffset + nc_tmp] *
                        grad[i1];
                    }
                  }
                }

                nx = H.size(0);
                inner = H.size(1);
                Hg.set_size(H.size(0));
                for (nc_tmp = 0; nc_tmp < nx; nc_tmp++) {
                  Hg[nc_tmp] = 0.0;
                }

                for (i1 = 0; i1 < inner; i1++) {
                  aoffset = i1 * H.size(0);
                  for (nc_tmp = 0; nc_tmp < nx; nc_tmp++) {
                    Hg[nc_tmp] = Hg[nc_tmp] + H[aoffset + nc_tmp] * grad[i1];
                  }
                }

                lambda = b_norm(Hg);
                guard1 = false;
                guard2 = false;
                guard3 = false;
                if (lambda < GradientTolerance) {
                  loop_ub = alpha.size(0);
                  b_x.set_size(alpha.size(0));
                  for (int i2{0}; i2 < loop_ub; i2++) {
                    b_x[i2] = (alpha[i2] <= 0.0);
                  }

                  flag = true;
                  nx = 1;
                  exitg3 = false;
                  while ((!exitg3) && (nx <= b_x.size(0))) {
                    if (!b_x[nx - 1]) {
                      flag = false;
                      exitg3 = true;
                    } else {
                      nx++;
                    }
                  }

                  if (flag) {
                    exitFlag = NLPSolverExitFlags::LocalMinimumFound;
                    err = manip::internal::GIKHelpers::evaluateSolution(x,
                      ExtraArgs);
                    exitg2 = 1;
                  } else {
                    guard3 = true;
                  }
                } else {
                  guard3 = true;
                }

                if (guard3) {
                  if (ConstraintsOn && ((A.size(0) != 0) && (A.size(1) != 0))) {
                    ::coder::internal::blas::b_mtimes(A, A, AIn);
                    inv(AIn, b_H);
                    if ((b_H.size(0) == 1) && (b_H.size(1) == 1)) {
                      gradNew.set_size(1);
                      gradNew[0] = b_H[0];
                    } else {
                      aoffset = b_H.size(0);
                      nx = b_H.size(1);
                      if (aoffset <= nx) {
                        nx = aoffset;
                      }

                      if (b_H.size(1) <= 0) {
                        nx = 0;
                      }

                      gradNew.set_size(nx);
                      for (i1 = 0; i1 < nx; i1++) {
                        gradNew[i1] = b_H[i1 + b_H.size(0) * i1];
                      }
                    }

                    nx = gradNew.size(0);
                    for (i1 = 0; i1 < nx; i1++) {
                      gradNew[i1] = std::sqrt(gradNew[i1]);
                    }

                    if (alpha.size(0) == gradNew.size(0)) {
                      loop_ub = alpha.size(0);
                      for (int i2{0}; i2 < loop_ub; i2++) {
                        alpha[i2] = alpha[i2] / gradNew[i2];
                      }

                      b_gamma = ::coder::internal::maximum(alpha, nx);
                    } else {
                      b_gamma = binary_expand_op_13(alpha, gradNew, nx);
                    }

                    if (lambda < 0.5 * b_gamma) {
                      c_eml_find(activeSet, r1);
                      loop_ub = r1.size(0);
                      alpha.set_size(r1.size(0));
                      for (int i2{0}; i2 < loop_ub; i2++) {
                        alpha[i2] = r1[i2];
                      }

                      boffset = static_cast<int>(alpha[nx - 1]) - 1;
                      activeSet[boffset] = false;
                      nx = activeSet.size(0);
                      aoffset = 0;
                      for (nc_tmp = 0; nc_tmp < nx; nc_tmp++) {
                        if (activeSet[nc_tmp]) {
                          aoffset++;
                        }
                      }

                      r5.set_size(aoffset);
                      aoffset = 0;
                      for (nc_tmp = 0; nc_tmp < nx; nc_tmp++) {
                        if (activeSet[nc_tmp]) {
                          r5[aoffset] = nc_tmp;
                          aoffset++;
                        }
                      }

                      loop_ub = ConstraintMatrix.size(0);
                      b_loop_ub = r5.size(0);
                      A.set_size(loop_ub, r5.size(0));
                      for (int i2{0}; i2 < b_loop_ub; i2++) {
                        nx = ConstraintMatrix.size(0);
                        for (int i3{0}; i3 < nx; i3++) {
                          A[i3 + A.size(0) * i2] = ConstraintMatrix[i3 +
                            ConstraintMatrix.size(0) * r5[i2]];
                        }
                      }

                      P.set_size(n, n);
                      for (int i2{0}; i2 < loop_ub_tmp; i2++) {
                        P[i2] = 0.0;
                      }

                      if (n > 0) {
                        for (i1 = 0; i1 < n; i1++) {
                          P[i1 + P.size(0) * i1] = 1.0;
                        }
                      }

                      b_A.set_size(r5.size(0), loop_ub);
                      for (int i2{0}; i2 < loop_ub; i2++) {
                        for (int i3{0}; i3 < b_loop_ub; i3++) {
                          b_A[i3 + b_A.size(0) * i2] = A[i2 + A.size(0) * i3];
                        }
                      }

                      ::coder::internal::blas::b_mtimes(A, A, b_H);
                      mldivide(b_H, b_A, a);
                      ::coder::internal::blas::mtimes(A, a, AIn);
                      if ((P.size(0) == AIn.size(0)) && (P.size(1) == AIn.size(1)))
                      {
                        for (int i2{0}; i2 < loop_ub_tmp; i2++) {
                          P[i2] = P[i2] - AIn[i2];
                        }
                      } else {
                        minus(P, AIn);
                      }

                      inner = ConstraintMatrix.size(0);
                      alpha.set_size(inner);
                      loop_ub = ConstraintMatrix.size(0);
                      for (int i2{0}; i2 < loop_ub; i2++) {
                        alpha[i2] = ConstraintMatrix[i2 + ConstraintMatrix.size
                          (0) * boffset];
                      }

                      nc_tmp = P.size(1);
                      C.set_size(1, P.size(1));
                      for (j = 0; j < nc_tmp; j++) {
                        boffset = j * P.size(0);
                        C[j] = 0.0;
                        for (i1 = 0; i1 < inner; i1++) {
                          C[j] = C[j] + alpha[i1] * P[boffset + i1];
                        }
                      }

                      beta = 0.0;
                      for (int i2{0}; i2 < nc_tmp; i2++) {
                        beta += C[i2] * alpha[i2];
                      }

                      lambda = 1.0 / beta;
                      a.set_size(P.size(0), P.size(1));
                      b_loop_ub_tmp = P.size(0) * P.size(1);
                      for (int i2{0}; i2 < b_loop_ub_tmp; i2++) {
                        a[i2] = lambda * P[i2];
                      }

                      b_H.set_size(inner, inner);
                      for (int i2{0}; i2 < inner; i2++) {
                        for (int i3{0}; i3 < inner; i3++) {
                          b_H[i3 + b_H.size(0) * i2] = alpha[i3] * alpha[i2];
                        }
                      }

                      ::coder::internal::blas::mtimes(a, b_H, AIn);
                      ::coder::internal::blas::mtimes(AIn, P, b_H);
                      if ((H.size(0) == b_H.size(0)) && (H.size(1) == b_H.size(1)))
                      {
                        b_loop_ub_tmp = H.size(0) * H.size(1);
                        for (int i2{0}; i2 < b_loop_ub_tmp; i2++) {
                          H[i2] = H[i2] + b_H[i2];
                        }
                      } else {
                        plus(H, b_H);
                      }

                      b_i++;
                    } else {
                      guard2 = true;
                    }
                  } else {
                    guard2 = true;
                  }
                }

                if (guard2) {
                  double m;
                  double sigma;
                  int exitg1;
                  loop_ub = Hg.size(0);
                  for (int i2{0}; i2 < loop_ub; i2++) {
                    Hg[i2] = -Hg[i2];
                  }

                  boffset = -2;
                  if (ConstraintsOn) {
                    loop_ub = activeSet.size(0);
                    b_x.set_size(activeSet.size(0));
                    for (int i2{0}; i2 < loop_ub; i2++) {
                      b_x[i2] = !activeSet[i2];
                    }

                    flag = false;
                    nx = 1;
                    exitg3 = false;
                    while ((!exitg3) && (nx <= b_x.size(0))) {
                      if (b_x[nx - 1]) {
                        flag = true;
                        exitg3 = true;
                      } else {
                        nx++;
                      }
                    }

                    if (flag) {
                      aoffset = 0;
                      for (nc_tmp = 0; nc_tmp < loop_ub; nc_tmp++) {
                        if (b_x[nc_tmp]) {
                          aoffset++;
                        }
                      }

                      r4.set_size(aoffset);
                      aoffset = 0;
                      for (nc_tmp = 0; nc_tmp < loop_ub; nc_tmp++) {
                        if (b_x[nc_tmp]) {
                          r4[aoffset] = nc_tmp;
                          aoffset++;
                        }
                      }

                      loop_ub = r4.size(0);
                      bIn.set_size(r4.size(0));
                      for (int i2{0}; i2 < loop_ub; i2++) {
                        bIn[i2] = ConstraintBound[r4[i2]];
                      }

                      inner = ConstraintMatrix.size(0);
                      AIn.set_size(inner, r4.size(0));
                      for (int i2{0}; i2 < loop_ub; i2++) {
                        b_loop_ub = ConstraintMatrix.size(0);
                        for (int i3{0}; i3 < b_loop_ub; i3++) {
                          AIn[i3 + AIn.size(0) * i2] = ConstraintMatrix[i3 +
                            ConstraintMatrix.size(0) * r4[i2]];
                        }
                      }

                      c_eml_find(b_x, r1);
                      b_loop_ub = r1.size(0);
                      inactiveConstraintIndices.set_size(r1.size(0));
                      for (int i2{0}; i2 < b_loop_ub; i2++) {
                        inactiveConstraintIndices[i2] = r1[i2];
                      }

                      alpha.set_size(r4.size(0));
                      for (nc_tmp = 0; nc_tmp < loop_ub; nc_tmp++) {
                        alpha[nc_tmp] = 0.0;
                      }

                      for (i1 = 0; i1 < inner; i1++) {
                        for (nc_tmp = 0; nc_tmp < loop_ub; nc_tmp++) {
                          alpha[nc_tmp] = alpha[nc_tmp] + AIn[nc_tmp * AIn.size
                            (0) + i1] * x[i1];
                        }
                      }

                      gradNew.set_size(r4.size(0));
                      for (nc_tmp = 0; nc_tmp < loop_ub; nc_tmp++) {
                        gradNew[nc_tmp] = 0.0;
                      }

                      for (i1 = 0; i1 < inner; i1++) {
                        for (nc_tmp = 0; nc_tmp < loop_ub; nc_tmp++) {
                          gradNew[nc_tmp] = gradNew[nc_tmp] + AIn[nc_tmp *
                            AIn.size(0) + i1] * Hg[i1];
                        }
                      }

                      if (bIn.size(0) == 1) {
                        i1 = alpha.size(0);
                      } else {
                        i1 = bIn.size(0);
                      }

                      if ((bIn.size(0) == alpha.size(0)) && (i1 == gradNew.size
                           (0))) {
                        for (int i2{0}; i2 < loop_ub; i2++) {
                          bIn[i2] = (bIn[i2] - alpha[i2]) / gradNew[i2];
                        }
                      } else {
                        binary_expand_op_12(bIn, alpha, gradNew);
                      }

                      loop_ub = bIn.size(0);
                      b_x.set_size(bIn.size(0));
                      for (int i2{0}; i2 < loop_ub; i2++) {
                        b_x[i2] = (bIn[i2] > 0.0);
                      }

                      c_eml_find(b_x, r1);
                      b_loop_ub = r1.size(0);
                      alpha.set_size(r1.size(0));
                      for (int i2{0}; i2 < b_loop_ub; i2++) {
                        alpha[i2] = r1[i2];
                      }

                      if (alpha.size(0) != 0) {
                        aoffset = 0;
                        for (nc_tmp = 0; nc_tmp < loop_ub; nc_tmp++) {
                          if (b_x[nc_tmp]) {
                            aoffset++;
                          }
                        }

                        r9.set_size(aoffset);
                        aoffset = 0;
                        for (nc_tmp = 0; nc_tmp < loop_ub; nc_tmp++) {
                          if (b_x[nc_tmp]) {
                            r9[aoffset] = nc_tmp;
                            aoffset++;
                          }
                        }

                        loop_ub = r9.size(0);
                        gradNew.set_size(r9.size(0));
                        for (int i2{0}; i2 < loop_ub; i2++) {
                          gradNew[i2] = bIn[r9[i2]];
                        }

                        lambda = ::coder::internal::minimum(gradNew, nx);
                        boffset = inactiveConstraintIndices[static_cast<int>
                          (alpha[nx - 1]) - 1] - 1;
                      } else {
                        lambda = 0.0;
                      }
                    } else {
                      lambda = 0.0;
                    }
                  } else {
                    lambda = 0.0;
                  }

                  if (lambda > 0.0) {
                    b_gamma = std::fmin(1.0, lambda);
                  } else {
                    b_gamma = 1.0;
                  }

                  beta = ArmijoRuleBeta;
                  sigma = ArmijoRuleSigma;
                  if (x.size(0) == Hg.size(0)) {
                    loop_ub = x.size(0);
                    gradNew.set_size(x.size(0));
                    for (int i2{0}; i2 < loop_ub; i2++) {
                      gradNew[i2] = x[i2] + b_gamma * Hg[i2];
                    }

                    costNew = manip::internal::GIKHelpers::computeCost(gradNew,
                      ExtraArgs, P, AIn, &r3);
                  } else {
                    costNew = binary_expand_op_5(x, b_gamma, Hg, this, P, AIn,
                      &r2);
                    r3 = r2;
                  }

                  ExtraArgs = r3;
                  m = 0.0;
                  double b_sigma;
                  do {
                    exitg1 = 0;
                    b_sigma = 0.0;
                    loop_ub = grad.size(0);
                    for (int i2{0}; i2 < loop_ub; i2++) {
                      b_sigma += -sigma * grad[i2] * (b_gamma * Hg[i2]);
                    }

                    if (cost - costNew < b_sigma) {
                      flag = (b_gamma < StepTolerance);
                      if (flag) {
                        exitFlag = NLPSolverExitFlags::StepSizeBelowMinimum;
                        err = manip::internal::GIKHelpers::evaluateSolution(x,
                          ExtraArgs);
                        exitg1 = 1;
                      } else {
                        b_gamma *= beta;
                        m++;
                        if (x.size(0) == Hg.size(0)) {
                          loop_ub = x.size(0);
                          gradNew.set_size(x.size(0));
                          for (int i2{0}; i2 < loop_ub; i2++) {
                            gradNew[i2] = x[i2] + b_gamma * Hg[i2];
                          }

                          costNew = manip::internal::GIKHelpers::computeCost
                            (gradNew, ExtraArgs, P, AIn, &r7);
                        } else {
                          costNew = binary_expand_op_5(x, b_gamma, Hg, this, P,
                            AIn, &r6);
                          r7 = r6;
                        }

                        ExtraArgs = r7;
                      }
                    } else {
                      if (x.size(0) == Hg.size(0)) {
                        loop_ub = x.size(0);
                        xSol.set_size(x.size(0));
                        for (int i2{0}; i2 < loop_ub; i2++) {
                          xSol[i2] = x[i2] + b_gamma * Hg[i2];
                        }
                      } else {
                        binary_expand_op_10(xSol, x, b_gamma, Hg);
                      }

                      manip::internal::GIKHelpers::computeGradient(xSol,
                        ExtraArgs, gradNew);
                      exitg1 = 2;
                    }
                  } while (exitg1 == 0);

                  if (exitg1 == 1) {
                    exitg2 = 1;
                  } else if ((m == 0.0) && (std::abs(b_gamma - lambda) <
                              1.4901161193847656E-8)) {
                    inner = ConstraintMatrix.size(0);
                    alpha.set_size(inner);
                    loop_ub = ConstraintMatrix.size(0);
                    for (int i2{0}; i2 < loop_ub; i2++) {
                      alpha[i2] = ConstraintMatrix[i2 + ConstraintMatrix.size(0)
                        * boffset];
                    }

                    activeSet[boffset] = true;
                    nx = activeSet.size(0);
                    aoffset = 0;
                    for (nc_tmp = 0; nc_tmp < nx; nc_tmp++) {
                      if (activeSet[nc_tmp]) {
                        aoffset++;
                      }
                    }

                    r8.set_size(aoffset);
                    aoffset = 0;
                    for (nc_tmp = 0; nc_tmp < nx; nc_tmp++) {
                      if (activeSet[nc_tmp]) {
                        r8[aoffset] = nc_tmp;
                        aoffset++;
                      }
                    }

                    loop_ub = r8.size(0);
                    A.set_size(ConstraintMatrix.size(0), r8.size(0));
                    for (int i2{0}; i2 < loop_ub; i2++) {
                      b_loop_ub = ConstraintMatrix.size(0);
                      for (int i3{0}; i3 < b_loop_ub; i3++) {
                        A[i3 + A.size(0) * i2] = ConstraintMatrix[i3 +
                          ConstraintMatrix.size(0) * r8[i2]];
                      }
                    }

                    nc_tmp = H.size(1);
                    C.set_size(1, H.size(1));
                    for (j = 0; j < nc_tmp; j++) {
                      boffset = j * H.size(0);
                      C[j] = 0.0;
                      for (i1 = 0; i1 < inner; i1++) {
                        C[j] = C[j] + alpha[i1] * H[boffset + i1];
                      }
                    }

                    beta = 0.0;
                    for (int i2{0}; i2 < nc_tmp; i2++) {
                      beta += C[i2] * alpha[i2];
                    }

                    lambda = 1.0 / beta;
                    b_H.set_size(inner, inner);
                    for (int i2{0}; i2 < inner; i2++) {
                      for (int i3{0}; i3 < inner; i3++) {
                        b_H[i3 + b_H.size(0) * i2] = alpha[i3] * alpha[i2];
                      }
                    }

                    ::coder::internal::blas::mtimes(b_H, H, AIn);
                    ::coder::internal::blas::mtimes(H, AIn, b_H);
                    if ((H.size(0) == b_H.size(0)) && (H.size(1) == b_H.size(1)))
                    {
                      b_loop_ub_tmp = H.size(0) * H.size(1);
                      for (int i2{0}; i2 < b_loop_ub_tmp; i2++) {
                        H[i2] = H[i2] - lambda * b_H[i2];
                      }
                    } else {
                      binary_expand_op_6(H, lambda, b_H);
                    }

                    guard1 = true;
                  } else {
                    if (gradNew.size(0) == grad.size(0)) {
                      loop_ub = gradNew.size(0);
                      grad.set_size(gradNew.size(0));
                      for (int i2{0}; i2 < loop_ub; i2++) {
                        grad[i2] = gradNew[i2] - grad[i2];
                      }
                    } else {
                      minus(grad, gradNew);
                    }

                    loop_ub = grad.size(0);
                    c_A.set_size(1, grad.size(0));
                    for (int i2{0}; i2 < loop_ub; i2++) {
                      c_A[i2] = 0.2 * grad[i2];
                    }

                    nc_tmp = H.size(1);
                    C.set_size(1, H.size(1));
                    for (j = 0; j < nc_tmp; j++) {
                      boffset = j * H.size(0);
                      C[j] = 0.0;
                      for (i1 = 0; i1 < loop_ub; i1++) {
                        C[j] = C[j] + c_A[i1] * H[boffset + i1];
                      }
                    }

                    lambda = 0.0;
                    b_loop_ub_tmp = Hg.size(0);
                    for (int i2{0}; i2 < b_loop_ub_tmp; i2++) {
                      lambda += Hg[i2] * grad[i2];
                    }

                    beta = 0.0;
                    for (int i2{0}; i2 < nc_tmp; i2++) {
                      beta += C[i2] * grad[i2];
                    }

                    if (lambda < beta) {
                      c_A.set_size(1, grad.size(0));
                      for (int i2{0}; i2 < loop_ub; i2++) {
                        c_A[i2] = 0.8 * grad[i2];
                      }

                      C.set_size(1, H.size(1));
                      for (j = 0; j < nc_tmp; j++) {
                        boffset = j * H.size(0);
                        C[j] = 0.0;
                        for (i1 = 0; i1 < loop_ub; i1++) {
                          C[j] = C[j] + c_A[i1] * H[boffset + i1];
                        }
                      }

                      c_A.set_size(1, H.size(1));
                      beta = 0.0;
                      for (j = 0; j < nc_tmp; j++) {
                        boffset = j * H.size(0);
                        c_A[j] = 0.0;
                        for (i1 = 0; i1 < loop_ub; i1++) {
                          c_A[j] = c_A[j] + grad[i1] * H[boffset + i1];
                        }

                        beta += C[j] * grad[j];
                      }

                      b_gamma = 0.0;
                      for (int i2{0}; i2 < nc_tmp; i2++) {
                        b_gamma += c_A[i2] * grad[i2];
                      }

                      lambda = 0.0;
                      for (int i2{0}; i2 < b_loop_ub_tmp; i2++) {
                        lambda += Hg[i2] * grad[i2];
                      }

                      lambda = beta / (b_gamma - lambda);
                    } else {
                      lambda = 1.0;
                    }

                    b_H.set_size(H.size(0), H.size(1));
                    nx = H.size(0) * H.size(1);
                    for (int i2{0}; i2 < nx; i2++) {
                      b_H[i2] = (1.0 - lambda) * H[i2];
                    }

                    nx = b_H.size(0);
                    inner = b_H.size(1);
                    alpha.set_size(b_H.size(0));
                    for (nc_tmp = 0; nc_tmp < nx; nc_tmp++) {
                      alpha[nc_tmp] = 0.0;
                    }

                    for (i1 = 0; i1 < inner; i1++) {
                      aoffset = i1 * b_H.size(0);
                      for (nc_tmp = 0; nc_tmp < nx; nc_tmp++) {
                        alpha[nc_tmp] = alpha[nc_tmp] + b_H[aoffset + nc_tmp] *
                          grad[i1];
                      }
                    }

                    if (Hg.size(0) == alpha.size(0)) {
                      for (int i2{0}; i2 < b_loop_ub_tmp; i2++) {
                        Hg[i2] = lambda * Hg[i2] + alpha[i2];
                      }
                    } else {
                      binary_expand_op_9(Hg, lambda, alpha);
                    }

                    lambda = 0.0;
                    b_loop_ub_tmp = Hg.size(0);
                    for (int i2{0}; i2 < b_loop_ub_tmp; i2++) {
                      lambda += Hg[i2] * grad[i2];
                    }

                    P.set_size(n, n);
                    for (int i2{0}; i2 < loop_ub_tmp; i2++) {
                      P[i2] = 0.0;
                    }

                    if (n > 0) {
                      for (i1 = 0; i1 < n; i1++) {
                        P[i1 + P.size(0) * i1] = 1.0;
                      }
                    }

                    if ((P.size(0) == Hg.size(0)) && (grad.size(0) == P.size(1)))
                    {
                      V.set_size(Hg.size(0), grad.size(0));
                      for (int i2{0}; i2 < loop_ub; i2++) {
                        for (int i3{0}; i3 < b_loop_ub_tmp; i3++) {
                          V[i3 + V.size(0) * i2] = P[i3 + P.size(0) * i2] -
                            Hg[i3] * grad[i2] / lambda;
                        }
                      }
                    } else {
                      binary_expand_op_8(V, P, Hg, grad, lambda);
                    }

                    ::coder::internal::blas::mtimes(V, H, AIn);
                    ::coder::internal::blas::c_mtimes(AIn, V, b_H);
                    if ((b_H.size(0) == Hg.size(0)) && (Hg.size(0) == b_H.size(1)))
                    {
                      loop_ub = Hg.size(0);
                      H.set_size(Hg.size(0), Hg.size(0));
                      for (int i2{0}; i2 < loop_ub; i2++) {
                        for (int i3{0}; i3 < loop_ub; i3++) {
                          H[i3 + H.size(0) * i2] = b_H[i3 + b_H.size(0) * i2] +
                            Hg[i3] * Hg[i2] / lambda;
                        }
                      }
                    } else {
                      binary_expand_op_7(H, b_H, Hg, lambda);
                    }

                    aoffset = H.size(0);
                    nx = H.size(1);
                    if (aoffset <= nx) {
                      nx = aoffset;
                    }

                    P.set_size(H.size(0), H.size(1));
                    b_loop_ub_tmp = H.size(0) * H.size(1);
                    for (int i2{0}; i2 < b_loop_ub_tmp; i2++) {
                      P[i2] = 0.0;
                    }

                    if (nx > 0) {
                      for (i1 = 0; i1 < nx; i1++) {
                        P[i1 + P.size(0) * i1] = 1.0;
                      }
                    }

                    if (P.size(0) == 1) {
                      loop_ub = H.size(0);
                    } else {
                      loop_ub = P.size(0);
                    }

                    if (P.size(1) == 1) {
                      b_loop_ub = H.size(1);
                    } else {
                      b_loop_ub = P.size(1);
                    }

                    b_H.set_size(loop_ub, b_loop_ub);
                    nx = (H.size(0) != 1);
                    aoffset = (H.size(1) != 1);
                    boffset = (P.size(0) != 1);
                    nc_tmp = (P.size(1) != 1);
                    j = 0;
                    b_loop_ub_tmp = 0;
                    for (int i2{0}; i2 < b_loop_ub; i2++) {
                      for (int i3{0}; i3 < loop_ub; i3++) {
                        b_H[i3 + b_H.size(0) * i2] = H[i3 * nx + H.size(0) * j]
                          + 1.4901161193847656E-8 * P[i3 * boffset + P.size(0) *
                          b_loop_ub_tmp];
                      }

                      b_loop_ub_tmp += nc_tmp;
                      j += aoffset;
                    }

                    if (!isPositiveDefinite(b_H)) {
                      exitFlag = NLPSolverExitFlags::
                        HessianNotPositiveSemidefinite;
                      err = manip::internal::GIKHelpers::evaluateSolution(xSol,
                        ExtraArgs);
                      exitg2 = 1;
                    } else {
                      guard1 = true;
                    }
                  }
                }

                if (guard1) {
                  if (searchDirectionInvalid(xSol)) {
                    loop_ub = x.size(0);
                    xSol.set_size(x.size(0));
                    for (i = 0; i < loop_ub; i++) {
                      xSol[i] = x[i];
                    }

                    exitFlag = NLPSolverExitFlags::SearchDirectionInvalid;
                    err = manip::internal::GIKHelpers::evaluateSolution(x,
                      ExtraArgs);
                    exitg2 = 1;
                  } else {
                    loop_ub = xSol.size(0);
                    x.set_size(xSol.size(0));
                    for (int i2{0}; i2 < loop_ub; i2++) {
                      x[i2] = xSol[i2];
                    }

                    loop_ub = gradNew.size(0);
                    grad.set_size(gradNew.size(0));
                    for (int i2{0}; i2 < loop_ub; i2++) {
                      grad[i2] = gradNew[i2];
                    }

                    cost = costNew;
                    b_i++;
                  }
                }
              }
            } else {
              exitFlag = NLPSolverExitFlags::IterationLimitExceeded;
              err = manip::internal::GIKHelpers::evaluateSolution(xSol,
                ExtraArgs);
              iter = MaxNumIterationInternal;
              exitg2 = 1;
            }
          } while (exitg2 == 0);

          return exitFlag;
        }

        //
        // Arguments    : RigidBody *bodyin
        //                const char parentName_data[]
        //                const int parentName_size[2]
        //                CollisionSet &iobj_0
        //                rigidBodyJoint &iobj_1
        //                RigidBody &iobj_2
        // Return Type  : void
        //
      }
    }

    namespace manip
    {
      namespace internal
      {
        void b_RigidBodyTree::addBody(RigidBody *bodyin, const char
          parentName_data[], const int parentName_size[2], CollisionSet &iobj_0,
          rigidBodyJoint &iobj_1, RigidBody &iobj_2)
        {
          static const char b_cv[5]{ 'f', 'i', 'x', 'e', 'd' };

          CharacterVector obj;
          RigidBody *body;
          rigidBodyJoint *jnt;
          double b_index;
          double pid;
          int obj_size[2];
          int loop_ub;
          char obj_data[200];
          bool b_bool;
          obj = bodyin->NameInternal;
          if (obj.Length < 1.0) {
            loop_ub = 0;
          } else {
            loop_ub = static_cast<int>(obj.Length);
          }

          obj_size[0] = 1;
          obj_size[1] = loop_ub;
          if (loop_ub - 1 >= 0) {
            ::std::copy(&obj.Vector[0], &obj.Vector[loop_ub], &obj_data[0]);
          }

          findBodyIndexByName(obj_data, obj_size);
          pid = findBodyIndexByName(parentName_data, parentName_size);
          jnt = bodyin->JointInternal;
          obj = jnt->NameInternal;
          if (obj.Length < 1.0) {
            loop_ub = 0;
          } else {
            loop_ub = static_cast<int>(obj.Length);
          }

          obj_size[0] = 1;
          obj_size[1] = loop_ub;
          if (loop_ub - 1 >= 0) {
            ::std::copy(&obj.Vector[0], &obj.Vector[loop_ub], &obj_data[0]);
          }

          findBodyIndexByJointName(obj_data, obj_size);
          b_index = NumBodies + 1.0;
          body = bodyin->copy((&iobj_0)[0], (&iobj_1)[0], iobj_2);
          Bodies[static_cast<int>(b_index) - 1] = body;
          body->Index = b_index;
          body->ParentIndex = pid;
          body->JointInternal->InTree = true;
          NumBodies++;
          jnt = body->JointInternal;
          obj = jnt->TypeInternal;
          if (obj.Length < 1.0) {
            loop_ub = 0;
          } else {
            loop_ub = static_cast<int>(obj.Length);
          }

          b_bool = false;
          if (loop_ub == 5) {
            loop_ub = 0;
            int exitg1;
            do {
              exitg1 = 0;
              if (loop_ub < 5) {
                if (obj.Vector[loop_ub] != b_cv[loop_ub]) {
                  exitg1 = 1;
                } else {
                  loop_ub++;
                }
              } else {
                b_bool = true;
                exitg1 = 1;
              }
            } while (exitg1 == 0);
          }

          if (!b_bool) {
            NumNonFixedBodies++;
            jnt = body->JointInternal;
            loop_ub = static_cast<int>(body->Index) - 1;
            PositionDoFMap[loop_ub] = PositionNumber + 1.0;
            PositionDoFMap[loop_ub + 12] = PositionNumber + jnt->PositionNumber;
            jnt = body->JointInternal;
            loop_ub = static_cast<int>(body->Index) - 1;
            VelocityDoFMap[loop_ub] = VelocityNumber + 1.0;
            VelocityDoFMap[loop_ub + 12] = VelocityNumber + jnt->VelocityNumber;
          } else {
            loop_ub = static_cast<int>(body->Index);
            PositionDoFMap[loop_ub - 1] = 0.0;
            PositionDoFMap[loop_ub + 11] = -1.0;
            loop_ub = static_cast<int>(body->Index);
            VelocityDoFMap[loop_ub - 1] = 0.0;
            VelocityDoFMap[loop_ub + 11] = -1.0;
          }

          jnt = body->JointInternal;
          PositionNumber += jnt->PositionNumber;
          jnt = body->JointInternal;
          VelocityNumber += jnt->VelocityNumber;
        }

        //
        // Arguments    : RigidBody *body
        //                array<double, 2U> &indices
        // Return Type  : void
        //
        void b_RigidBodyTree::ancestorIndices(RigidBody *body, array<double, 2U>
          &indices)
        {
          unsigned int b_i;
          int loop_ub;
          indices.set_size(1, static_cast<int>(NumBodies + 1.0));
          loop_ub = static_cast<int>(NumBodies + 1.0);
          for (int i{0}; i < loop_ub; i++) {
            indices[i] = 0.0;
          }

          b_i = 2U;
          indices[0] = body->Index;
          while (body->ParentIndex > 0.0) {
            body = Bodies[static_cast<int>(body->ParentIndex) - 1];
            indices[static_cast<int>(b_i) - 1] = body->Index;
            b_i++;
          }

          if (body->Index > 0.0) {
            indices[static_cast<int>(b_i) - 1] = body->ParentIndex;
            b_i++;
          }

          indices.set_size(indices.size(0), static_cast<int>(b_i - 1U));
        }

        //
        // Arguments    : void
        // Return Type  : double
        //
        double b_RigidBodyTree::b_findBodyIndexByName()
        {
          static const char b_cv[8]{ 'b', 'o', 'd', 'y', 'B', 'a', 's', 'e' };

          CharacterVector obj;
          RigidBody *b_obj;
          double bid;
          int exitg1;
          int kstr;
          bool b_bool;
          bid = -1.0;
          obj = Base.NameInternal;
          if (obj.Length < 1.0) {
            kstr = 0;
          } else {
            kstr = static_cast<int>(obj.Length);
          }

          b_bool = false;
          if (kstr == 8) {
            kstr = 0;
            do {
              exitg1 = 0;
              if (kstr < 8) {
                if (obj.Vector[kstr] != b_cv[kstr]) {
                  exitg1 = 1;
                } else {
                  kstr++;
                }
              } else {
                b_bool = true;
                exitg1 = 1;
              }
            } while (exitg1 == 0);
          }

          if (b_bool) {
            bid = 0.0;
          } else {
            double d;
            int i;
            bool exitg2;
            d = NumBodies;
            i = 0;
            exitg2 = false;
            while ((!exitg2) && (i <= static_cast<int>(d) - 1)) {
              b_obj = Bodies[i];
              obj = b_obj->NameInternal;
              if (obj.Length < 1.0) {
                kstr = 0;
              } else {
                kstr = static_cast<int>(obj.Length);
              }

              b_bool = false;
              if (kstr == 8) {
                kstr = 0;
                do {
                  exitg1 = 0;
                  if (kstr < 8) {
                    if (obj.Vector[kstr] != b_cv[kstr]) {
                      exitg1 = 1;
                    } else {
                      kstr++;
                    }
                  } else {
                    b_bool = true;
                    exitg1 = 1;
                  }
                } while (exitg1 == 0);
              }

              if (b_bool) {
                bid = static_cast<double>(i) + 1.0;
                exitg2 = true;
              } else {
                i++;
              }
            }
          }

          return bid;
        }

        //
        // Arguments    : const char bodyname[6]
        // Return Type  : double
        //
        double b_RigidBodyTree::b_findBodyIndexByName(const char bodyname[6])
        {
          CharacterVector obj;
          RigidBody *b_obj;
          double bid;
          int exitg1;
          int kstr;
          bool b_bool;
          bid = -1.0;
          obj = Base.NameInternal;
          if (obj.Length < 1.0) {
            kstr = 0;
          } else {
            kstr = static_cast<int>(obj.Length);
          }

          b_bool = false;
          if (kstr == 6) {
            kstr = 0;
            do {
              exitg1 = 0;
              if (kstr < 6) {
                if (obj.Vector[kstr] != bodyname[kstr]) {
                  exitg1 = 1;
                } else {
                  kstr++;
                }
              } else {
                b_bool = true;
                exitg1 = 1;
              }
            } while (exitg1 == 0);
          }

          if (b_bool) {
            bid = 0.0;
          } else {
            double d;
            int i;
            bool exitg2;
            d = NumBodies;
            i = 0;
            exitg2 = false;
            while ((!exitg2) && (i <= static_cast<int>(d) - 1)) {
              b_obj = Bodies[i];
              obj = b_obj->NameInternal;
              if (obj.Length < 1.0) {
                kstr = 0;
              } else {
                kstr = static_cast<int>(obj.Length);
              }

              b_bool = false;
              if (kstr == 6) {
                kstr = 0;
                do {
                  exitg1 = 0;
                  if (kstr < 6) {
                    if (obj.Vector[kstr] != bodyname[kstr]) {
                      exitg1 = 1;
                    } else {
                      kstr++;
                    }
                  } else {
                    b_bool = true;
                    exitg1 = 1;
                  }
                } while (exitg1 == 0);
              }

              if (b_bool) {
                bid = static_cast<double>(i) + 1.0;
                exitg2 = true;
              } else {
                i++;
              }
            }
          }

          return bid;
        }

        //
        // Arguments    : const char bodyname[10]
        // Return Type  : double
        //
        double b_RigidBodyTree::c_findBodyIndexByName(const char bodyname[10])
        {
          CharacterVector obj;
          RigidBody *b_obj;
          double bid;
          int exitg1;
          int kstr;
          bool b_bool;
          bid = -1.0;
          obj = Base.NameInternal;
          if (obj.Length < 1.0) {
            kstr = 0;
          } else {
            kstr = static_cast<int>(obj.Length);
          }

          b_bool = false;
          if (kstr == 10) {
            kstr = 0;
            do {
              exitg1 = 0;
              if (kstr < 10) {
                if (obj.Vector[kstr] != bodyname[kstr]) {
                  exitg1 = 1;
                } else {
                  kstr++;
                }
              } else {
                b_bool = true;
                exitg1 = 1;
              }
            } while (exitg1 == 0);
          }

          if (b_bool) {
            bid = 0.0;
          } else {
            double d;
            int i;
            bool exitg2;
            d = NumBodies;
            i = 0;
            exitg2 = false;
            while ((!exitg2) && (i <= static_cast<int>(d) - 1)) {
              b_obj = Bodies[i];
              obj = b_obj->NameInternal;
              if (obj.Length < 1.0) {
                kstr = 0;
              } else {
                kstr = static_cast<int>(obj.Length);
              }

              b_bool = false;
              if (kstr == 10) {
                kstr = 0;
                do {
                  exitg1 = 0;
                  if (kstr < 10) {
                    if (obj.Vector[kstr] != bodyname[kstr]) {
                      exitg1 = 1;
                    } else {
                      kstr++;
                    }
                  } else {
                    b_bool = true;
                    exitg1 = 1;
                  }
                } while (exitg1 == 0);
              }

              if (b_bool) {
                bid = static_cast<double>(i) + 1.0;
                exitg2 = true;
              } else {
                i++;
              }
            }
          }

          return bid;
        }

        //
        // Arguments    : CollisionSet *querySet
        //                double &minSepDist
        //                double witnessPts[6]
        // Return Type  : bool
        //
        bool CollisionSet::checkCollision(CollisionSet *querySet, double
          &minSepDist, double witnessPts[6])
        {
          CollisionGeometry geom;
          CollisionGeometry obj;
          double d;
          int b_i;
          bool exitg2;
          bool inCollision;
          inCollision = false;
          minSepDist = rtInf;
          for (int i{0}; i < 6; i++) {
            witnessPts[i] = rtInf;
          }

          d = Size;
          b_i = 0;
          exitg2 = false;
          while ((!exitg2) && (b_i <= static_cast<int>(d) - 1)) {
            double d1;
            int exitg1;
            int j;
            d1 = querySet->Size;
            j = 0;
            do {
              exitg1 = 0;
              if (j <= static_cast<int>(d1) - 1) {
                double b_obj[9];
                double quaternion1[4];
                double p1Vec[3];
                double p2Vec[3];
                double position1[3];
                double position2[3];
                double sepDist;
                int obj_tmp;
                obj = CollisionGeometries[b_i];
                geom = querySet->CollisionGeometries[j];
                position1[0] = obj.WorldPose[12];
                position1[1] = obj.WorldPose[13];
                position1[2] = obj.WorldPose[14];
                for (int i{0}; i < 3; i++) {
                  obj_tmp = i << 2;
                  b_obj[3 * i] = obj.WorldPose[obj_tmp];
                  b_obj[3 * i + 1] = obj.WorldPose[obj_tmp + 1];
                  b_obj[3 * i + 2] = obj.WorldPose[obj_tmp + 2];
                }

                core::internal::b_rotm2quat(b_obj, quaternion1);
                position2[0] = geom.WorldPose[12];
                position2[1] = geom.WorldPose[13];
                position2[2] = geom.WorldPose[14];
                for (int i{0}; i < 3; i++) {
                  obj_tmp = i << 2;
                  b_obj[3 * i] = geom.WorldPose[obj_tmp];
                  b_obj[3 * i + 1] = geom.WorldPose[obj_tmp + 1];
                  b_obj[3 * i + 2] = geom.WorldPose[obj_tmp + 2];
                }

                double quaternion2[4];
                double status;
                core::internal::b_rotm2quat(b_obj, quaternion2);
                sepDist = 0.0;
                p1Vec[0] = 0.0;
                p2Vec[0] = 0.0;
                p1Vec[1] = 0.0;
                p2Vec[1] = 0.0;
                p1Vec[2] = 0.0;
                p2Vec[2] = 0.0;
                status = collisioncodegen_intersect(obj.CollisionPrimitive,
                  &position1[0], &quaternion1[0], geom.CollisionPrimitive,
                  &position2[0], &quaternion2[0], true, &p1Vec[0], &p2Vec[0],
                  &sepDist);
                inCollision = (status != 0.0);
                if (inCollision) {
                  minSepDist = rtNaN;
                  for (int i{0}; i < 6; i++) {
                    witnessPts[i] = rtNaN;
                  }

                  exitg1 = 1;
                } else {
                  if (sepDist < minSepDist) {
                    minSepDist = sepDist;
                    witnessPts[0] = p1Vec[0];
                    witnessPts[3] = p2Vec[0];
                    witnessPts[1] = p1Vec[1];
                    witnessPts[4] = p2Vec[1];
                    witnessPts[2] = p1Vec[2];
                    witnessPts[5] = p2Vec[2];
                  }

                  j++;
                }
              } else {
                b_i++;
                exitg1 = 2;
              }
            } while (exitg1 == 0);

            if (exitg1 == 1) {
              exitg2 = true;
            }
          }

          return inCollision;
        }

        //
        // Arguments    : const cell_wrap_41 tTree_data[]
        //                const double baseTform[16]
        //                bool isExhaustive
        //                const double skippedSelfCollisionType[24]
        //                array<double, 2U> &separationDist
        //                array<double, 2U> &witnessPts
        // Return Type  : bool
        //
        bool b_RigidBodyTree::checkSelfCollision(const cell_wrap_41 tTree_data[],
          const double baseTform[16], bool isExhaustive, const double
          skippedSelfCollisionType[24], array<double, 2U> &separationDist, array<
          double, 2U> &witnessPts)
        {
          CollisionGeometry b_obj;
          CollisionSet *obj;
          RigidBody *bodyI;
          RigidBody *bodyJ;
          anonymous_function b_this;
          anonymous_function c_this;
          int k;
          bool exitg1;
          bool isColliding;
          bool y;
          y = true;
          k = 0;
          exitg1 = false;
          while ((!exitg1) && (k < 24)) {
            if (!(skippedSelfCollisionType[k] == 0.0)) {
              y = false;
              exitg1 = true;
            } else {
              k++;
            }
          }

          if (y) {
            double numBodies;
            int b_i;
            int i;
            int i1;
            isColliding = false;
            numBodies = NumBodies;
            separationDist.set_size(static_cast<int>(numBodies + 1.0),
              static_cast<int>(numBodies + 1.0));
            k = static_cast<int>(numBodies + 1.0) * static_cast<int>(numBodies +
              1.0);
            for (i = 0; i < k; i++) {
              separationDist[i] = rtInf;
            }

            i = static_cast<int>(3.0 * (numBodies + 1.0));
            i1 = static_cast<int>(2.0 * (numBodies + 1.0));
            witnessPts.set_size(i, i1);
            k = i * i1;
            for (i = 0; i < k; i++) {
              witnessPts[i] = rtInf;
            }

            b_i = 0;
            int exitg3;
            do {
              exitg3 = 0;
              if (b_i <= static_cast<int>(numBodies) - 1) {
                if (isColliding && (!isExhaustive)) {
                  exitg3 = 1;
                } else {
                  double sDist;
                  int c_i;
                  int i3;
                  bodyI = Bodies[b_i];
                  obj = bodyI->CollisionsInternal;
                  sDist = obj->Size;
                  i = static_cast<int>(sDist);
                  for (c_i = 0; c_i < i; c_i++) {
                    b_obj = obj->CollisionGeometries[c_i];
                    for (i1 = 0; i1 < 4; i1++) {
                      for (int i2{0}; i2 < 4; i2++) {
                        i3 = i2 << 2;
                        k = i1 + i3;
                        b_obj.WorldPose[k] = 0.0;
                        b_obj.WorldPose[k] += tTree_data[b_i].f1[i1] *
                          b_obj.LocalPose[i3];
                        b_obj.WorldPose[k] += tTree_data[b_i].f1[i1 + 4] *
                          b_obj.LocalPose[i3 + 1];
                        b_obj.WorldPose[k] += tTree_data[b_i].f1[i1 + 8] *
                          b_obj.LocalPose[i3 + 2];
                        b_obj.WorldPose[k] += tTree_data[b_i].f1[i1 + 12] *
                          b_obj.LocalPose[i3 + 3];
                      }
                    }

                    obj->CollisionGeometries[c_i] = b_obj;
                  }

                  i = static_cast<int>(numBodies + (1.0 - ((static_cast<double>
                    (b_i) + 1.0) + 1.0)));
                  for (int j{0}; j < i; j++) {
                    unsigned int b_j;
                    b_j = (static_cast<unsigned int>(b_i) + static_cast<unsigned
                           int>(j)) + 2U;
                    bodyJ = Bodies[static_cast<int>(b_j) - 1];
                    y = (Bodies[static_cast<int>(b_j) - 1]->ParentIndex ==
                         static_cast<double>(b_i) + 1.0);
                    if (!y) {
                      double wPts[6];
                      int witnessPts_tmp;
                      obj = bodyJ->CollisionsInternal;
                      sDist = obj->Size;
                      i1 = static_cast<int>(sDist);
                      for (c_i = 0; c_i < i1; c_i++) {
                        b_obj = obj->CollisionGeometries[c_i];
                        for (int i2{0}; i2 < 4; i2++) {
                          for (i3 = 0; i3 < 4; i3++) {
                            k = i3 << 2;
                            witnessPts_tmp = i2 + k;
                            b_obj.WorldPose[witnessPts_tmp] = 0.0;
                            b_obj.WorldPose[witnessPts_tmp] += tTree_data[
                              static_cast<int>(b_j) - 1].f1[i2] *
                              b_obj.LocalPose[k];
                            b_obj.WorldPose[witnessPts_tmp] += tTree_data[
                              static_cast<int>(b_j) - 1].f1[i2 + 4] *
                              b_obj.LocalPose[k + 1];
                            b_obj.WorldPose[witnessPts_tmp] += tTree_data[
                              static_cast<int>(b_j) - 1].f1[i2 + 8] *
                              b_obj.LocalPose[k + 2];
                            b_obj.WorldPose[witnessPts_tmp] += tTree_data[
                              static_cast<int>(b_j) - 1].f1[i2 + 12] *
                              b_obj.LocalPose[k + 3];
                          }
                        }

                        obj->CollisionGeometries[c_i] = b_obj;
                      }

                      y = bodyI->CollisionsInternal->checkCollision
                        (bodyJ->CollisionsInternal, sDist, wPts);
                      if (isColliding || y) {
                        isColliding = true;
                      }

                      c_i = b_i * 3;
                      k = (static_cast<int>(b_j) - 1) << 1;
                      for (i1 = 0; i1 < 2; i1++) {
                        witnessPts_tmp = i1 + k;
                        witnessPts[c_i + witnessPts.size(0) * witnessPts_tmp] =
                          wPts[3 * i1];
                        witnessPts[(c_i + witnessPts.size(0) * witnessPts_tmp) +
                          1] = wPts[3 * i1 + 1];
                        witnessPts[(c_i + witnessPts.size(0) * witnessPts_tmp) +
                          2] = wPts[3 * i1 + 2];
                      }

                      k = (static_cast<int>(b_j) - 1) * 3;
                      c_i = b_i << 1;
                      for (i1 = 0; i1 < 2; i1++) {
                        witnessPts_tmp = i1 + c_i;
                        witnessPts[k + witnessPts.size(0) * witnessPts_tmp] =
                          wPts[3 * i1];
                        witnessPts[(k + witnessPts.size(0) * witnessPts_tmp) + 1]
                          = wPts[3 * i1 + 1];
                        witnessPts[(k + witnessPts.size(0) * witnessPts_tmp) + 2]
                          = wPts[3 * i1 + 2];
                      }

                      separationDist[b_i + separationDist.size(0) * (
                        static_cast<int>(b_j) - 1)] = sDist;
                      separationDist[(static_cast<int>(b_j) +
                                      separationDist.size(0) * b_i) - 1] = sDist;
                    }
                  }

                  b_i++;
                }
              } else {
                double b_numBodies;
                double sDist;
                int i3;
                int j;
                obj = Base.CollisionsInternal;
                sDist = obj->Size;
                i = static_cast<int>(sDist);
                for (b_i = 0; b_i < i; b_i++) {
                  b_obj = obj->CollisionGeometries[b_i];
                  for (i1 = 0; i1 < 4; i1++) {
                    double d;
                    double d1;
                    sDist = baseTform[i1];
                    b_numBodies = baseTform[i1 + 4];
                    d = baseTform[i1 + 8];
                    d1 = baseTform[i1 + 12];
                    for (int i2{0}; i2 < 4; i2++) {
                      i3 = i2 << 2;
                      k = i1 + i3;
                      b_obj.WorldPose[k] = 0.0;
                      b_obj.WorldPose[k] += sDist * b_obj.LocalPose[i3];
                      b_obj.WorldPose[k] += b_numBodies * b_obj.LocalPose[i3 + 1];
                      b_obj.WorldPose[k] += d * b_obj.LocalPose[i3 + 2];
                      b_obj.WorldPose[k] += d1 * b_obj.LocalPose[i3 + 3];
                    }
                  }

                  obj->CollisionGeometries[b_i] = b_obj;
                }

                j = 0;
                while ((j <= static_cast<int>(numBodies) - 1) && ((!isColliding)
                        || isExhaustive)) {
                  bodyJ = Bodies[j];
                  y = (Bodies[j]->ParentIndex == 0.0);
                  if (!y) {
                    double wPts[6];
                    int witnessPts_tmp;
                    obj = bodyJ->CollisionsInternal;
                    sDist = obj->Size;
                    i = static_cast<int>(sDist);
                    for (b_i = 0; b_i < i; b_i++) {
                      b_obj = obj->CollisionGeometries[b_i];
                      for (i1 = 0; i1 < 4; i1++) {
                        for (int i2{0}; i2 < 4; i2++) {
                          i3 = i2 << 2;
                          k = i1 + i3;
                          b_obj.WorldPose[k] = 0.0;
                          b_obj.WorldPose[k] += tTree_data[j].f1[i1] *
                            b_obj.LocalPose[i3];
                          b_obj.WorldPose[k] += tTree_data[j].f1[i1 + 4] *
                            b_obj.LocalPose[i3 + 1];
                          b_obj.WorldPose[k] += tTree_data[j].f1[i1 + 8] *
                            b_obj.LocalPose[i3 + 2];
                          b_obj.WorldPose[k] += tTree_data[j].f1[i1 + 12] *
                            b_obj.LocalPose[i3 + 3];
                        }
                      }

                      obj->CollisionGeometries[b_i] = b_obj;
                    }

                    y = Base.CollisionsInternal->checkCollision
                      (bodyJ->CollisionsInternal, sDist, wPts);
                    if (isColliding || y) {
                      isColliding = true;
                    }

                    b_numBodies = ((numBodies + 1.0) - 1.0) * 3.0 + 1.0;
                    k = j << 1;
                    for (i = 0; i < 2; i++) {
                      witnessPts_tmp = i + k;
                      witnessPts[(static_cast<int>(b_numBodies) +
                                  witnessPts.size(0) * witnessPts_tmp) - 1] =
                        wPts[3 * i];
                      witnessPts[(static_cast<int>(b_numBodies + 1.0) +
                                  witnessPts.size(0) * witnessPts_tmp) - 1] =
                        wPts[3 * i + 1];
                      witnessPts[(static_cast<int>(b_numBodies + 2.0) +
                                  witnessPts.size(0) * witnessPts_tmp) - 1] =
                        wPts[3 * i + 2];
                    }

                    k = j * 3;
                    b_numBodies = ((numBodies + 1.0) - 1.0) * 2.0 + 1.0;
                    for (i = 0; i < 2; i++) {
                      witnessPts_tmp = static_cast<int>(b_numBodies +
                        static_cast<double>(i)) - 1;
                      witnessPts[k + witnessPts.size(0) * witnessPts_tmp] =
                        wPts[3 * i];
                      witnessPts[(k + witnessPts.size(0) * witnessPts_tmp) + 1] =
                        wPts[3 * i + 1];
                      witnessPts[(k + witnessPts.size(0) * witnessPts_tmp) + 2] =
                        wPts[3 * i + 2];
                    }

                    separationDist[(static_cast<int>(numBodies + 1.0) +
                                    separationDist.size(0) * j) - 1] = sDist;
                    separationDist[j + separationDist.size(0) * (static_cast<int>
                      (numBodies + 1.0) - 1)] = sDist;
                  }

                  j++;
                }

                exitg3 = 1;
              }
            } while (exitg3 == 0);
          } else {
            y = true;
            k = 0;
            exitg1 = false;
            while ((!exitg1) && (k < 24)) {
              if (!(skippedSelfCollisionType[k] == 1.0)) {
                y = false;
                exitg1 = true;
              } else {
                k++;
              }
            }

            if (y) {
              double numBodies;
              int b_i;
              int i;
              int i1;
              isColliding = false;
              numBodies = NumBodies;
              separationDist.set_size(static_cast<int>(numBodies + 1.0),
                static_cast<int>(numBodies + 1.0));
              k = static_cast<int>(numBodies + 1.0) * static_cast<int>(numBodies
                + 1.0);
              for (i = 0; i < k; i++) {
                separationDist[i] = rtInf;
              }

              i = static_cast<int>(3.0 * (numBodies + 1.0));
              i1 = static_cast<int>(2.0 * (numBodies + 1.0));
              witnessPts.set_size(i, i1);
              k = i * i1;
              for (i = 0; i < k; i++) {
                witnessPts[i] = rtInf;
              }

              b_i = 0;
              int exitg2;
              do {
                exitg2 = 0;
                if (b_i <= static_cast<int>(numBodies) - 1) {
                  if (isColliding && (!isExhaustive)) {
                    exitg2 = 1;
                  } else {
                    double sDist;
                    int c_i;
                    int i3;
                    bodyI = Bodies[b_i];
                    obj = bodyI->CollisionsInternal;
                    sDist = obj->Size;
                    i = static_cast<int>(sDist);
                    for (c_i = 0; c_i < i; c_i++) {
                      b_obj = obj->CollisionGeometries[c_i];
                      for (i1 = 0; i1 < 4; i1++) {
                        for (int i2{0}; i2 < 4; i2++) {
                          i3 = i2 << 2;
                          k = i1 + i3;
                          b_obj.WorldPose[k] = 0.0;
                          b_obj.WorldPose[k] += tTree_data[b_i].f1[i1] *
                            b_obj.LocalPose[i3];
                          b_obj.WorldPose[k] += tTree_data[b_i].f1[i1 + 4] *
                            b_obj.LocalPose[i3 + 1];
                          b_obj.WorldPose[k] += tTree_data[b_i].f1[i1 + 8] *
                            b_obj.LocalPose[i3 + 2];
                          b_obj.WorldPose[k] += tTree_data[b_i].f1[i1 + 12] *
                            b_obj.LocalPose[i3 + 3];
                        }
                      }

                      obj->CollisionGeometries[c_i] = b_obj;
                    }

                    i = static_cast<int>(numBodies + (1.0 - ((static_cast<double>
                      (b_i) + 1.0) + 1.0)));
                    for (int j{0}; j < i; j++) {
                      unsigned int b_j;
                      b_j = (static_cast<unsigned int>(b_i) + static_cast<
                             unsigned int>(j)) + 2U;
                      bodyJ = Bodies[static_cast<int>(b_j) - 1];
                      if (b_j != static_cast<unsigned int>(b_i + 2)) {
                        double wPts[6];
                        int witnessPts_tmp;
                        obj = bodyJ->CollisionsInternal;
                        sDist = obj->Size;
                        i1 = static_cast<int>(sDist);
                        for (c_i = 0; c_i < i1; c_i++) {
                          b_obj = obj->CollisionGeometries[c_i];
                          for (int i2{0}; i2 < 4; i2++) {
                            for (i3 = 0; i3 < 4; i3++) {
                              k = i3 << 2;
                              witnessPts_tmp = i2 + k;
                              b_obj.WorldPose[witnessPts_tmp] = 0.0;
                              b_obj.WorldPose[witnessPts_tmp] += tTree_data[
                                static_cast<int>(b_j) - 1].f1[i2] *
                                b_obj.LocalPose[k];
                              b_obj.WorldPose[witnessPts_tmp] += tTree_data[
                                static_cast<int>(b_j) - 1].f1[i2 + 4] *
                                b_obj.LocalPose[k + 1];
                              b_obj.WorldPose[witnessPts_tmp] += tTree_data[
                                static_cast<int>(b_j) - 1].f1[i2 + 8] *
                                b_obj.LocalPose[k + 2];
                              b_obj.WorldPose[witnessPts_tmp] += tTree_data[
                                static_cast<int>(b_j) - 1].f1[i2 + 12] *
                                b_obj.LocalPose[k + 3];
                            }
                          }

                          obj->CollisionGeometries[c_i] = b_obj;
                        }

                        y = bodyI->CollisionsInternal->checkCollision
                          (bodyJ->CollisionsInternal, sDist, wPts);
                        if (isColliding || y) {
                          isColliding = true;
                        }

                        c_i = b_i * 3;
                        k = (static_cast<int>(b_j) - 1) << 1;
                        for (i1 = 0; i1 < 2; i1++) {
                          witnessPts_tmp = i1 + k;
                          witnessPts[c_i + witnessPts.size(0) * witnessPts_tmp] =
                            wPts[3 * i1];
                          witnessPts[(c_i + witnessPts.size(0) * witnessPts_tmp)
                            + 1] = wPts[3 * i1 + 1];
                          witnessPts[(c_i + witnessPts.size(0) * witnessPts_tmp)
                            + 2] = wPts[3 * i1 + 2];
                        }

                        k = (static_cast<int>(b_j) - 1) * 3;
                        c_i = b_i << 1;
                        for (i1 = 0; i1 < 2; i1++) {
                          witnessPts_tmp = i1 + c_i;
                          witnessPts[k + witnessPts.size(0) * witnessPts_tmp] =
                            wPts[3 * i1];
                          witnessPts[(k + witnessPts.size(0) * witnessPts_tmp) +
                            1] = wPts[3 * i1 + 1];
                          witnessPts[(k + witnessPts.size(0) * witnessPts_tmp) +
                            2] = wPts[3 * i1 + 2];
                        }

                        separationDist[b_i + separationDist.size(0) * (
                          static_cast<int>(b_j) - 1)] = sDist;
                        separationDist[(static_cast<int>(b_j) +
                                        separationDist.size(0) * b_i) - 1] =
                          sDist;
                      }
                    }

                    b_i++;
                  }
                } else {
                  double b_numBodies;
                  double sDist;
                  int i3;
                  int j;
                  obj = Base.CollisionsInternal;
                  sDist = obj->Size;
                  i = static_cast<int>(sDist);
                  for (b_i = 0; b_i < i; b_i++) {
                    b_obj = obj->CollisionGeometries[b_i];
                    for (i1 = 0; i1 < 4; i1++) {
                      double d;
                      double d1;
                      sDist = baseTform[i1];
                      b_numBodies = baseTform[i1 + 4];
                      d = baseTform[i1 + 8];
                      d1 = baseTform[i1 + 12];
                      for (int i2{0}; i2 < 4; i2++) {
                        i3 = i2 << 2;
                        k = i1 + i3;
                        b_obj.WorldPose[k] = 0.0;
                        b_obj.WorldPose[k] += sDist * b_obj.LocalPose[i3];
                        b_obj.WorldPose[k] += b_numBodies * b_obj.LocalPose[i3 +
                          1];
                        b_obj.WorldPose[k] += d * b_obj.LocalPose[i3 + 2];
                        b_obj.WorldPose[k] += d1 * b_obj.LocalPose[i3 + 3];
                      }
                    }

                    obj->CollisionGeometries[b_i] = b_obj;
                  }

                  j = 0;
                  while ((j <= static_cast<int>(numBodies) - 1) &&
                         ((!isColliding) || isExhaustive)) {
                    bodyJ = Bodies[j];
                    if (j + 1 != 1) {
                      double wPts[6];
                      int witnessPts_tmp;
                      obj = bodyJ->CollisionsInternal;
                      sDist = obj->Size;
                      i = static_cast<int>(sDist);
                      for (b_i = 0; b_i < i; b_i++) {
                        b_obj = obj->CollisionGeometries[b_i];
                        for (i1 = 0; i1 < 4; i1++) {
                          for (int i2{0}; i2 < 4; i2++) {
                            i3 = i2 << 2;
                            k = i1 + i3;
                            b_obj.WorldPose[k] = 0.0;
                            b_obj.WorldPose[k] += tTree_data[j].f1[i1] *
                              b_obj.LocalPose[i3];
                            b_obj.WorldPose[k] += tTree_data[j].f1[i1 + 4] *
                              b_obj.LocalPose[i3 + 1];
                            b_obj.WorldPose[k] += tTree_data[j].f1[i1 + 8] *
                              b_obj.LocalPose[i3 + 2];
                            b_obj.WorldPose[k] += tTree_data[j].f1[i1 + 12] *
                              b_obj.LocalPose[i3 + 3];
                          }
                        }

                        obj->CollisionGeometries[b_i] = b_obj;
                      }

                      y = Base.CollisionsInternal->checkCollision
                        (bodyJ->CollisionsInternal, sDist, wPts);
                      if (isColliding || y) {
                        isColliding = true;
                      }

                      b_numBodies = ((numBodies + 1.0) - 1.0) * 3.0 + 1.0;
                      k = j << 1;
                      for (i = 0; i < 2; i++) {
                        witnessPts_tmp = i + k;
                        witnessPts[(static_cast<int>(b_numBodies) +
                                    witnessPts.size(0) * witnessPts_tmp) - 1] =
                          wPts[3 * i];
                        witnessPts[(static_cast<int>(b_numBodies + 1.0) +
                                    witnessPts.size(0) * witnessPts_tmp) - 1] =
                          wPts[3 * i + 1];
                        witnessPts[(static_cast<int>(b_numBodies + 2.0) +
                                    witnessPts.size(0) * witnessPts_tmp) - 1] =
                          wPts[3 * i + 2];
                      }

                      k = j * 3;
                      b_numBodies = ((numBodies + 1.0) - 1.0) * 2.0 + 1.0;
                      for (i = 0; i < 2; i++) {
                        witnessPts_tmp = static_cast<int>(b_numBodies +
                          static_cast<double>(i)) - 1;
                        witnessPts[k + witnessPts.size(0) * witnessPts_tmp] =
                          wPts[3 * i];
                        witnessPts[(k + witnessPts.size(0) * witnessPts_tmp) + 1]
                          = wPts[3 * i + 1];
                        witnessPts[(k + witnessPts.size(0) * witnessPts_tmp) + 2]
                          = wPts[3 * i + 2];
                      }

                      separationDist[(static_cast<int>(numBodies + 1.0) +
                                      separationDist.size(0) * j) - 1] = sDist;
                      separationDist[j + separationDist.size(0) * (static_cast<
                        int>(numBodies + 1.0) - 1)] = sDist;
                    }

                    j++;
                  }

                  exitg2 = 1;
                }
              } while (exitg2 == 0);
            } else {
              b_this.workspace.obj = this;
              ::std::copy(&skippedSelfCollisionType[0],
                          &skippedSelfCollisionType[24],
                          &b_this.workspace.idxpairs[0]);
              c_this = b_this;
              isColliding = checkSelfCollision_(tTree_data, baseTform,
                isExhaustive, c_this, separationDist, witnessPts);
            }
          }

          return isColliding;
        }

        //
        // Arguments    : const cell_wrap_41 tTree_data[]
        //                const double baseTform[16]
        //                bool isExhaustive
        //                const anonymous_function &skipCollisionFcn
        //                array<double, 2U> &separationDist
        //                array<double, 2U> &witnessPts
        // Return Type  : bool
        //
        bool b_RigidBodyTree::checkSelfCollision_(const cell_wrap_41 tTree_data[],
          const double baseTform[16], bool isExhaustive, const
          anonymous_function &skipCollisionFcn, array<double, 2U>
          &separationDist, array<double, 2U> &witnessPts)
        {
          CollisionGeometry b_obj;
          CollisionSet *obj;
          RigidBody *bodyI;
          RigidBody *bodyJ;
          double numBodies;
          int b_i;
          int i;
          int i1;
          int loop_ub_tmp;
          bool isColliding;
          isColliding = false;
          numBodies = NumBodies;
          separationDist.set_size(static_cast<int>(numBodies + 1.0),
            static_cast<int>(numBodies + 1.0));
          loop_ub_tmp = static_cast<int>(numBodies + 1.0) * static_cast<int>
            (numBodies + 1.0);
          for (i = 0; i < loop_ub_tmp; i++) {
            separationDist[i] = rtInf;
          }

          i = static_cast<int>(3.0 * (numBodies + 1.0));
          i1 = static_cast<int>(2.0 * (numBodies + 1.0));
          witnessPts.set_size(i, i1);
          loop_ub_tmp = i * i1;
          for (i = 0; i < loop_ub_tmp; i++) {
            witnessPts[i] = rtInf;
          }

          b_i = 0;
          int exitg1;
          do {
            exitg1 = 0;
            if (b_i <= static_cast<int>(numBodies) - 1) {
              if (isColliding && (!isExhaustive)) {
                exitg1 = 1;
              } else {
                double sDist;
                int c_i;
                int i3;
                bodyI = Bodies[b_i];
                obj = bodyI->CollisionsInternal;
                sDist = obj->Size;
                i = static_cast<int>(sDist);
                for (c_i = 0; c_i < i; c_i++) {
                  b_obj = obj->CollisionGeometries[c_i];
                  for (i1 = 0; i1 < 4; i1++) {
                    for (int i2{0}; i2 < 4; i2++) {
                      i3 = i2 << 2;
                      loop_ub_tmp = i1 + i3;
                      b_obj.WorldPose[loop_ub_tmp] = 0.0;
                      b_obj.WorldPose[loop_ub_tmp] += tTree_data[b_i].f1[i1] *
                        b_obj.LocalPose[i3];
                      b_obj.WorldPose[loop_ub_tmp] += tTree_data[b_i].f1[i1 + 4]
                        * b_obj.LocalPose[i3 + 1];
                      b_obj.WorldPose[loop_ub_tmp] += tTree_data[b_i].f1[i1 + 8]
                        * b_obj.LocalPose[i3 + 2];
                      b_obj.WorldPose[loop_ub_tmp] += tTree_data[b_i].f1[i1 + 12]
                        * b_obj.LocalPose[i3 + 3];
                    }
                  }

                  obj->CollisionGeometries[c_i] = b_obj;
                }

                i = static_cast<int>(numBodies + (1.0 - ((static_cast<double>
                  (b_i) + 1.0) + 1.0)));
                for (int j{0}; j < i; j++) {
                  unsigned int b_j;
                  bool varargout_1;
                  b_j = (static_cast<unsigned int>(b_i) + static_cast<unsigned
                         int>(j)) + 2U;
                  bodyJ = Bodies[static_cast<int>(b_j) - 1];
                  varargout_1 = b_RigidBodyTree::checkSelfCollision_anonFcn3
                    (skipCollisionFcn.workspace.idxpairs, static_cast<double>
                     (b_i) + 1.0, static_cast<double>(b_j));
                  if (!varargout_1) {
                    double wPts[6];
                    int witnessPts_tmp;
                    obj = bodyJ->CollisionsInternal;
                    sDist = obj->Size;
                    i1 = static_cast<int>(sDist);
                    for (c_i = 0; c_i < i1; c_i++) {
                      b_obj = obj->CollisionGeometries[c_i];
                      for (int i2{0}; i2 < 4; i2++) {
                        for (i3 = 0; i3 < 4; i3++) {
                          loop_ub_tmp = i3 << 2;
                          witnessPts_tmp = i2 + loop_ub_tmp;
                          b_obj.WorldPose[witnessPts_tmp] = 0.0;
                          b_obj.WorldPose[witnessPts_tmp] += tTree_data[
                            static_cast<int>(b_j) - 1].f1[i2] *
                            b_obj.LocalPose[loop_ub_tmp];
                          b_obj.WorldPose[witnessPts_tmp] += tTree_data[
                            static_cast<int>(b_j) - 1].f1[i2 + 4] *
                            b_obj.LocalPose[loop_ub_tmp + 1];
                          b_obj.WorldPose[witnessPts_tmp] += tTree_data[
                            static_cast<int>(b_j) - 1].f1[i2 + 8] *
                            b_obj.LocalPose[loop_ub_tmp + 2];
                          b_obj.WorldPose[witnessPts_tmp] += tTree_data[
                            static_cast<int>(b_j) - 1].f1[i2 + 12] *
                            b_obj.LocalPose[loop_ub_tmp + 3];
                        }
                      }

                      obj->CollisionGeometries[c_i] = b_obj;
                    }

                    varargout_1 = bodyI->CollisionsInternal->checkCollision
                      (bodyJ->CollisionsInternal, sDist, wPts);
                    if (isColliding || varargout_1) {
                      isColliding = true;
                    }

                    c_i = b_i * 3;
                    loop_ub_tmp = (static_cast<int>(b_j) - 1) << 1;
                    for (i1 = 0; i1 < 2; i1++) {
                      witnessPts_tmp = i1 + loop_ub_tmp;
                      witnessPts[c_i + witnessPts.size(0) * witnessPts_tmp] =
                        wPts[3 * i1];
                      witnessPts[(c_i + witnessPts.size(0) * witnessPts_tmp) + 1]
                        = wPts[3 * i1 + 1];
                      witnessPts[(c_i + witnessPts.size(0) * witnessPts_tmp) + 2]
                        = wPts[3 * i1 + 2];
                    }

                    loop_ub_tmp = (static_cast<int>(b_j) - 1) * 3;
                    c_i = b_i << 1;
                    for (i1 = 0; i1 < 2; i1++) {
                      witnessPts_tmp = i1 + c_i;
                      witnessPts[loop_ub_tmp + witnessPts.size(0) *
                        witnessPts_tmp] = wPts[3 * i1];
                      witnessPts[(loop_ub_tmp + witnessPts.size(0) *
                                  witnessPts_tmp) + 1] = wPts[3 * i1 + 1];
                      witnessPts[(loop_ub_tmp + witnessPts.size(0) *
                                  witnessPts_tmp) + 2] = wPts[3 * i1 + 2];
                    }

                    separationDist[b_i + separationDist.size(0) * (static_cast<
                      int>(b_j) - 1)] = sDist;
                    separationDist[(static_cast<int>(b_j) + separationDist.size
                                    (0) * b_i) - 1] = sDist;
                  }
                }

                b_i++;
              }
            } else {
              double b_numBodies;
              double sDist;
              int i3;
              int j;
              obj = Base.CollisionsInternal;
              sDist = obj->Size;
              i = static_cast<int>(sDist);
              for (b_i = 0; b_i < i; b_i++) {
                b_obj = obj->CollisionGeometries[b_i];
                for (i1 = 0; i1 < 4; i1++) {
                  double d;
                  double d1;
                  sDist = baseTform[i1];
                  b_numBodies = baseTform[i1 + 4];
                  d = baseTform[i1 + 8];
                  d1 = baseTform[i1 + 12];
                  for (int i2{0}; i2 < 4; i2++) {
                    i3 = i2 << 2;
                    loop_ub_tmp = i1 + i3;
                    b_obj.WorldPose[loop_ub_tmp] = 0.0;
                    b_obj.WorldPose[loop_ub_tmp] += sDist * b_obj.LocalPose[i3];
                    b_obj.WorldPose[loop_ub_tmp] += b_numBodies *
                      b_obj.LocalPose[i3 + 1];
                    b_obj.WorldPose[loop_ub_tmp] += d * b_obj.LocalPose[i3 + 2];
                    b_obj.WorldPose[loop_ub_tmp] += d1 * b_obj.LocalPose[i3 + 3];
                  }
                }

                obj->CollisionGeometries[b_i] = b_obj;
              }

              j = 0;
              while ((j <= static_cast<int>(numBodies) - 1) && ((!isColliding) ||
                      isExhaustive)) {
                bool varargout_1;
                bodyJ = Bodies[j];
                varargout_1 = b_RigidBodyTree::checkSelfCollision_anonFcn3
                  (skipCollisionFcn.workspace.idxpairs, 0.0, static_cast<double>
                   (j) + 1.0);
                if (!varargout_1) {
                  double wPts[6];
                  int witnessPts_tmp;
                  obj = bodyJ->CollisionsInternal;
                  sDist = obj->Size;
                  i = static_cast<int>(sDist);
                  for (b_i = 0; b_i < i; b_i++) {
                    b_obj = obj->CollisionGeometries[b_i];
                    for (i1 = 0; i1 < 4; i1++) {
                      for (int i2{0}; i2 < 4; i2++) {
                        i3 = i2 << 2;
                        loop_ub_tmp = i1 + i3;
                        b_obj.WorldPose[loop_ub_tmp] = 0.0;
                        b_obj.WorldPose[loop_ub_tmp] += tTree_data[j].f1[i1] *
                          b_obj.LocalPose[i3];
                        b_obj.WorldPose[loop_ub_tmp] += tTree_data[j].f1[i1 + 4]
                          * b_obj.LocalPose[i3 + 1];
                        b_obj.WorldPose[loop_ub_tmp] += tTree_data[j].f1[i1 + 8]
                          * b_obj.LocalPose[i3 + 2];
                        b_obj.WorldPose[loop_ub_tmp] += tTree_data[j].f1[i1 + 12]
                          * b_obj.LocalPose[i3 + 3];
                      }
                    }

                    obj->CollisionGeometries[b_i] = b_obj;
                  }

                  varargout_1 = Base.CollisionsInternal->checkCollision
                    (bodyJ->CollisionsInternal, sDist, wPts);
                  if (isColliding || varargout_1) {
                    isColliding = true;
                  }

                  b_numBodies = ((numBodies + 1.0) - 1.0) * 3.0 + 1.0;
                  loop_ub_tmp = j << 1;
                  for (i = 0; i < 2; i++) {
                    witnessPts_tmp = i + loop_ub_tmp;
                    witnessPts[(static_cast<int>(b_numBodies) + witnessPts.size
                                (0) * witnessPts_tmp) - 1] = wPts[3 * i];
                    witnessPts[(static_cast<int>(b_numBodies + 1.0) +
                                witnessPts.size(0) * witnessPts_tmp) - 1] =
                      wPts[3 * i + 1];
                    witnessPts[(static_cast<int>(b_numBodies + 2.0) +
                                witnessPts.size(0) * witnessPts_tmp) - 1] =
                      wPts[3 * i + 2];
                  }

                  loop_ub_tmp = j * 3;
                  b_numBodies = ((numBodies + 1.0) - 1.0) * 2.0 + 1.0;
                  for (i = 0; i < 2; i++) {
                    witnessPts_tmp = static_cast<int>(b_numBodies + static_cast<
                      double>(i)) - 1;
                    witnessPts[loop_ub_tmp + witnessPts.size(0) * witnessPts_tmp]
                      = wPts[3 * i];
                    witnessPts[(loop_ub_tmp + witnessPts.size(0) *
                                witnessPts_tmp) + 1] = wPts[3 * i + 1];
                    witnessPts[(loop_ub_tmp + witnessPts.size(0) *
                                witnessPts_tmp) + 2] = wPts[3 * i + 2];
                  }

                  separationDist[(static_cast<int>(numBodies + 1.0) +
                                  separationDist.size(0) * j) - 1] = sDist;
                  separationDist[j + separationDist.size(0) * (static_cast<int>
                    (numBodies + 1.0) - 1)] = sDist;
                }

                j++;
              }

              exitg1 = 1;
            }
          } while (exitg1 == 0);

          return isColliding;
        }

        //
        // Arguments    : const double idxpairs[24]
        //                double i
        //                double j
        // Return Type  : bool
        //
        bool b_RigidBodyTree::checkSelfCollision_anonFcn3(const double idxpairs
          [24], double i, double j)
        {
          double b_i[2];
          int c_i;
          int i2;
          int x_tmp;
          bool x[24];
          bool y[12];
          bool exitg1;
          bool varargout_1;
          b_i[0] = i;
          b_i[1] = j;
          for (c_i = 0; c_i < 2; c_i++) {
            for (i2 = 0; i2 < 12; i2++) {
              x_tmp = i2 + 12 * c_i;
              x[x_tmp] = (idxpairs[x_tmp] == b_i[c_i]);
            }
          }

          for (c_i = 0; c_i < 12; c_i++) {
            y[c_i] = true;
          }

          c_i = 1;
          i2 = 12;
          for (x_tmp = 0; x_tmp < 12; x_tmp++) {
            int i1_tmp;
            int ix;
            i1_tmp = c_i;
            c_i++;
            i2++;
            ix = i1_tmp;
            exitg1 = false;
            while ((!exitg1) && (ix <= i2)) {
              if (!x[ix - 1]) {
                y[i1_tmp - 1] = false;
                exitg1 = true;
              } else {
                ix += 12;
              }
            }
          }

          varargout_1 = false;
          c_i = 0;
          exitg1 = false;
          while ((!exitg1) && (c_i <= 11)) {
            if (y[c_i]) {
              varargout_1 = true;
              exitg1 = true;
            } else {
              c_i++;
            }
          }

          return varargout_1;
        }

        //
        // Arguments    : const array<double, 1U> &x
        //                GIKProblem *problem
        //                array<double, 2U> &W
        //                array<double, 2U> &Jac
        //                GIKProblem **b_problem
        // Return Type  : double
        //
        double GIKHelpers::computeCost(const array<double, 1U> &x, GIKProblem
          *problem, array<double, 2U> &W, array<double, 2U> &Jac, GIKProblem
          **b_problem)
        {
          array<double, 2U> A;
          array<double, 2U> C;
          array<double, 1U> f;
          double cost;
          int boffset;
          int loop_ub;
          int nc_tmp;
          *b_problem = problem;
          (*b_problem)->residuals(x, f, Jac);
          (*b_problem)->get_WeightMatrix(W);
          (*b_problem)->residuals(x, f);
          loop_ub = f.size(0);
          A.set_size(1, f.size(0));
          for (boffset = 0; boffset < loop_ub; boffset++) {
            A[boffset] = 0.5 * f[boffset];
          }

          nc_tmp = W.size(1);
          C.set_size(1, W.size(1));
          for (int j{0}; j < nc_tmp; j++) {
            boffset = j * W.size(0);
            C[j] = 0.0;
            for (int k{0}; k < loop_ub; k++) {
              C[j] = C[j] + A[k] * W[boffset + k];
            }
          }

          cost = 0.0;
          for (boffset = 0; boffset < nc_tmp; boffset++) {
            cost += C[boffset] * f[boffset];
          }

          (*b_problem)->get_WeightMatrix(W);
          return cost;
        }

        //
        // Arguments    : const array<double, 1U> &x
        //                GIKProblem *problem
        //                array<double, 1U> &grad
        // Return Type  : void
        //
        void GIKHelpers::computeGradient(const array<double, 1U> &x, GIKProblem *
          problem, array<double, 1U> &grad)
        {
          array<double, 2U> C;
          array<double, 2U> J;
          array<double, 2U> W;
          array<double, 2U> b_C;
          array<double, 1U> f;
          int b_nc_tmp;
          int boffset;
          int inner;
          int nc_tmp;
          problem->get_WeightMatrix(W);
          problem->residuals(x, f, J);
          inner = f.size(0);
          nc_tmp = W.size(1);
          C.set_size(1, W.size(1));
          for (int j{0}; j < nc_tmp; j++) {
            boffset = j * W.size(0);
            C[j] = 0.0;
            for (int k{0}; k < inner; k++) {
              C[j] = C[j] + f[k] * W[boffset + k];
            }
          }

          b_nc_tmp = J.size(1);
          b_C.set_size(1, J.size(1));
          for (int j{0}; j < b_nc_tmp; j++) {
            boffset = j * J.size(0);
            b_C[j] = 0.0;
            for (int k{0}; k < nc_tmp; k++) {
              b_C[j] = b_C[j] + C[k] * J[boffset + k];
            }
          }

          grad.set_size(J.size(1));
          for (inner = 0; inner < b_nc_tmp; inner++) {
            grad[inner] = b_C[inner];
          }
        }

        //
        // Arguments    : CollisionSet &iobj_0
        //                rigidBodyJoint &iobj_1
        //                RigidBody &iobj_2
        // Return Type  : RigidBody *
        //
        RigidBody *RigidBody::copy(CollisionSet &iobj_0, rigidBodyJoint &iobj_1,
          RigidBody &iobj_2)
        {
          static const char b_cv1[8]{ 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };

          static const char b_cv2[8]{ 'f', 'l', 'o', 'a', 't', 'i', 'n', 'g' };

          static const signed char iv2[7]{ 1, 0, 0, 0, 0, 0, 0 };

          static const signed char b_iv[6]{ 0, 0, 1, 0, 0, 0 };

          static const signed char b_iv1[6]{ 0, 0, 0, 0, 0, 1 };

          static const char b_cv[5]{ 'f', 'i', 'x', 'e', 'd' };

          static const char b_cv3[5]{ 'f', 'i', 'x', 'e', 'd' };

          void *copyGeometryInternal;
          CharacterVector obj;
          CharacterVector s;
          CollisionGeometry b_newObj;
          CollisionGeometry d_obj;
          CollisionSet *c_obj;
          CollisionSet *newObj;
          RigidBody *newbody;
          double msubspace_data[36];
          double poslim_data[14];
          double b_obj[9];
          double obj_idx_0;
          int exitg1;
          int homepos_size_idx_1;
          int i;
          int ibmat;
          int loop_ub;
          int poslim_size_idx_0;
          char vec_data[204];
          signed char b_I[36];
          signed char c_I[9];
          signed char homepos_data[7];
          bool result;
          obj = NameInternal;
          if (obj.Length < 1.0) {
            loop_ub = 0;
          } else {
            loop_ub = static_cast<int>(obj.Length);
          }

          newbody = &iobj_2;
          s.Length = 200.0;
          for (i = 0; i < 200; i++) {
            s.Vector[i] = ' ';
          }

          iobj_2.NameInternal = s;
          s = iobj_2.NameInternal;
          s.Length = loop_ub;
          if (loop_ub < 1) {
            ibmat = 0;
          } else {
            ibmat = loop_ub;
          }

          if (ibmat - 1 >= 0) {
            ::std::copy(&obj.Vector[0], &obj.Vector[ibmat], &s.Vector[0]);
          }

          iobj_2.NameInternal = s;
          (&iobj_1)[0].InTree = false;
          for (i = 0; i < 16; i++) {
            ibmat = iv[i];
            (&iobj_1)[0].JointToParentTransform[i] = ibmat;
            (&iobj_1)[0].ChildToJointTransform[i] = ibmat;
          }

          for (i = 0; i < 14; i++) {
            (&iobj_1)[0].PositionLimitsInternal[i] = 0.0;
          }

          for (i = 0; i < 7; i++) {
            (&iobj_1)[0].HomePositionInternal[i] = 0.0;
          }

          for (i = 0; i < 36; i++) {
            (&iobj_1)[0].MotionSubspaceInternal[i] = 0.0;
          }

          s.Length = 200.0;
          for (i = 0; i < 200; i++) {
            s.Vector[i] = ' ';
          }

          (&iobj_1)[0].NameInternal = s;
          s.Length = 200.0;
          for (i = 0; i < 200; i++) {
            s.Vector[i] = ' ';
          }

          (&iobj_1)[0].TypeInternal = s;
          s = (&iobj_1)[0].NameInternal;
          ibmat = loop_ub + 4;
          if (loop_ub - 1 >= 0) {
            ::std::copy(&obj.Vector[0], &obj.Vector[loop_ub], &vec_data[0]);
          }

          vec_data[loop_ub] = '_';
          vec_data[loop_ub + 1] = 'j';
          vec_data[loop_ub + 2] = 'n';
          vec_data[loop_ub + 3] = 't';
          s.Length = loop_ub + 4;
          if (ibmat - 1 >= 0) {
            ::std::copy(&vec_data[0], &vec_data[ibmat], &s.Vector[0]);
          }

          (&iobj_1)[0].NameInternal = s;
          obj = (&iobj_1)[0].TypeInternal;
          obj.Length = 5.0;
          for (i = 0; i < 5; i++) {
            obj.Vector[i] = b_cv[i];
          }

          (&iobj_1)[0].TypeInternal = obj;
          obj = (&iobj_1)[0].TypeInternal;
          if (obj.Length < 1.0) {
            i = 0;
          } else {
            i = static_cast<int>(obj.Length);
          }

          result = false;
          if (i == 8) {
            ibmat = 0;
            do {
              exitg1 = 0;
              if (ibmat < 8) {
                if (b_cv1[ibmat] != obj.Vector[ibmat]) {
                  exitg1 = 1;
                } else {
                  ibmat++;
                }
              } else {
                result = true;
                exitg1 = 1;
              }
            } while (exitg1 == 0);
          }

          if (result) {
            ibmat = 0;
          } else {
            result = false;
            if (i == 9) {
              ibmat = 0;
              do {
                exitg1 = 0;
                if (ibmat < 9) {
                  if (cv1[ibmat] != obj.Vector[ibmat]) {
                    exitg1 = 1;
                  } else {
                    ibmat++;
                  }
                } else {
                  result = true;
                  exitg1 = 1;
                }
              } while (exitg1 == 0);
            }

            if (result) {
              ibmat = 1;
            } else {
              result = false;
              if (i == 8) {
                ibmat = 0;
                do {
                  exitg1 = 0;
                  if (ibmat < 8) {
                    if (b_cv2[ibmat] != obj.Vector[ibmat]) {
                      exitg1 = 1;
                    } else {
                      ibmat++;
                    }
                  } else {
                    result = true;
                    exitg1 = 1;
                  }
                } while (exitg1 == 0);
              }

              if (result) {
                ibmat = 2;
              } else {
                ibmat = -1;
              }
            }
          }

          switch (ibmat) {
           case 0:
            for (i = 0; i < 6; i++) {
              msubspace_data[i] = b_iv[i];
            }

            poslim_size_idx_0 = 1;
            poslim_data[0] = -3.1415926535897931;
            poslim_data[1] = 3.1415926535897931;
            homepos_size_idx_1 = 1;
            homepos_data[0] = 0;
            (&iobj_1)[0].VelocityNumber = 1.0;
            (&iobj_1)[0].PositionNumber = 1.0;
            (&iobj_1)[0].JointAxisInternal[0] = 0.0;
            (&iobj_1)[0].JointAxisInternal[1] = 0.0;
            (&iobj_1)[0].JointAxisInternal[2] = 1.0;
            break;

           case 1:
            for (i = 0; i < 6; i++) {
              msubspace_data[i] = b_iv1[i];
            }

            poslim_size_idx_0 = 1;
            poslim_data[0] = -0.5;
            poslim_data[1] = 0.5;
            homepos_size_idx_1 = 1;
            homepos_data[0] = 0;
            (&iobj_1)[0].VelocityNumber = 1.0;
            (&iobj_1)[0].PositionNumber = 1.0;
            (&iobj_1)[0].JointAxisInternal[0] = 0.0;
            (&iobj_1)[0].JointAxisInternal[1] = 0.0;
            (&iobj_1)[0].JointAxisInternal[2] = 1.0;
            break;

           case 2:
            {
              signed char b[6];
              for (i = 0; i < 36; i++) {
                b_I[i] = 0;
              }

              for (ibmat = 0; ibmat < 6; ibmat++) {
                b_I[ibmat + 6 * ibmat] = 1;
              }

              for (i = 0; i < 36; i++) {
                msubspace_data[i] = b_I[i];
              }

              poslim_size_idx_0 = 7;
              for (homepos_size_idx_1 = 0; homepos_size_idx_1 < 2;
                   homepos_size_idx_1++) {
                signed char b_tmp;
                ibmat = homepos_size_idx_1 * 3;
                b_tmp = static_cast<signed char>(10 * homepos_size_idx_1 - 5);
                b[ibmat] = b_tmp;
                b[ibmat + 1] = b_tmp;
                b[ibmat + 2] = b_tmp;
                poslim_data[7 * homepos_size_idx_1] = rtNaN;
                poslim_data[7 * homepos_size_idx_1 + 1] = rtNaN;
                poslim_data[7 * homepos_size_idx_1 + 2] = rtNaN;
                poslim_data[7 * homepos_size_idx_1 + 3] = rtNaN;
              }

              for (i = 0; i < 2; i++) {
                poslim_data[7 * i + 4] = b[3 * i];
                poslim_data[7 * i + 5] = b[3 * i + 1];
                poslim_data[7 * i + 6] = b[3 * i + 2];
              }

              homepos_size_idx_1 = 7;
              for (i = 0; i < 7; i++) {
                homepos_data[i] = iv2[i];
              }

              (&iobj_1)[0].VelocityNumber = 6.0;
              (&iobj_1)[0].PositionNumber = 7.0;
              (&iobj_1)[0].JointAxisInternal[0] = rtNaN;
              (&iobj_1)[0].JointAxisInternal[1] = rtNaN;
              (&iobj_1)[0].JointAxisInternal[2] = rtNaN;
            }
            break;

           default:
            for (i = 0; i < 6; i++) {
              msubspace_data[i] = 0.0;
            }

            poslim_size_idx_0 = 1;
            poslim_data[0] = 0.0;
            poslim_data[1] = 0.0;
            homepos_size_idx_1 = 1;
            homepos_data[0] = 0;
            (&iobj_1)[0].VelocityNumber = 0.0;
            (&iobj_1)[0].PositionNumber = 0.0;
            (&iobj_1)[0].JointAxisInternal[0] = 0.0;
            (&iobj_1)[0].JointAxisInternal[1] = 0.0;
            (&iobj_1)[0].JointAxisInternal[2] = 0.0;
            break;
          }

          (&iobj_1)[0].set_MotionSubspace(msubspace_data);
          obj = (&iobj_1)[0].TypeInternal;
          if (obj.Length < 1.0) {
            i = 0;
          } else {
            i = static_cast<int>(obj.Length);
          }

          result = false;
          if (i == 5) {
            ibmat = 0;
            do {
              exitg1 = 0;
              if (ibmat < 5) {
                if (obj.Vector[ibmat] != b_cv3[ibmat]) {
                  exitg1 = 1;
                } else {
                  ibmat++;
                }
              } else {
                result = true;
                exitg1 = 1;
              }
            } while (exitg1 == 0);
          }

          if (!result) {
            obj_idx_0 = (&iobj_1)[0].PositionNumber;
            if (obj_idx_0 < 1.0) {
              loop_ub = 0;
            } else {
              loop_ub = static_cast<int>(obj_idx_0);
            }

            for (i = 0; i < 2; i++) {
              for (ibmat = 0; ibmat < loop_ub; ibmat++) {
                (&iobj_1)[0].PositionLimitsInternal[ibmat + 7 * i] =
                  poslim_data[ibmat + poslim_size_idx_0 * i];
              }
            }

            for (i = 0; i < homepos_size_idx_1; i++) {
              (&iobj_1)[0].HomePositionInternal[i] = homepos_data[i];
            }
          } else {
            (&iobj_1)[0].PositionLimitsInternal[0] = poslim_data[0];
            (&iobj_1)[0].PositionLimitsInternal[7] = poslim_data[1];
            (&iobj_1)[0].HomePositionInternal[0] = homepos_data[0];
          }

          iobj_2.JointInternal = &(&iobj_1)[0];
          iobj_2.Index = -1.0;
          iobj_2.ParentIndex = -1.0;
          iobj_2.MassInternal = 1.0;
          iobj_2.CenterOfMassInternal[0] = 0.0;
          iobj_2.CenterOfMassInternal[1] = 0.0;
          iobj_2.CenterOfMassInternal[2] = 0.0;
          for (i = 0; i < 9; i++) {
            c_I[i] = 0;
          }

          c_I[0] = 1;
          c_I[4] = 1;
          c_I[8] = 1;
          for (i = 0; i < 9; i++) {
            iobj_2.InertiaInternal[i] = c_I[i];
          }

          for (i = 0; i < 36; i++) {
            b_I[i] = 0;
          }

          for (ibmat = 0; ibmat < 6; ibmat++) {
            b_I[ibmat + 6 * ibmat] = 1;
          }

          for (i = 0; i < 36; i++) {
            iobj_2.SpatialInertia[i] = b_I[i];
          }

          double obj_idx_1;
          double obj_idx_2;
          iobj_2.CollisionsInternal = (&iobj_0)[0].init(static_cast<double>(0.0));
          iobj_2.matlabCodegenIsDeleted = false;
          iobj_2.JointInternal = JointInternal->copy((&iobj_1)[1]);
          iobj_2.MassInternal = MassInternal;
          obj_idx_0 = CenterOfMassInternal[0];
          obj_idx_1 = CenterOfMassInternal[1];
          obj_idx_2 = CenterOfMassInternal[2];
          iobj_2.CenterOfMassInternal[0] = obj_idx_0;
          iobj_2.CenterOfMassInternal[1] = obj_idx_1;
          iobj_2.CenterOfMassInternal[2] = obj_idx_2;
          for (i = 0; i < 9; i++) {
            b_obj[i] = InertiaInternal[i];
          }

          for (i = 0; i < 9; i++) {
            iobj_2.InertiaInternal[i] = b_obj[i];
          }

          for (i = 0; i < 36; i++) {
            msubspace_data[i] = SpatialInertia[i];
          }

          for (i = 0; i < 36; i++) {
            iobj_2.SpatialInertia[i] = msubspace_data[i];
          }

          c_obj = CollisionsInternal;
          newObj = (&iobj_0)[1].init(c_obj->MaxElements);
          newObj->Size = c_obj->Size;
          obj_idx_0 = c_obj->Size;
          i = static_cast<int>(obj_idx_0);
          for (ibmat = 0; ibmat < i; ibmat++) {
            d_obj = c_obj->CollisionGeometries[ibmat];
            copyGeometryInternal = collisioncodegen_copyGeometry
              (d_obj.CollisionPrimitive);
            b_newObj.CollisionPrimitive = copyGeometryInternal;
            ::std::copy(&d_obj.LocalPose[0], &d_obj.LocalPose[16],
                        &b_newObj.LocalPose[0]);
            b_newObj.MeshScale[0] = d_obj.MeshScale[0];
            b_newObj.MeshScale[1] = d_obj.MeshScale[1];
            b_newObj.MeshScale[2] = d_obj.MeshScale[2];
            ::std::copy(&d_obj.WorldPose[0], &d_obj.WorldPose[16],
                        &b_newObj.WorldPose[0]);
            newObj->CollisionGeometries[ibmat] = b_newObj;
          }

          iobj_2.CollisionsInternal = newObj;
          return newbody;
        }

        //
        // Arguments    : const array<double, 1U> &qv
        //                double bid1
        //                double bid2
        //                double T_data[]
        //                int T_size[2]
        //                array<double, 2U> &Jac
        // Return Type  : void
        //
        void b_RigidBodyTree::efficientFKAndJacobianForIK(const array<double, 1U>
          &qv, double bid1, double bid2, double T_data[], int T_size[2], array<
          double, 2U> &Jac)
        {
          static const char b_cv1[8]{ 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };

          static const char b_cv2[8]{ 'f', 'l', 'o', 'a', 't', 'i', 'n', 'g' };

          static const char b_cv[5]{ 'f', 'i', 'x', 'e', 'd' };

          RigidBody *body1;
          RigidBody *body2;
          rigidBodyJoint *joint;
          array<double, 2U> B;
          array<double, 2U> kinematicPathIndices;
          array<double, 1U> b_qv;
          double b_data[36];
          double T1[16];
          double T1j[16];
          double Tj1[16];
          double b[16];
          double R[9];
          if ((bid1 >= 0.0) && (bid2 >= 0.0)) {
            double X[36];
            double s;
            int c_i;
            int i;
            int j;
            int loop_ub;
            int n;
            if (bid1 == 0.0) {
              body1 = &Base;
            } else {
              body1 = Bodies[static_cast<int>(bid1) - 1];
            }

            if (bid2 == 0.0) {
              body2 = &Base;
            } else {
              body2 = Bodies[static_cast<int>(bid2) - 1];
            }

            kinematicPathInternal(body1, body2, kinematicPathIndices);
            std::memset(&T1[0], 0, 16U * sizeof(double));
            T1[0] = 1.0;
            T1[5] = 1.0;
            T1[10] = 1.0;
            T1[15] = 1.0;
            n = static_cast<int>(PositionNumber);
            Jac.set_size(6, n);
            loop_ub = 6 * static_cast<int>(PositionNumber);
            for (i = 0; i < loop_ub; i++) {
              Jac[i] = 0.0;
            }

            i = kinematicPathIndices.size(1);
            for (int b_i{0}; b_i <= i - 2; b_i++) {
              CharacterVector obj;
              double Tc2p[16];
              double tempR[9];
              double tempR_tmp;
              double v_idx_0;
              double v_idx_1;
              int X_tmp;
              int exitg1;
              int jointSign;
              bool b_bool;
              bool nextBodyIsParent;
              s = kinematicPathIndices[b_i];
              if (s != 0.0) {
                body1 = Bodies[static_cast<int>(s) - 1];
              } else {
                body1 = &Base;
              }

              s = kinematicPathIndices[b_i + 1];
              if (s != 0.0) {
                body2 = Bodies[static_cast<int>(s) - 1];
              } else {
                body2 = &Base;
              }

              nextBodyIsParent = (body2->Index == body1->ParentIndex);
              if (nextBodyIsParent) {
                body2 = body1;
                jointSign = 1;
              } else {
                jointSign = -1;
              }

              joint = body2->JointInternal;
              obj = joint->TypeInternal;
              if (obj.Length < 1.0) {
                c_i = 0;
              } else {
                c_i = static_cast<int>(obj.Length);
              }

              b_bool = false;
              if (c_i == 5) {
                loop_ub = 0;
                do {
                  exitg1 = 0;
                  if (loop_ub < 5) {
                    if (obj.Vector[loop_ub] != b_cv[loop_ub]) {
                      exitg1 = 1;
                    } else {
                      loop_ub++;
                    }
                  } else {
                    b_bool = true;
                    exitg1 = 1;
                  }
                } while (exitg1 == 0);
              }

              if (b_bool) {
                double Tj[16];
                for (c_i = 0; c_i < 16; c_i++) {
                  Tj1[c_i] = joint->JointToParentTransform[c_i];
                }

                obj = joint->TypeInternal;
                if (obj.Length < 1.0) {
                  c_i = 0;
                } else {
                  c_i = static_cast<int>(obj.Length);
                }

                b_bool = false;
                if (c_i == 8) {
                  loop_ub = 0;
                  do {
                    exitg1 = 0;
                    if (loop_ub < 8) {
                      if (b_cv1[loop_ub] != obj.Vector[loop_ub]) {
                        exitg1 = 1;
                      } else {
                        loop_ub++;
                      }
                    } else {
                      b_bool = true;
                      exitg1 = 1;
                    }
                  } while (exitg1 == 0);
                }

                if (b_bool) {
                  loop_ub = 0;
                } else {
                  b_bool = false;
                  if (c_i == 9) {
                    loop_ub = 0;
                    do {
                      exitg1 = 0;
                      if (loop_ub < 9) {
                        if (cv1[loop_ub] != obj.Vector[loop_ub]) {
                          exitg1 = 1;
                        } else {
                          loop_ub++;
                        }
                      } else {
                        b_bool = true;
                        exitg1 = 1;
                      }
                    } while (exitg1 == 0);
                  }

                  if (b_bool) {
                    loop_ub = 1;
                  } else {
                    b_bool = false;
                    if (c_i == 8) {
                      loop_ub = 0;
                      do {
                        exitg1 = 0;
                        if (loop_ub < 8) {
                          if (b_cv2[loop_ub] != obj.Vector[loop_ub]) {
                            exitg1 = 1;
                          } else {
                            loop_ub++;
                          }
                        } else {
                          b_bool = true;
                          exitg1 = 1;
                        }
                      } while (exitg1 == 0);
                    }

                    if (b_bool) {
                      loop_ub = 2;
                    } else {
                      loop_ub = -1;
                    }
                  }
                }

                switch (loop_ub) {
                 case 0:
                  {
                    double v[3];
                    double b_tempR_tmp;
                    double c_tempR_tmp;
                    double d_tempR_tmp;
                    double e_tempR_tmp;
                    double f_tempR_tmp;
                    double qidx_idx_0;
                    double qidx_idx_1;
                    joint->get_JointAxis(v);
                    s = 1.0 / std::sqrt((v[0] * v[0] + v[1] * v[1]) + v[2] * v[2]);
                    v_idx_0 = v[0] * s;
                    v_idx_1 = v[1] * s;
                    s *= v[2];
                    tempR_tmp = v_idx_0 * v_idx_0 * 0.0 + 1.0;
                    tempR[0] = tempR_tmp;
                    qidx_idx_0 = v_idx_0 * v_idx_1 * 0.0;
                    qidx_idx_1 = qidx_idx_0 - s * 0.0;
                    tempR[1] = qidx_idx_1;
                    b_tempR_tmp = v_idx_0 * s * 0.0;
                    c_tempR_tmp = b_tempR_tmp + v_idx_1 * 0.0;
                    tempR[2] = c_tempR_tmp;
                    qidx_idx_0 += s * 0.0;
                    tempR[3] = qidx_idx_0;
                    d_tempR_tmp = v_idx_1 * v_idx_1 * 0.0 + 1.0;
                    tempR[4] = d_tempR_tmp;
                    e_tempR_tmp = v_idx_1 * s * 0.0;
                    f_tempR_tmp = e_tempR_tmp - v_idx_0 * 0.0;
                    tempR[5] = f_tempR_tmp;
                    b_tempR_tmp -= v_idx_1 * 0.0;
                    tempR[6] = b_tempR_tmp;
                    e_tempR_tmp += v_idx_0 * 0.0;
                    tempR[7] = e_tempR_tmp;
                    s = s * s * 0.0 + 1.0;
                    tempR[8] = s;
                    R[0] = tempR_tmp;
                    R[1] = qidx_idx_1;
                    R[2] = c_tempR_tmp;
                    R[3] = qidx_idx_0;
                    R[4] = d_tempR_tmp;
                    R[5] = f_tempR_tmp;
                    R[6] = b_tempR_tmp;
                    R[7] = e_tempR_tmp;
                    R[8] = s;
                    for (int k{0}; k < 3; k++) {
                      R[k] = tempR[3 * k];
                      R[k + 3] = tempR[3 * k + 1];
                      R[k + 6] = tempR[3 * k + 2];
                    }

                    std::memset(&b[0], 0, 16U * sizeof(double));
                    for (c_i = 0; c_i < 3; c_i++) {
                      loop_ub = c_i << 2;
                      b[loop_ub] = R[3 * c_i];
                      b[loop_ub + 1] = R[3 * c_i + 1];
                      b[loop_ub + 2] = R[3 * c_i + 2];
                    }

                    b[15] = 1.0;
                  }
                  break;

                 case 1:
                  {
                    double v[3];
                    joint->get_JointAxis(v);
                    std::memset(&R[0], 0, 9U * sizeof(double));
                    R[0] = 1.0;
                    R[4] = 1.0;
                    R[8] = 1.0;
                    for (c_i = 0; c_i < 3; c_i++) {
                      loop_ub = c_i << 2;
                      b[loop_ub] = R[3 * c_i];
                      b[loop_ub + 1] = R[3 * c_i + 1];
                      b[loop_ub + 2] = R[3 * c_i + 2];
                      b[c_i + 12] = v[c_i] * 0.0;
                    }

                    b[3] = 0.0;
                    b[7] = 0.0;
                    b[11] = 0.0;
                    b[15] = 1.0;
                  }
                  break;

                 case 2:
                  // A check that is always false is detected at compile-time. Eliminating code that follows.
                  break;

                 default:
                  std::memset(&b[0], 0, 16U * sizeof(double));
                  b[0] = 1.0;
                  b[5] = 1.0;
                  b[10] = 1.0;
                  b[15] = 1.0;
                  break;
                }

                for (c_i = 0; c_i < 16; c_i++) {
                  Tj[c_i] = joint->ChildToJointTransform[c_i];
                }

                for (c_i = 0; c_i < 4; c_i++) {
                  s = Tj1[c_i];
                  v_idx_0 = Tj1[c_i + 4];
                  v_idx_1 = Tj1[c_i + 8];
                  tempR_tmp = Tj1[c_i + 12];
                  for (X_tmp = 0; X_tmp < 4; X_tmp++) {
                    j = X_tmp << 2;
                    T1j[c_i + j] = ((s * b[j] + v_idx_0 * b[j + 1]) + v_idx_1 *
                                    b[j + 2]) + tempR_tmp * b[j + 3];
                  }

                  s = T1j[c_i];
                  v_idx_0 = T1j[c_i + 4];
                  v_idx_1 = T1j[c_i + 8];
                  tempR_tmp = T1j[c_i + 12];
                  for (X_tmp = 0; X_tmp < 4; X_tmp++) {
                    j = X_tmp << 2;
                    Tc2p[c_i + j] = ((s * Tj[j] + v_idx_0 * Tj[j + 1]) + v_idx_1
                                     * Tj[j + 2]) + tempR_tmp * Tj[j + 3];
                  }
                }
              } else {
                double y_data[36];
                double Tj[16];
                double qidx_idx_0;
                double qidx_idx_1;
                loop_ub = static_cast<int>(body2->Index);
                qidx_idx_0 = PositionDoFMap[loop_ub - 1];
                qidx_idx_1 = PositionDoFMap[loop_ub + 11];
                if (qidx_idx_0 > qidx_idx_1) {
                  c_i = 0;
                  X_tmp = 0;
                } else {
                  c_i = static_cast<int>(qidx_idx_0) - 1;
                  X_tmp = static_cast<int>(qidx_idx_1);
                }

                loop_ub = X_tmp - c_i;
                b_qv.set_size(loop_ub);
                for (X_tmp = 0; X_tmp < loop_ub; X_tmp++) {
                  b_qv[X_tmp] = qv[c_i + X_tmp];
                }

                joint->transformBodyToParent(b_qv, Tc2p);
                loop_ub = static_cast<int>(body2->Index);
                qidx_idx_0 = VelocityDoFMap[loop_ub - 1];
                qidx_idx_1 = VelocityDoFMap[loop_ub + 11];
                if (nextBodyIsParent) {
                  for (c_i = 0; c_i < 16; c_i++) {
                    Tj[c_i] = joint->ChildToJointTransform[c_i];
                  }
                } else {
                  for (c_i = 0; c_i < 16; c_i++) {
                    Tj1[c_i] = joint->JointToParentTransform[c_i];
                  }

                  for (c_i = 0; c_i < 3; c_i++) {
                    R[3 * c_i] = Tj1[c_i];
                    R[3 * c_i + 1] = Tj1[c_i + 4];
                    R[3 * c_i + 2] = Tj1[c_i + 8];
                  }

                  for (c_i = 0; c_i < 9; c_i++) {
                    tempR[c_i] = -R[c_i];
                  }

                  s = Tj1[12];
                  v_idx_0 = Tj1[13];
                  v_idx_1 = Tj1[14];
                  for (c_i = 0; c_i < 3; c_i++) {
                    loop_ub = c_i << 2;
                    Tj[loop_ub] = R[3 * c_i];
                    Tj[loop_ub + 1] = R[3 * c_i + 1];
                    Tj[loop_ub + 2] = R[3 * c_i + 2];
                    Tj[c_i + 12] = (tempR[c_i] * s + tempR[c_i + 3] * v_idx_0) +
                      tempR[c_i + 6] * v_idx_1;
                  }

                  Tj[3] = 0.0;
                  Tj[7] = 0.0;
                  Tj[11] = 0.0;
                  Tj[15] = 1.0;
                }

                for (c_i = 0; c_i < 4; c_i++) {
                  s = Tj[c_i];
                  v_idx_0 = Tj[c_i + 4];
                  v_idx_1 = Tj[c_i + 8];
                  tempR_tmp = Tj[c_i + 12];
                  for (X_tmp = 0; X_tmp < 4; X_tmp++) {
                    j = X_tmp << 2;
                    T1j[c_i + j] = ((s * T1[j] + v_idx_0 * T1[j + 1]) + v_idx_1 *
                                    T1[j + 2]) + tempR_tmp * T1[j + 3];
                  }
                }

                for (c_i = 0; c_i < 3; c_i++) {
                  R[3 * c_i] = T1j[c_i];
                  R[3 * c_i + 1] = T1j[c_i + 4];
                  R[3 * c_i + 2] = T1j[c_i + 8];
                }

                for (c_i = 0; c_i < 9; c_i++) {
                  tempR[c_i] = -R[c_i];
                }

                s = T1j[12];
                v_idx_0 = T1j[13];
                v_idx_1 = T1j[14];
                for (c_i = 0; c_i < 3; c_i++) {
                  loop_ub = c_i << 2;
                  Tj1[loop_ub] = R[3 * c_i];
                  Tj1[loop_ub + 1] = R[3 * c_i + 1];
                  Tj1[loop_ub + 2] = R[3 * c_i + 2];
                  Tj1[c_i + 12] = (tempR[c_i] * s + tempR[c_i + 3] * v_idx_0) +
                    tempR[c_i + 6] * v_idx_1;
                }

                Tj1[3] = 0.0;
                Tj1[7] = 0.0;
                Tj1[11] = 0.0;
                Tj1[15] = 1.0;
                R[0] = 0.0;
                R[3] = -Tj1[14];
                R[6] = Tj1[13];
                R[1] = Tj1[14];
                R[4] = 0.0;
                R[7] = -Tj1[12];
                R[2] = -Tj1[13];
                R[5] = Tj1[12];
                R[8] = 0.0;
                for (c_i = 0; c_i < 3; c_i++) {
                  s = R[c_i];
                  v_idx_0 = R[c_i + 3];
                  v_idx_1 = R[c_i + 6];
                  for (X_tmp = 0; X_tmp < 3; X_tmp++) {
                    j = X_tmp << 2;
                    tempR[c_i + 3 * X_tmp] = (s * Tj1[j] + v_idx_0 * Tj1[j + 1])
                      + v_idx_1 * Tj1[j + 2];
                    X[X_tmp + 6 * c_i] = Tj1[X_tmp + (c_i << 2)];
                    X[X_tmp + 6 * (c_i + 3)] = 0.0;
                  }
                }

                for (c_i = 0; c_i < 3; c_i++) {
                  X[6 * c_i + 3] = tempR[3 * c_i];
                  loop_ub = c_i << 2;
                  X_tmp = 6 * (c_i + 3);
                  X[X_tmp + 3] = Tj1[loop_ub];
                  X[6 * c_i + 4] = tempR[3 * c_i + 1];
                  X[X_tmp + 4] = Tj1[loop_ub + 1];
                  X[6 * c_i + 5] = tempR[3 * c_i + 2];
                  X[X_tmp + 5] = Tj1[loop_ub + 2];
                }

                int b_size[2];
                joint->get_MotionSubspace(b_data, b_size);
                X_tmp = b_size[1];
                for (j = 0; j < X_tmp; j++) {
                  loop_ub = j * 6;
                  for (c_i = 0; c_i < 6; c_i++) {
                    s = 0.0;
                    for (int k{0}; k < 6; k++) {
                      s += X[k * 6 + c_i] * b_data[loop_ub + k];
                    }

                    y_data[loop_ub + c_i] = s;
                  }
                }

                if (qidx_idx_0 > qidx_idx_1) {
                  c_i = 0;
                  X_tmp = 0;
                } else {
                  c_i = static_cast<int>(qidx_idx_0) - 1;
                  X_tmp = static_cast<int>(qidx_idx_1);
                }

                loop_ub = X_tmp - c_i;
                for (X_tmp = 0; X_tmp < loop_ub; X_tmp++) {
                  for (j = 0; j < 6; j++) {
                    Jac[j + 6 * (c_i + X_tmp)] = y_data[j + 6 * X_tmp] *
                      static_cast<double>(jointSign);
                  }
                }
              }

              if (nextBodyIsParent) {
                for (c_i = 0; c_i < 4; c_i++) {
                  s = Tc2p[c_i];
                  v_idx_0 = Tc2p[c_i + 4];
                  v_idx_1 = Tc2p[c_i + 8];
                  tempR_tmp = Tc2p[c_i + 12];
                  for (X_tmp = 0; X_tmp < 4; X_tmp++) {
                    j = X_tmp << 2;
                    T1j[c_i + j] = ((s * T1[j] + v_idx_0 * T1[j + 1]) + v_idx_1 *
                                    T1[j + 2]) + tempR_tmp * T1[j + 3];
                  }
                }

                ::std::copy(&T1j[0], &T1j[16], &T1[0]);
              } else {
                for (c_i = 0; c_i < 3; c_i++) {
                  R[3 * c_i] = Tc2p[c_i];
                  R[3 * c_i + 1] = Tc2p[c_i + 4];
                  R[3 * c_i + 2] = Tc2p[c_i + 8];
                }

                for (c_i = 0; c_i < 9; c_i++) {
                  tempR[c_i] = -R[c_i];
                }

                s = Tc2p[12];
                v_idx_0 = Tc2p[13];
                v_idx_1 = Tc2p[14];
                for (c_i = 0; c_i < 3; c_i++) {
                  loop_ub = c_i << 2;
                  T1j[loop_ub] = R[3 * c_i];
                  T1j[loop_ub + 1] = R[3 * c_i + 1];
                  T1j[loop_ub + 2] = R[3 * c_i + 2];
                  T1j[c_i + 12] = (tempR[c_i] * s + tempR[c_i + 3] * v_idx_0) +
                    tempR[c_i + 6] * v_idx_1;
                }

                T1j[3] = 0.0;
                T1j[7] = 0.0;
                T1j[11] = 0.0;
                T1j[15] = 1.0;
                for (c_i = 0; c_i < 4; c_i++) {
                  s = T1j[c_i];
                  v_idx_0 = T1j[c_i + 4];
                  v_idx_1 = T1j[c_i + 8];
                  tempR_tmp = T1j[c_i + 12];
                  for (X_tmp = 0; X_tmp < 4; X_tmp++) {
                    j = X_tmp << 2;
                    Tj1[c_i + j] = ((s * T1[j] + v_idx_0 * T1[j + 1]) + v_idx_1 *
                                    T1[j + 2]) + tempR_tmp * T1[j + 3];
                  }
                }

                ::std::copy(&Tj1[0], &Tj1[16], &T1[0]);
              }
            }

            for (i = 0; i < 3; i++) {
              c_i = i << 2;
              s = T1[c_i];
              X[6 * i] = s;
              loop_ub = 6 * (i + 3);
              X[loop_ub] = 0.0;
              X[6 * i + 3] = 0.0;
              X[loop_ub + 3] = s;
              s = T1[c_i + 1];
              X[6 * i + 1] = s;
              X[loop_ub + 1] = 0.0;
              X[6 * i + 4] = 0.0;
              X[loop_ub + 4] = s;
              s = T1[c_i + 2];
              X[6 * i + 2] = s;
              X[loop_ub + 2] = 0.0;
              X[6 * i + 5] = 0.0;
              X[loop_ub + 5] = s;
            }

            B.set_size(6, n);
            loop_ub = 6 * Jac.size(1);
            for (i = 0; i < loop_ub; i++) {
              B[i] = Jac[i];
            }

            Jac.set_size(6, n);
            for (j = 0; j < n; j++) {
              loop_ub = j * 6;
              for (int b_i{0}; b_i < 6; b_i++) {
                s = 0.0;
                for (int k{0}; k < 6; k++) {
                  s += X[k * 6 + b_i] * B[loop_ub + k];
                }

                Jac[loop_ub + b_i] = s;
              }
            }

            T_size[0] = 4;
            T_size[1] = 4;
            ::std::copy(&T1[0], &T1[16], &T_data[0]);
          } else {
            T_size[0] = 0;
            T_size[1] = 0;
            Jac.set_size(6, 0);
          }
        }

        //
        // Arguments    : const double T_data[]
        //                const int T_size[2]
        //                double JTwist[6]
        // Return Type  : double
        //
        double OrientationTarget::evaluateFromTransform(const double T_data[],
          const int T_size[2], double JTwist[6]) const
        {
          creal_T u;
          creal_T v;
          double T[9];
          double y[9];
          double vspecial_data[3];
          double d;
          double err_idx_0;
          double err_idx_1;
          double g;
          double q;
          int i;
          int k;
          bool exitg1;
          bool rEQ0;
          i = T_size[0];
          for (k = 0; k < 3; k++) {
            T[3 * k] = T_data[static_cast<signed char>(k + 1) - 1];
            T[3 * k + 1] = T_data[(static_cast<signed char>(k + 1) + i) - 1];
            T[3 * k + 2] = T_data[(static_cast<signed char>(k + 1) + i * 2) - 1];
          }

          for (i = 0; i < 3; i++) {
            d = TargetTransform[i];
            g = TargetTransform[i + 4];
            q = TargetTransform[i + 8];
            for (k = 0; k < 3; k++) {
              y[i + 3 * k] = (d * T[3 * k] + g * T[3 * k + 1]) + q * T[3 * k + 2];
            }
          }

          g = 0.5 * (((y[0] + y[4]) + y[8]) - 1.0);
          if (!(std::abs(g) > 1.0)) {
            u.re = std::acos(g);
          } else {
            v.re = g + 1.0;
            v.im = 0.0;
            ::coder::internal::scalar::b_sqrt(v);
            u.re = 1.0 - g;
            u.im = 0.0;
            ::coder::internal::scalar::b_sqrt(u);
            g = u.re;
            u.re = 2.0 * ::coder::internal::scalar::b_atan2(g, v.re);
          }

          g = 2.0 * std::sin(u.re);
          vspecial_data[0] = (y[5] - y[7]) / g;
          vspecial_data[1] = (y[6] - y[2]) / g;
          vspecial_data[2] = (y[1] - y[3]) / g;
          if (std::isnan(u.re) || std::isinf(u.re)) {
            g = rtNaN;
          } else if (u.re == 0.0) {
            g = 0.0;
          } else {
            g = std::fmod(u.re, 3.1415926535897931);
            rEQ0 = (g == 0.0);
            if (!rEQ0) {
              q = std::abs(u.re / 3.1415926535897931);
              rEQ0 = !(std::abs(q - std::floor(q + 0.5)) >
                       2.2204460492503131E-16 * q);
            }

            if (rEQ0) {
              g = 0.0;
            } else if (g < 0.0) {
              g += 3.1415926535897931;
            }
          }

          rEQ0 = true;
          k = 0;
          exitg1 = false;
          while ((!exitg1) && (k < 3)) {
            if (!(vspecial_data[k] == 0.0)) {
              rEQ0 = false;
              exitg1 = true;
            } else {
              k++;
            }
          }

          if ((g == 0.0) || rEQ0) {
            for (i = 0; i < 3; i++) {
              vspecial_data[i] = 0.0;
            }

            for (int b_i{0}; b_i < 1; b_i++) {
              double V[9];
              std::memset(&T[0], 0, 9U * sizeof(double));
              T[0] = 1.0;
              T[4] = 1.0;
              T[8] = 1.0;
              rEQ0 = true;
              for (k = 0; k < 9; k++) {
                d = T[k] - y[k];
                T[k] = d;
                if ((!rEQ0) || (std::isinf(d) || std::isnan(d))) {
                  rEQ0 = false;
                }
              }

              if (rEQ0) {
                double U[9];
                ::coder::internal::svd(T, U, vspecial_data, V);
              } else {
                for (i = 0; i < 9; i++) {
                  V[i] = rtNaN;
                }
              }

              vspecial_data[0] = V[6];
              vspecial_data[1] = V[7];
              vspecial_data[2] = V[8];
            }
          }

          g = 1.0 / std::sqrt((vspecial_data[0] * vspecial_data[0] +
                               vspecial_data[1] * vspecial_data[1]) +
                              vspecial_data[2] * vspecial_data[2]);
          d = u.re * (vspecial_data[0] * g);
          err_idx_0 = d;
          q = d * d;
          d = u.re * (vspecial_data[1] * g);
          err_idx_1 = d;
          q += d * d;
          d = u.re * (vspecial_data[2] * g);
          q += d * d;
          g = std::sqrt(q + 2.2204460492503131E-16);
          JTwist[0] = -(err_idx_0 / g);
          JTwist[3] = -0.0;
          JTwist[1] = -(err_idx_1 / g);
          JTwist[4] = -0.0;
          JTwist[2] = -(d / g);
          JTwist[5] = -0.0;
          return g;
        }

        //
        // Arguments    : const array<double, 1U> &x
        //                GIKProblem *problem
        // Return Type  : double
        //
        double GIKHelpers::evaluateSolution(const array<double, 1U> &x,
          GIKProblem *problem)
        {
          array<double, 2U> a;
          array<double, 1U> C;
          array<double, 1U> evec;
          int inner;
          int mc_tmp;
          problem->residuals(x, evec);
          problem->get_WeightMatrix(a);
          mc_tmp = a.size(0);
          inner = a.size(1);
          C.set_size(a.size(0));
          for (int i{0}; i < mc_tmp; i++) {
            C[i] = 0.0;
          }

          for (int k{0}; k < inner; k++) {
            int aoffset;
            aoffset = k * a.size(0);
            for (int i{0}; i < mc_tmp; i++) {
              C[i] = C[i] + a[aoffset + i] * evec[k];
            }
          }

          return b_norm(C);
        }

        //
        // Arguments    : const char jointname_data[]
        //                const int jointname_size[2]
        // Return Type  : double
        //
        double b_RigidBodyTree::findBodyIndexByJointName(const char
          jointname_data[], const int jointname_size[2])
        {
          CharacterVector b_obj;
          RigidBody *obj;
          rigidBodyJoint *jnt;
          double bid;
          double d;
          int obj_size[2];
          int i;
          char obj_data[200];
          bool exitg1;
          bid = -1.0;
          d = NumBodies;
          i = 0;
          exitg1 = false;
          while ((!exitg1) && (i <= static_cast<int>(d) - 1)) {
            int loop_ub;
            obj = Bodies[i];
            jnt = obj->JointInternal;
            b_obj = jnt->NameInternal;
            if (b_obj.Length < 1.0) {
              loop_ub = 0;
            } else {
              loop_ub = static_cast<int>(b_obj.Length);
            }

            obj_size[0] = 1;
            obj_size[1] = loop_ub;
            if (loop_ub - 1 >= 0) {
              ::std::copy(&b_obj.Vector[0], &b_obj.Vector[loop_ub], &obj_data[0]);
            }

            if (::coder::internal::b_strcmp(obj_data, obj_size, jointname_data,
                 jointname_size)) {
              bid = static_cast<double>(i) + 1.0;
              exitg1 = true;
            } else {
              i++;
            }
          }

          return bid;
        }

        //
        // Arguments    : const char bodyname[8]
        // Return Type  : double
        //
        double b_RigidBodyTree::findBodyIndexByName(const char bodyname[8])
        {
          CharacterVector obj;
          RigidBody *b_obj;
          double bid;
          int exitg1;
          int kstr;
          bool b_bool;
          bid = -1.0;
          obj = Base.NameInternal;
          if (obj.Length < 1.0) {
            kstr = 0;
          } else {
            kstr = static_cast<int>(obj.Length);
          }

          b_bool = false;
          if (kstr == 8) {
            kstr = 0;
            do {
              exitg1 = 0;
              if (kstr < 8) {
                if (obj.Vector[kstr] != bodyname[kstr]) {
                  exitg1 = 1;
                } else {
                  kstr++;
                }
              } else {
                b_bool = true;
                exitg1 = 1;
              }
            } while (exitg1 == 0);
          }

          if (b_bool) {
            bid = 0.0;
          } else {
            double d;
            int i;
            bool exitg2;
            d = NumBodies;
            i = 0;
            exitg2 = false;
            while ((!exitg2) && (i <= static_cast<int>(d) - 1)) {
              b_obj = Bodies[i];
              obj = b_obj->NameInternal;
              if (obj.Length < 1.0) {
                kstr = 0;
              } else {
                kstr = static_cast<int>(obj.Length);
              }

              b_bool = false;
              if (kstr == 8) {
                kstr = 0;
                do {
                  exitg1 = 0;
                  if (kstr < 8) {
                    if (obj.Vector[kstr] != bodyname[kstr]) {
                      exitg1 = 1;
                    } else {
                      kstr++;
                    }
                  } else {
                    b_bool = true;
                    exitg1 = 1;
                  }
                } while (exitg1 == 0);
              }

              if (b_bool) {
                bid = static_cast<double>(i) + 1.0;
                exitg2 = true;
              } else {
                i++;
              }
            }
          }

          return bid;
        }

        //
        // Arguments    : const char bodyname_data[]
        //                const int bodyname_size[2]
        // Return Type  : double
        //
        double b_RigidBodyTree::findBodyIndexByName(const char bodyname_data[],
          const int bodyname_size[2])
        {
          CharacterVector obj;
          RigidBody *b_obj;
          double bid;
          int obj_size[2];
          int loop_ub;
          char obj_data[200];
          bid = -1.0;
          obj = Base.NameInternal;
          if (obj.Length < 1.0) {
            loop_ub = 0;
          } else {
            loop_ub = static_cast<int>(obj.Length);
          }

          obj_size[0] = 1;
          obj_size[1] = loop_ub;
          if (loop_ub - 1 >= 0) {
            ::std::copy(&obj.Vector[0], &obj.Vector[loop_ub], &obj_data[0]);
          }

          if (::coder::internal::b_strcmp(obj_data, obj_size, bodyname_data,
               bodyname_size)) {
            bid = 0.0;
          } else {
            double d;
            int i;
            bool exitg1;
            d = NumBodies;
            i = 0;
            exitg1 = false;
            while ((!exitg1) && (i <= static_cast<int>(d) - 1)) {
              b_obj = Bodies[i];
              obj = b_obj->NameInternal;
              if (obj.Length < 1.0) {
                loop_ub = 0;
              } else {
                loop_ub = static_cast<int>(obj.Length);
              }

              obj_size[0] = 1;
              obj_size[1] = loop_ub;
              if (loop_ub - 1 >= 0) {
                ::std::copy(&obj.Vector[0], &obj.Vector[loop_ub], &obj_data[0]);
              }

              if (::coder::internal::b_strcmp(obj_data, obj_size, bodyname_data,
                   bodyname_size)) {
                bid = static_cast<double>(i) + 1.0;
                exitg1 = true;
              } else {
                i++;
              }
            }
          }

          return bid;
        }

        //
        // Arguments    : void
        // Return Type  : double
        //
        double b_RigidBodyTree::findBodyIndexByName()
        {
          static const char b_cv[4]{ 'b', 'a', 's', 'e' };

          CharacterVector obj;
          RigidBody *b_obj;
          double bid;
          int exitg1;
          int kstr;
          bool b_bool;
          bid = -1.0;
          obj = Base.NameInternal;
          if (obj.Length < 1.0) {
            kstr = 0;
          } else {
            kstr = static_cast<int>(obj.Length);
          }

          b_bool = false;
          if (kstr == 4) {
            kstr = 0;
            do {
              exitg1 = 0;
              if (kstr < 4) {
                if (obj.Vector[kstr] != b_cv[kstr]) {
                  exitg1 = 1;
                } else {
                  kstr++;
                }
              } else {
                b_bool = true;
                exitg1 = 1;
              }
            } while (exitg1 == 0);
          }

          if (b_bool) {
            bid = 0.0;
          } else {
            double d;
            int i;
            bool exitg2;
            d = NumBodies;
            i = 0;
            exitg2 = false;
            while ((!exitg2) && (i <= static_cast<int>(d) - 1)) {
              b_obj = Bodies[i];
              obj = b_obj->NameInternal;
              if (obj.Length < 1.0) {
                kstr = 0;
              } else {
                kstr = static_cast<int>(obj.Length);
              }

              b_bool = false;
              if (kstr == 4) {
                kstr = 0;
                do {
                  exitg1 = 0;
                  if (kstr < 4) {
                    if (obj.Vector[kstr] != b_cv[kstr]) {
                      exitg1 = 1;
                    } else {
                      kstr++;
                    }
                  } else {
                    b_bool = true;
                    exitg1 = 1;
                  }
                } while (exitg1 == 0);
              }

              if (b_bool) {
                bid = static_cast<double>(i) + 1.0;
                exitg2 = true;
              } else {
                i++;
              }
            }
          }

          return bid;
        }

        //
        // Arguments    : const double qvec[6]
        //                cell_wrap_41 Ttree_data[]
        //                int Ttree_size[2]
        // Return Type  : void
        //
        void b_RigidBodyTree::forwardKinematics(const double qvec[6],
          cell_wrap_41 Ttree_data[], int Ttree_size[2])
        {
          RigidBody *body;
          array<double, 1U> b_qvec_data;
          double b_a[16];
          double qvec_data[6];
          double k;
          double n;
          int i;
          n = NumBodies;
          repmat(n, Ttree_data, Ttree_size);
          k = 1.0;
          i = static_cast<int>(n);
          for (int b_i{0}; b_i < i; b_i++) {
            int i1;
            int i2;
            int loop_ub;
            body = Bodies[b_i];
            n = body->JointInternal->PositionNumber;
            n += k;
            if (k > n - 1.0) {
              i1 = 0;
              i2 = 0;
            } else {
              i1 = static_cast<int>(k) - 1;
              i2 = static_cast<int>(n - 1.0);
            }

            loop_ub = i2 - i1;
            for (i2 = 0; i2 < loop_ub; i2++) {
              qvec_data[i2] = qvec[i1 + i2];
            }

            b_qvec_data.set(&qvec_data[0], loop_ub);
            body->JointInternal->transformBodyToParent(b_qvec_data,
              Ttree_data[b_i].f1);
            k = n;
            if (body->ParentIndex > 0.0) {
              double a[16];
              for (i1 = 0; i1 < 16; i1++) {
                a[i1] = Ttree_data[static_cast<int>(body->ParentIndex) - 1]
                  .f1[i1];
              }

              for (i1 = 0; i1 < 4; i1++) {
                double d;
                double d1;
                double d2;
                n = a[i1];
                d = a[i1 + 4];
                d1 = a[i1 + 8];
                d2 = a[i1 + 12];
                for (i2 = 0; i2 < 4; i2++) {
                  loop_ub = i2 << 2;
                  b_a[i1 + loop_ub] = ((n * Ttree_data[b_i].f1[loop_ub] + d *
                                        Ttree_data[b_i].f1[loop_ub + 1]) + d1 *
                                       Ttree_data[b_i].f1[loop_ub + 2]) + d2 *
                    Ttree_data[b_i].f1[loop_ub + 3];
                }
              }

              ::std::copy(&b_a[0], &b_a[16], &Ttree_data[b_i].f1[0]);
            }
          }
        }

        //
        // Arguments    : char value_data[]
        //                int value_size[2]
        // Return Type  : void
        //
        void OrientationTarget::get_EndEffector(char value_data[], int
          value_size[2])
        {
          CharacterVector c_obj;
          RigidBody *b_obj;
          b_RigidBodyTree *obj;
          if (EndEffectorIndex > 0.0) {
            int loop_ub;
            b_obj = Tree->Bodies[static_cast<int>(EndEffectorIndex) - 1];
            c_obj = b_obj->NameInternal;
            if (c_obj.Length < 1.0) {
              loop_ub = 0;
            } else {
              loop_ub = static_cast<int>(c_obj.Length);
            }

            value_size[0] = 1;
            value_size[1] = loop_ub;
            if (loop_ub - 1 >= 0) {
              ::std::copy(&c_obj.Vector[0], &c_obj.Vector[loop_ub], &value_data
                          [0]);
            }
          } else {
            int loop_ub;
            obj = Tree;
            c_obj = obj->Base.NameInternal;
            if (c_obj.Length < 1.0) {
              loop_ub = 0;
            } else {
              loop_ub = static_cast<int>(c_obj.Length);
            }

            value_size[0] = 1;
            value_size[1] = loop_ub;
            if (loop_ub - 1 >= 0) {
              ::std::copy(&c_obj.Vector[0], &c_obj.Vector[loop_ub], &value_data
                          [0]);
            }
          }
        }

        //
        // Arguments    : char value_data[]
        //                int value_size[2]
        // Return Type  : void
        //
        void PositionTarget::get_EndEffector(char value_data[], int value_size[2])
        {
          CharacterVector c_obj;
          RigidBody *b_obj;
          b_RigidBodyTree *obj;
          if (EndEffectorIndex > 0.0) {
            int loop_ub;
            b_obj = Tree->Bodies[static_cast<int>(EndEffectorIndex) - 1];
            c_obj = b_obj->NameInternal;
            if (c_obj.Length < 1.0) {
              loop_ub = 0;
            } else {
              loop_ub = static_cast<int>(c_obj.Length);
            }

            value_size[0] = 1;
            value_size[1] = loop_ub;
            if (loop_ub - 1 >= 0) {
              ::std::copy(&c_obj.Vector[0], &c_obj.Vector[loop_ub], &value_data
                          [0]);
            }
          } else {
            int loop_ub;
            obj = Tree;
            c_obj = obj->Base.NameInternal;
            if (c_obj.Length < 1.0) {
              loop_ub = 0;
            } else {
              loop_ub = static_cast<int>(c_obj.Length);
            }

            value_size[0] = 1;
            value_size[1] = loop_ub;
            if (loop_ub - 1 >= 0) {
              ::std::copy(&c_obj.Vector[0], &c_obj.Vector[loop_ub], &value_data
                          [0]);
            }
          }
        }

        //
        // Arguments    : array<double, 2U> &limits
        // Return Type  : void
        //
        void b_RigidBodyTree::get_JointPositionLimits(array<double, 2U> &limits)
        {
          static const char b_cv[5]{ 'f', 'i', 'x', 'e', 'd' };

          RigidBody *body;
          rigidBodyJoint *obj;
          double d;
          double k;
          int i;
          int loop_ub;
          limits.set_size(static_cast<int>(PositionNumber), 2);
          loop_ub = static_cast<int>(PositionNumber) << 1;
          for (i = 0; i < loop_ub; i++) {
            limits[i] = 0.0;
          }

          k = 1.0;
          d = NumBodies;
          i = static_cast<int>(d);
          for (int b_i{0}; b_i < i; b_i++) {
            CharacterVector b_obj;
            int exitg1;
            int i1;
            int kstr;
            bool b_bool;
            body = Bodies[b_i];
            obj = body->JointInternal;
            b_obj = obj->TypeInternal;
            if (b_obj.Length < 1.0) {
              i1 = 0;
            } else {
              i1 = static_cast<int>(b_obj.Length);
            }

            b_bool = false;
            if (i1 == 5) {
              kstr = 0;
              do {
                exitg1 = 0;
                if (kstr < 5) {
                  if (b_obj.Vector[kstr] != b_cv[kstr]) {
                    exitg1 = 1;
                  } else {
                    kstr++;
                  }
                } else {
                  b_bool = true;
                  exitg1 = 1;
                }
              } while (exitg1 == 0);
            }

            if (!b_bool) {
              double tmp_data[14];
              double pnum;
              int i2;
              int i3;
              pnum = body->JointInternal->PositionNumber;
              d = k + pnum;
              if (k > d - 1.0) {
                i1 = 0;
                i2 = 0;
              } else {
                i1 = static_cast<int>(k) - 1;
                i2 = static_cast<int>(d - 1.0);
              }

              obj = body->JointInternal;
              b_obj = obj->TypeInternal;
              if (b_obj.Length < 1.0) {
                i3 = 0;
              } else {
                i3 = static_cast<int>(b_obj.Length);
              }

              b_bool = false;
              if (i3 == 5) {
                kstr = 0;
                do {
                  exitg1 = 0;
                  if (kstr < 5) {
                    if (b_obj.Vector[kstr] != b_cv[kstr]) {
                      exitg1 = 1;
                    } else {
                      kstr++;
                    }
                  } else {
                    b_bool = true;
                    exitg1 = 1;
                  }
                } while (exitg1 == 0);
              }

              if (!b_bool) {
                pnum = obj->PositionNumber;
                if (pnum < 1.0) {
                  loop_ub = 0;
                } else {
                  loop_ub = static_cast<int>(pnum);
                }

                for (i3 = 0; i3 < 2; i3++) {
                  for (kstr = 0; kstr < loop_ub; kstr++) {
                    tmp_data[kstr + loop_ub * i3] = obj->
                      PositionLimitsInternal[kstr + 7 * i3];
                  }
                }
              } else {
                loop_ub = 1;
                tmp_data[0] = 0.0;
                tmp_data[1] = 0.0;
              }

              kstr = i2 - i1;
              for (i2 = 0; i2 < 2; i2++) {
                for (i3 = 0; i3 < kstr; i3++) {
                  limits[(i1 + i3) + limits.size(0) * i2] = tmp_data[i3 +
                    loop_ub * i2];
                }
              }

              k = d;
            }
          }
        }

        //
        // Arguments    : double value_data[]
        //                int value_size[2]
        // Return Type  : void
        //
        void GIKProblem::get_KinematicPath(double value_data[], int value_size[2])
        {
          OrientationTarget *c_obj;
          PositionTarget *obj;
          RigidBody *body1;
          RigidBody *body2;
          b_RigidBodyTree *b_obj;
          array<double, 2U> b_value;
          array<double, 2U> c_value;
          double y_data[26];
          double bid1;
          double bid2;
          int idx_data[26];
          int iwork_data[26];
          int body2Name_size[2];
          int y_size[2];
          int b_i;
          int i;
          int j;
          int j2;
          int k;
          int n;
          int nb;
          int qEnd;
          char body1Name_data[200];
          char body2Name_data[200];
          bool exitg1;
          obj = Constraints.f1;
          b_obj = obj->Tree;
          obj->get_EndEffector(body1Name_data, y_size);
          obj->get_ReferenceBody(body2Name_data, body2Name_size);
          bid1 = b_obj->findBodyIndexByName(body1Name_data, y_size);
          bid2 = b_obj->findBodyIndexByName(body2Name_data, body2Name_size);
          if (bid1 == 0.0) {
            body1 = &b_obj->Base;
          } else {
            body1 = b_obj->Bodies[static_cast<int>(bid1) - 1];
          }

          if (bid2 == 0.0) {
            body2 = &b_obj->Base;
          } else {
            body2 = b_obj->Bodies[static_cast<int>(bid2) - 1];
          }

          b_obj->kinematicPathInternal(body1, body2, b_value);
          c_obj = Constraints.f2;
          b_obj = c_obj->Tree;
          c_obj->get_EndEffector(body1Name_data, y_size);
          c_obj->get_ReferenceBody(body2Name_data, body2Name_size);
          bid1 = b_obj->findBodyIndexByName(body1Name_data, y_size);
          bid2 = b_obj->findBodyIndexByName(body2Name_data, body2Name_size);
          if (bid1 == 0.0) {
            body1 = &b_obj->Base;
          } else {
            body1 = b_obj->Bodies[static_cast<int>(bid1) - 1];
          }

          if (bid2 == 0.0) {
            body2 = &b_obj->Base;
          } else {
            body2 = b_obj->Bodies[static_cast<int>(bid2) - 1];
          }

          b_obj->kinematicPathInternal(body1, body2, c_value);
          y_size[0] = 1;
          y_size[1] = b_value.size(1) + c_value.size(1);
          j2 = b_value.size(1);
          for (i = 0; i < j2; i++) {
            y_data[i] = b_value[i];
          }

          j2 = c_value.size(1);
          for (i = 0; i < j2; i++) {
            y_data[i + b_value.size(1)] = c_value[i];
          }

          ::coder::internal::sort(y_data, y_size);
          j2 = y_size[1];
          n = y_size[1] + 1;
          if (j2 - 1 >= 0) {
            std::memset(&idx_data[0], 0, static_cast<unsigned int>(j2) * sizeof
                        (int));
          }

          if (y_size[1] != 0) {
            i = y_size[1] - 1;
            for (k = 1; k <= i; k += 2) {
              bid1 = y_data[k];
              if ((y_data[k - 1] <= bid1) || std::isnan(bid1)) {
                idx_data[k - 1] = k;
                idx_data[k] = k + 1;
              } else {
                idx_data[k - 1] = k + 1;
                idx_data[k] = k;
              }
            }

            if ((static_cast<unsigned int>(y_size[1]) & 1U) != 0U) {
              idx_data[y_size[1] - 1] = y_size[1];
            }

            b_i = 2;
            while (b_i < n - 1) {
              nb = b_i << 1;
              j = 1;
              for (int pEnd{b_i + 1}; pEnd < n; pEnd = qEnd + b_i) {
                int kEnd;
                int p;
                int q;
                p = j;
                q = pEnd - 1;
                qEnd = j + nb;
                if (qEnd > n) {
                  qEnd = n;
                }

                k = 0;
                kEnd = qEnd - j;
                while (k + 1 <= kEnd) {
                  bid1 = y_data[idx_data[q] - 1];
                  i = idx_data[p - 1];
                  if ((y_data[i - 1] <= bid1) || std::isnan(bid1)) {
                    iwork_data[k] = i;
                    p++;
                    if (p == pEnd) {
                      while (q + 1 < qEnd) {
                        k++;
                        iwork_data[k] = idx_data[q];
                        q++;
                      }
                    }
                  } else {
                    iwork_data[k] = idx_data[q];
                    q++;
                    if (q + 1 == qEnd) {
                      while (p < pEnd) {
                        k++;
                        iwork_data[k] = idx_data[p - 1];
                        p++;
                      }
                    }
                  }

                  k++;
                }

                for (k = 0; k < kEnd; k++) {
                  idx_data[(j + k) - 1] = iwork_data[k];
                }

                j = qEnd;
              }

              b_i = nb;
            }
          }

          value_size[0] = 1;
          for (k = 0; k < j2; k++) {
            value_data[k] = y_data[idx_data[k] - 1];
          }

          k = 0;
          while ((k + 1 <= j2) && std::isinf(value_data[k]) && (value_data[k] <
                  0.0)) {
            k++;
          }

          n = k;
          k = y_size[1];
          while ((k >= 1) && std::isnan(value_data[k - 1])) {
            k--;
          }

          b_i = y_size[1] - k;
          exitg1 = false;
          while ((!exitg1) && (k >= 1)) {
            bid1 = value_data[k - 1];
            if (std::isinf(bid1) && (bid1 > 0.0)) {
              k--;
            } else {
              exitg1 = true;
            }
          }

          j2 = (y_size[1] - k) - b_i;
          nb = -1;
          if (n > 0) {
            nb = 0;
          }

          while (n + 1 <= k) {
            bid1 = value_data[n];
            do {
              n++;
            } while (!((n + 1 > k) || (value_data[n] != bid1)));

            nb++;
            value_data[nb] = bid1;
          }

          if (j2 > 0) {
            nb++;
            value_data[nb] = value_data[k];
          }

          n = k + j2;
          for (j = 0; j < b_i; j++) {
            value_data[(nb + j) + 1] = value_data[n + j];
          }

          if (b_i - 1 >= 0) {
            nb += b_i;
          }

          if (nb + 1 < 1) {
            value_size[1] = 0;
          } else {
            value_size[1] = nb + 1;
          }

          i = value_size[1] >> 1;
          for (n = 0; n < i; n++) {
            j2 = (value_size[1] - n) - 1;
            bid1 = value_data[n];
            value_data[n] = value_data[j2];
            value_data[j2] = bid1;
          }
        }

        //
        // Arguments    : char value_data[]
        //                int value_size[2]
        // Return Type  : void
        //
        void OrientationTarget::get_ReferenceBody(char value_data[], int
          value_size[2])
        {
          CharacterVector c_obj;
          RigidBody *b_obj;
          b_RigidBodyTree *obj;
          if (ReferenceBodyIndex > 0.0) {
            int loop_ub;
            b_obj = Tree->Bodies[static_cast<int>(ReferenceBodyIndex) - 1];
            c_obj = b_obj->NameInternal;
            if (c_obj.Length < 1.0) {
              loop_ub = 0;
            } else {
              loop_ub = static_cast<int>(c_obj.Length);
            }

            value_size[0] = 1;
            value_size[1] = loop_ub;
            if (loop_ub - 1 >= 0) {
              ::std::copy(&c_obj.Vector[0], &c_obj.Vector[loop_ub], &value_data
                          [0]);
            }
          } else {
            int loop_ub;
            obj = Tree;
            c_obj = obj->Base.NameInternal;
            if (c_obj.Length < 1.0) {
              loop_ub = 0;
            } else {
              loop_ub = static_cast<int>(c_obj.Length);
            }

            value_size[0] = 1;
            value_size[1] = loop_ub;
            if (loop_ub - 1 >= 0) {
              ::std::copy(&c_obj.Vector[0], &c_obj.Vector[loop_ub], &value_data
                          [0]);
            }
          }
        }

        //
        // Arguments    : char value_data[]
        //                int value_size[2]
        // Return Type  : void
        //
        void PositionTarget::get_ReferenceBody(char value_data[], int
          value_size[2])
        {
          CharacterVector c_obj;
          RigidBody *b_obj;
          b_RigidBodyTree *obj;
          if (ReferenceBodyIndex > 0.0) {
            int loop_ub;
            b_obj = Tree->Bodies[static_cast<int>(ReferenceBodyIndex) - 1];
            c_obj = b_obj->NameInternal;
            if (c_obj.Length < 1.0) {
              loop_ub = 0;
            } else {
              loop_ub = static_cast<int>(c_obj.Length);
            }

            value_size[0] = 1;
            value_size[1] = loop_ub;
            if (loop_ub - 1 >= 0) {
              ::std::copy(&c_obj.Vector[0], &c_obj.Vector[loop_ub], &value_data
                          [0]);
            }
          } else {
            int loop_ub;
            obj = Tree;
            c_obj = obj->Base.NameInternal;
            if (c_obj.Length < 1.0) {
              loop_ub = 0;
            } else {
              loop_ub = static_cast<int>(c_obj.Length);
            }

            value_size[0] = 1;
            value_size[1] = loop_ub;
            if (loop_ub - 1 >= 0) {
              ::std::copy(&c_obj.Vector[0], &c_obj.Vector[loop_ub], &value_data
                          [0]);
            }
          }
        }

        //
        // Arguments    : array<double, 2U> &b_value
        // Return Type  : void
        //
        void GIKProblem::get_WeightMatrix(array<double, 2U> &b_value) const
        {
          array<double, 2U> r3;
          array<double, 2U> v;
          array<double, 1U> r;
          array<int, 1U> r1;
          array<int, 1U> r2;
          double fullk;
          int i;
          int i1;
          int loop_ub;
          int loop_ub_tmp;
          int m_tmp;
          fullk = NumResiduals;
          if (fullk < 0.0) {
            fullk = 0.0;
          }

          m_tmp = static_cast<int>(fullk);
          b_value.set_size(static_cast<int>(fullk), static_cast<int>(fullk));
          loop_ub_tmp = static_cast<int>(fullk) * static_cast<int>(fullk);
          for (i = 0; i < loop_ub_tmp; i++) {
            b_value[i] = 0.0;
          }

          if (static_cast<int>(fullk) > 0) {
            for (loop_ub_tmp = 0; loop_ub_tmp < m_tmp; loop_ub_tmp++) {
              b_value[loop_ub_tmp + b_value.size(0) * loop_ub_tmp] = 1.0;
            }
          }

          loop_ub = ResidualIndices[0].f1.size(1);
          r.set_size(loop_ub);
          m_tmp = ResidualIndices[0].f1.size(1);
          for (i = 0; i < m_tmp; i++) {
            r[i] = ResidualIndices[0].f1[i];
          }

          r1.set_size(loop_ub);
          r2.set_size(loop_ub);
          for (i = 0; i < loop_ub; i++) {
            i1 = static_cast<int>(r[i]) - 1;
            r1[i] = i1;
            r2[i] = i1;
          }

          i = Constraints.f1->Weights.size(1);
          v.set_size(1, i);
          m_tmp = Constraints.f1->Weights.size(1);
          for (i1 = 0; i1 < m_tmp; i1++) {
            v[i1] = Constraints.f1->Weights[i1];
          }

          r3.set_size(i, i);
          loop_ub_tmp = v.size(1) * v.size(1);
          for (i1 = 0; i1 < loop_ub_tmp; i1++) {
            r3[i1] = 0.0;
          }

          for (m_tmp = 0; m_tmp < i; m_tmp++) {
            r3[m_tmp + r3.size(0) * m_tmp] = v[m_tmp];
          }

          for (i = 0; i < loop_ub; i++) {
            for (i1 = 0; i1 < loop_ub; i1++) {
              b_value[r1[i1] + b_value.size(0) * r2[i]] = r3[i1 + loop_ub * i];
            }
          }

          loop_ub = ResidualIndices[1].f1.size(1);
          r.set_size(loop_ub);
          m_tmp = ResidualIndices[1].f1.size(1);
          for (i = 0; i < m_tmp; i++) {
            r[i] = ResidualIndices[1].f1[i];
          }

          r1.set_size(loop_ub);
          r2.set_size(loop_ub);
          for (i = 0; i < loop_ub; i++) {
            i1 = static_cast<int>(r[i]) - 1;
            r1[i] = i1;
            r2[i] = i1;
          }

          i = Constraints.f2->Weights.size(1);
          v.set_size(1, i);
          m_tmp = Constraints.f2->Weights.size(1);
          for (i1 = 0; i1 < m_tmp; i1++) {
            v[i1] = Constraints.f2->Weights[i1];
          }

          r3.set_size(i, i);
          loop_ub_tmp = v.size(1) * v.size(1);
          for (i1 = 0; i1 < loop_ub_tmp; i1++) {
            r3[i1] = 0.0;
          }

          for (m_tmp = 0; m_tmp < i; m_tmp++) {
            r3[m_tmp + r3.size(0) * m_tmp] = v[m_tmp];
          }

          for (i = 0; i < loop_ub; i++) {
            for (i1 = 0; i1 < loop_ub; i1++) {
              b_value[r1[i1] + b_value.size(0) * r2[i]] = r3[i1 + loop_ub * i];
            }
          }
        }

        //
        // Arguments    : double maxElements
        // Return Type  : CollisionSet *
        //
        CollisionSet *CollisionSet::init(double maxElements)
        {
          static const void *t0_GeometryInternal{ nullptr };

          CollisionGeometry defaultGeometry;
          CollisionSet *obj;
          int size_tmp_idx_1;
          obj = this;
          obj->Size = 0.0;
          obj->MaxElements = maxElements;
          size_tmp_idx_1 = static_cast<int>(obj->MaxElements);
          obj->CollisionGeometries.set_size(1, size_tmp_idx_1);
          defaultGeometry.CollisionPrimitive = const_cast<void *>
            (t0_GeometryInternal);
          for (size_tmp_idx_1 = 0; size_tmp_idx_1 < 16; size_tmp_idx_1++) {
            defaultGeometry.LocalPose[size_tmp_idx_1] = iv[size_tmp_idx_1];
          }

          for (size_tmp_idx_1 = 0; size_tmp_idx_1 < 16; size_tmp_idx_1++) {
            defaultGeometry.WorldPose[size_tmp_idx_1] = iv[size_tmp_idx_1];
          }

          double d;
          defaultGeometry.MeshScale[0] = 1.0;
          defaultGeometry.MeshScale[1] = 1.0;
          defaultGeometry.MeshScale[2] = 1.0;
          d = obj->MaxElements;
          size_tmp_idx_1 = static_cast<int>(d);
          for (int i{0}; i < size_tmp_idx_1; i++) {
            obj->CollisionGeometries[i] = defaultGeometry;
          }

          obj->matlabCodegenIsDeleted = false;
          return obj;
        }

        //
        // Arguments    : void
        // Return Type  : RigidBodyTree *
        //
        RigidBodyTree *RigidBodyTree::init()
        {
          static const char jname[14]{ 'd', 'u', 'm', 'm', 'y', 'b', 'o', 'd',
            'y', '1', '_', 'j', 'n', 't' };

          CharacterVector s;
          RigidBodyTree *obj;
          double unusedExpr[5];
          obj = this;
          b_rand(unusedExpr);
          s.Length = 200.0;
          for (int i{0}; i < 200; i++) {
            s.Vector[i] = ' ';
          }

          obj->Base.NameInternal = s;
          s = obj->Base.NameInternal;
          s.Length = 4.0;
          s.Vector[0] = 'b';
          s.Vector[1] = 'a';
          s.Vector[2] = 's';
          s.Vector[3] = 'e';
          obj->Base.NameInternal = s;
          obj->Base.JointInternal.init();
          obj->Base.CollisionsInternal.init(static_cast<double>(0.0));
          obj->Base.matlabCodegenIsDeleted = false;
          s.Length = 200.0;
          for (int i{0}; i < 200; i++) {
            s.Vector[i] = ' ';
          }

          obj->_pobj0.NameInternal = s;
          s = obj->_pobj0.NameInternal;
          s.Length = 10.0;
          for (int i{0}; i < 10; i++) {
            s.Vector[i] = cv[i];
          }

          obj->_pobj0.NameInternal = s;
          obj->_pobj0.JointInternal.init(jname);
          obj->_pobj0.CollisionsInternal.init(static_cast<double>(0.0));
          obj->_pobj0.matlabCodegenIsDeleted = false;
          obj->Bodies[0] = &obj->_pobj0;
          b_rand(unusedExpr);
          obj->matlabCodegenIsDeleted = false;
          return obj;
        }

        //
        // Arguments    : void
        // Return Type  : b_RigidBodyTree *
        //
        b_RigidBodyTree *b_RigidBodyTree::init()
        {
          static const signed char b_iv[24]{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 };

          static const char cv10[11]{ 'd', 'u', 'm', 'm', 'y', 'b', 'o', 'd',
            'y', '1', '2' };

          static const char cv8[11]{ 'd', 'u', 'm', 'm', 'y', 'b', 'o', 'd', 'y',
            '1', '0' };

          static const char cv9[11]{ 'd', 'u', 'm', 'm', 'y', 'b', 'o', 'd', 'y',
            '1', '1' };

          static const char b_cv[10]{ 'd', 'u', 'm', 'm', 'y', 'b', 'o', 'd',
            'y', '2' };

          static const char b_cv1[10]{ 'd', 'u', 'm', 'm', 'y', 'b', 'o', 'd',
            'y', '3' };

          static const char b_cv2[10]{ 'd', 'u', 'm', 'm', 'y', 'b', 'o', 'd',
            'y', '4' };

          static const char b_cv3[10]{ 'd', 'u', 'm', 'm', 'y', 'b', 'o', 'd',
            'y', '5' };

          static const char b_cv4[10]{ 'd', 'u', 'm', 'm', 'y', 'b', 'o', 'd',
            'y', '6' };

          static const char b_cv5[10]{ 'd', 'u', 'm', 'm', 'y', 'b', 'o', 'd',
            'y', '7' };

          static const char cv6[10]{ 'd', 'u', 'm', 'm', 'y', 'b', 'o', 'd', 'y',
            '8' };

          static const char cv7[10]{ 'd', 'u', 'm', 'm', 'y', 'b', 'o', 'd', 'y',
            '9' };

          CharacterVector s;
          b_RigidBodyTree *obj;
          double unusedExpr[5];
          signed char c_I[36];
          signed char b_I[9];
          obj = this;
          b_rand(unusedExpr);
          s.Length = 200.0;
          for (int k{0}; k < 200; k++) {
            s.Vector[k] = ' ';
          }

          obj->Base.NameInternal = s;
          s = obj->Base.NameInternal;
          s.Length = 4.0;
          s.Vector[0] = 'b';
          s.Vector[1] = 'a';
          s.Vector[2] = 's';
          s.Vector[3] = 'e';
          obj->Base.NameInternal = s;
          obj->Base.JointInternal = obj->Base._pobj1.init();
          obj->Base.Index = -1.0;
          obj->Base.ParentIndex = -1.0;
          obj->Base.MassInternal = 1.0;
          obj->Base.CenterOfMassInternal[0] = 0.0;
          obj->Base.CenterOfMassInternal[1] = 0.0;
          obj->Base.CenterOfMassInternal[2] = 0.0;
          for (int k{0}; k < 9; k++) {
            b_I[k] = 0;
          }

          b_I[0] = 1;
          b_I[4] = 1;
          b_I[8] = 1;
          for (int k{0}; k < 9; k++) {
            obj->Base.InertiaInternal[k] = b_I[k];
          }

          for (int k{0}; k < 36; k++) {
            c_I[k] = 0;
          }

          for (int k{0}; k < 6; k++) {
            c_I[k + 6 * k] = 1;
          }

          for (int k{0}; k < 36; k++) {
            obj->Base.SpatialInertia[k] = c_I[k];
          }

          obj->Base.CollisionsInternal = obj->Base._pobj0.init(static_cast<
            double>(0.0));
          obj->Base.matlabCodegenIsDeleted = false;
          obj->Base.Index = 0.0;
          obj->Gravity[0] = 0.0;
          obj->Gravity[1] = 0.0;
          obj->Gravity[2] = 0.0;
          obj->Bodies[0] = obj->_pobj2[0].init(cv);
          obj->Bodies[1] = obj->_pobj2[1].init(b_cv);
          obj->Bodies[2] = obj->_pobj2[2].init(b_cv1);
          obj->Bodies[3] = obj->_pobj2[3].init(b_cv2);
          obj->Bodies[4] = obj->_pobj2[4].init(b_cv3);
          obj->Bodies[5] = obj->_pobj2[5].init(b_cv4);
          obj->Bodies[6] = obj->_pobj2[6].init(b_cv5);
          obj->Bodies[7] = obj->_pobj2[7].init(cv6);
          obj->Bodies[8] = obj->_pobj2[8].init(cv7);
          obj->Bodies[9] = obj->_pobj2[9].init(cv8, obj->_pobj0[0], obj->_pobj1
            [0]);
          obj->Bodies[10] = obj->_pobj2[10].init(cv9, obj->_pobj0[1],
            obj->_pobj1[1]);
          obj->Bodies[11] = obj->_pobj2[11].init(cv10, obj->_pobj0[2],
            obj->_pobj1[2]);
          obj->NumBodies = 0.0;
          obj->NumNonFixedBodies = 0.0;
          obj->PositionNumber = 0.0;
          obj->VelocityNumber = 0.0;
          b_rand(unusedExpr);
          for (int k{0}; k < 24; k++) {
            obj->PositionDoFMap[k] = b_iv[k];
          }

          for (int k{0}; k < 24; k++) {
            obj->VelocityDoFMap[k] = b_iv[k];
          }

          obj->matlabCodegenIsDeleted = false;
          return obj;
        }

        //
        // Arguments    : const char bodyInput[10]
        // Return Type  : RigidBody *
        //
        RigidBody *RigidBody::init(const char bodyInput[10])
        {
          CharacterVector s;
          RigidBody *obj;
          signed char c_I[36];
          char b_bodyInput[14];
          signed char b_I[9];
          obj = this;
          s.Length = 200.0;
          for (int k{0}; k < 200; k++) {
            s.Vector[k] = ' ';
          }

          obj->NameInternal = s;
          s = obj->NameInternal;
          s.Length = 10.0;
          for (int k{0}; k < 10; k++) {
            s.Vector[k] = bodyInput[k];
          }

          obj->NameInternal = s;
          for (int k{0}; k < 10; k++) {
            b_bodyInput[k] = bodyInput[k];
          }

          b_bodyInput[10] = '_';
          b_bodyInput[11] = 'j';
          b_bodyInput[12] = 'n';
          b_bodyInput[13] = 't';
          obj->JointInternal = obj->_pobj1.init(b_bodyInput);
          obj->Index = -1.0;
          obj->ParentIndex = -1.0;
          obj->MassInternal = 1.0;
          obj->CenterOfMassInternal[0] = 0.0;
          obj->CenterOfMassInternal[1] = 0.0;
          obj->CenterOfMassInternal[2] = 0.0;
          for (int k{0}; k < 9; k++) {
            b_I[k] = 0;
          }

          b_I[0] = 1;
          b_I[4] = 1;
          b_I[8] = 1;
          for (int k{0}; k < 9; k++) {
            obj->InertiaInternal[k] = b_I[k];
          }

          for (int k{0}; k < 36; k++) {
            c_I[k] = 0;
          }

          for (int k{0}; k < 6; k++) {
            c_I[k + 6 * k] = 1;
          }

          for (int k{0}; k < 36; k++) {
            obj->SpatialInertia[k] = c_I[k];
          }

          obj->CollisionsInternal = obj->_pobj0.init(static_cast<double>(0.0));
          obj->matlabCodegenIsDeleted = false;
          return obj;
        }

        //
        // Arguments    : const char bodyInput[11]
        //                CollisionSet &iobj_0
        //                rigidBodyJoint &iobj_1
        // Return Type  : RigidBody *
        //
        RigidBody *RigidBody::init(const char bodyInput[11], CollisionSet &
          iobj_0, rigidBodyJoint &iobj_1)
        {
          static const char b_cv1[8]{ 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };

          static const char b_cv2[8]{ 'f', 'l', 'o', 'a', 't', 'i', 'n', 'g' };

          static const signed char iv2[7]{ 1, 0, 0, 0, 0, 0, 0 };

          static const signed char b_iv[6]{ 0, 0, 1, 0, 0, 0 };

          static const signed char b_iv1[6]{ 0, 0, 0, 0, 0, 1 };

          static const char b_cv[5]{ 'f', 'i', 'x', 'e', 'd' };

          static const char b_cv3[5]{ 'f', 'i', 'x', 'e', 'd' };

          CharacterVector s;
          RigidBody *obj;
          double msubspace_data[36];
          double poslim_data[14];
          int exitg1;
          int homepos_size_idx_1;
          int i;
          int i1;
          int ibmat;
          int poslim_size_idx_0;
          signed char b_I[36];
          signed char c_I[9];
          signed char homepos_data[7];
          bool result;
          obj = this;
          s.Length = 200.0;
          for (i = 0; i < 200; i++) {
            s.Vector[i] = ' ';
          }

          obj->NameInternal = s;
          s = obj->NameInternal;
          s.Length = 11.0;
          for (i = 0; i < 11; i++) {
            s.Vector[i] = bodyInput[i];
          }

          obj->NameInternal = s;
          iobj_1.InTree = false;
          for (i = 0; i < 16; i++) {
            i1 = iv[i];
            iobj_1.JointToParentTransform[i] = i1;
            iobj_1.ChildToJointTransform[i] = i1;
          }

          for (i = 0; i < 14; i++) {
            iobj_1.PositionLimitsInternal[i] = 0.0;
          }

          for (i = 0; i < 7; i++) {
            iobj_1.HomePositionInternal[i] = 0.0;
          }

          for (i = 0; i < 36; i++) {
            iobj_1.MotionSubspaceInternal[i] = 0.0;
          }

          s.Length = 200.0;
          for (i = 0; i < 200; i++) {
            s.Vector[i] = ' ';
          }

          iobj_1.NameInternal = s;
          s.Length = 200.0;
          for (i = 0; i < 200; i++) {
            s.Vector[i] = ' ';
          }

          iobj_1.TypeInternal = s;
          s = iobj_1.NameInternal;
          s.Length = 15.0;
          for (i = 0; i < 11; i++) {
            s.Vector[i] = bodyInput[i];
          }

          s.Vector[11] = '_';
          s.Vector[12] = 'j';
          s.Vector[13] = 'n';
          s.Vector[14] = 't';
          iobj_1.NameInternal = s;
          s = iobj_1.TypeInternal;
          s.Length = 5.0;
          for (i = 0; i < 5; i++) {
            s.Vector[i] = b_cv[i];
          }

          iobj_1.TypeInternal = s;
          s = iobj_1.TypeInternal;
          if (s.Length < 1.0) {
            i = 0;
          } else {
            i = static_cast<int>(s.Length);
          }

          result = false;
          if (i == 8) {
            ibmat = 0;
            do {
              exitg1 = 0;
              if (ibmat < 8) {
                if (b_cv1[ibmat] != s.Vector[ibmat]) {
                  exitg1 = 1;
                } else {
                  ibmat++;
                }
              } else {
                result = true;
                exitg1 = 1;
              }
            } while (exitg1 == 0);
          }

          if (result) {
            ibmat = 0;
          } else {
            result = false;
            if (i == 9) {
              ibmat = 0;
              do {
                exitg1 = 0;
                if (ibmat < 9) {
                  if (cv1[ibmat] != s.Vector[ibmat]) {
                    exitg1 = 1;
                  } else {
                    ibmat++;
                  }
                } else {
                  result = true;
                  exitg1 = 1;
                }
              } while (exitg1 == 0);
            }

            if (result) {
              ibmat = 1;
            } else {
              result = false;
              if (i == 8) {
                ibmat = 0;
                do {
                  exitg1 = 0;
                  if (ibmat < 8) {
                    if (b_cv2[ibmat] != s.Vector[ibmat]) {
                      exitg1 = 1;
                    } else {
                      ibmat++;
                    }
                  } else {
                    result = true;
                    exitg1 = 1;
                  }
                } while (exitg1 == 0);
              }

              if (result) {
                ibmat = 2;
              } else {
                ibmat = -1;
              }
            }
          }

          switch (ibmat) {
           case 0:
            for (i = 0; i < 6; i++) {
              msubspace_data[i] = b_iv[i];
            }

            poslim_size_idx_0 = 1;
            poslim_data[0] = -3.1415926535897931;
            poslim_data[1] = 3.1415926535897931;
            homepos_size_idx_1 = 1;
            homepos_data[0] = 0;
            iobj_1.VelocityNumber = 1.0;
            iobj_1.PositionNumber = 1.0;
            iobj_1.JointAxisInternal[0] = 0.0;
            iobj_1.JointAxisInternal[1] = 0.0;
            iobj_1.JointAxisInternal[2] = 1.0;
            break;

           case 1:
            for (i = 0; i < 6; i++) {
              msubspace_data[i] = b_iv1[i];
            }

            poslim_size_idx_0 = 1;
            poslim_data[0] = -0.5;
            poslim_data[1] = 0.5;
            homepos_size_idx_1 = 1;
            homepos_data[0] = 0;
            iobj_1.VelocityNumber = 1.0;
            iobj_1.PositionNumber = 1.0;
            iobj_1.JointAxisInternal[0] = 0.0;
            iobj_1.JointAxisInternal[1] = 0.0;
            iobj_1.JointAxisInternal[2] = 1.0;
            break;

           case 2:
            {
              signed char b[6];
              for (i = 0; i < 36; i++) {
                b_I[i] = 0;
              }

              for (ibmat = 0; ibmat < 6; ibmat++) {
                b_I[ibmat + 6 * ibmat] = 1;
              }

              for (i = 0; i < 36; i++) {
                msubspace_data[i] = b_I[i];
              }

              poslim_size_idx_0 = 7;
              for (homepos_size_idx_1 = 0; homepos_size_idx_1 < 2;
                   homepos_size_idx_1++) {
                signed char b_tmp;
                ibmat = homepos_size_idx_1 * 3;
                b_tmp = static_cast<signed char>(10 * homepos_size_idx_1 - 5);
                b[ibmat] = b_tmp;
                b[ibmat + 1] = b_tmp;
                b[ibmat + 2] = b_tmp;
                poslim_data[7 * homepos_size_idx_1] = rtNaN;
                poslim_data[7 * homepos_size_idx_1 + 1] = rtNaN;
                poslim_data[7 * homepos_size_idx_1 + 2] = rtNaN;
                poslim_data[7 * homepos_size_idx_1 + 3] = rtNaN;
              }

              for (i = 0; i < 2; i++) {
                poslim_data[7 * i + 4] = b[3 * i];
                poslim_data[7 * i + 5] = b[3 * i + 1];
                poslim_data[7 * i + 6] = b[3 * i + 2];
              }

              homepos_size_idx_1 = 7;
              for (i = 0; i < 7; i++) {
                homepos_data[i] = iv2[i];
              }

              iobj_1.VelocityNumber = 6.0;
              iobj_1.PositionNumber = 7.0;
              iobj_1.JointAxisInternal[0] = rtNaN;
              iobj_1.JointAxisInternal[1] = rtNaN;
              iobj_1.JointAxisInternal[2] = rtNaN;
            }
            break;

           default:
            for (i = 0; i < 6; i++) {
              msubspace_data[i] = 0.0;
            }

            poslim_size_idx_0 = 1;
            poslim_data[0] = 0.0;
            poslim_data[1] = 0.0;
            homepos_size_idx_1 = 1;
            homepos_data[0] = 0;
            iobj_1.VelocityNumber = 0.0;
            iobj_1.PositionNumber = 0.0;
            iobj_1.JointAxisInternal[0] = 0.0;
            iobj_1.JointAxisInternal[1] = 0.0;
            iobj_1.JointAxisInternal[2] = 0.0;
            break;
          }

          iobj_1.set_MotionSubspace(msubspace_data);
          s = iobj_1.TypeInternal;
          if (s.Length < 1.0) {
            i = 0;
          } else {
            i = static_cast<int>(s.Length);
          }

          result = false;
          if (i == 5) {
            ibmat = 0;
            do {
              exitg1 = 0;
              if (ibmat < 5) {
                if (s.Vector[ibmat] != b_cv3[ibmat]) {
                  exitg1 = 1;
                } else {
                  ibmat++;
                }
              } else {
                result = true;
                exitg1 = 1;
              }
            } while (exitg1 == 0);
          }

          if (!result) {
            double d;
            d = iobj_1.PositionNumber;
            if (d < 1.0) {
              ibmat = 0;
            } else {
              ibmat = static_cast<int>(d);
            }

            for (i = 0; i < 2; i++) {
              for (i1 = 0; i1 < ibmat; i1++) {
                iobj_1.PositionLimitsInternal[i1 + 7 * i] = poslim_data[i1 +
                  poslim_size_idx_0 * i];
              }
            }

            for (i = 0; i < homepos_size_idx_1; i++) {
              iobj_1.HomePositionInternal[i] = homepos_data[i];
            }
          } else {
            iobj_1.PositionLimitsInternal[0] = poslim_data[0];
            iobj_1.PositionLimitsInternal[7] = poslim_data[1];
            iobj_1.HomePositionInternal[0] = homepos_data[0];
          }

          obj->JointInternal = &iobj_1;
          obj->Index = -1.0;
          obj->ParentIndex = -1.0;
          obj->MassInternal = 1.0;
          obj->CenterOfMassInternal[0] = 0.0;
          obj->CenterOfMassInternal[1] = 0.0;
          obj->CenterOfMassInternal[2] = 0.0;
          for (i = 0; i < 9; i++) {
            c_I[i] = 0;
          }

          c_I[0] = 1;
          c_I[4] = 1;
          c_I[8] = 1;
          for (i = 0; i < 9; i++) {
            obj->InertiaInternal[i] = c_I[i];
          }

          for (i = 0; i < 36; i++) {
            b_I[i] = 0;
          }

          for (ibmat = 0; ibmat < 6; ibmat++) {
            b_I[ibmat + 6 * ibmat] = 1;
          }

          for (i = 0; i < 36; i++) {
            obj->SpatialInertia[i] = b_I[i];
          }

          obj->CollisionsInternal = iobj_0.init(static_cast<double>(0.0));
          obj->matlabCodegenIsDeleted = false;
          return obj;
        }

        //
        // Arguments    : RigidBody *body1
        //                RigidBody *body2
        //                array<double, 2U> &indices
        // Return Type  : void
        //
        void b_RigidBodyTree::kinematicPathInternal(RigidBody *body1, RigidBody *
          body2, array<double, 2U> &indices)
        {
          array<double, 2U> ancestorIndices1;
          array<double, 2U> ancestorIndices2;
          int b_i;
          int b_loop_ub;
          int i;
          int i1;
          int loop_ub;
          int minPathLength;
          bool exitg1;
          ancestorIndices(body1, ancestorIndices1);
          ancestorIndices(body2, ancestorIndices2);
          minPathLength = static_cast<int>(std::fmin(static_cast<double>
            (ancestorIndices1.size(1)), static_cast<double>
            (ancestorIndices2.size(1))));
          i = 2;
          exitg1 = false;
          while ((!exitg1) && (i - 2 <= minPathLength - 2)) {
            if (ancestorIndices1[ancestorIndices1.size(1) - i] !=
                ancestorIndices2[ancestorIndices2.size(1) - i]) {
              minPathLength = i - 1;
              exitg1 = true;
            } else {
              i++;
            }
          }

          b_i = ancestorIndices1.size(1) - minPathLength;
          if (b_i < 1) {
            loop_ub = 0;
          } else {
            loop_ub = b_i;
          }

          i = ancestorIndices2.size(1) - minPathLength;
          if (i < 1) {
            i = 0;
            minPathLength = 1;
            i1 = -1;
          } else {
            i--;
            minPathLength = -1;
            i1 = 0;
          }

          b_loop_ub = div_s32(i1 - i, minPathLength);
          indices.set_size(1, (loop_ub + b_loop_ub) + 2);
          for (i1 = 0; i1 < loop_ub; i1++) {
            indices[i1] = ancestorIndices1[i1];
          }

          indices[loop_ub] = ancestorIndices1[b_i];
          for (b_i = 0; b_i <= b_loop_ub; b_i++) {
            indices[(b_i + loop_ub) + 1] = ancestorIndices2[i + minPathLength *
              b_i];
          }
        }

        //
        // Arguments    : void
        // Return Type  : void
        //
        void RigidBodyTree::matlabCodegenDestructor()
        {
          if (!matlabCodegenIsDeleted) {
            matlabCodegenIsDeleted = true;
          }
        }

        //
        // Arguments    : void
        // Return Type  : void
        //
        void OrientationTarget::matlabCodegenDestructor()
        {
          if (!matlabCodegenIsDeleted) {
            matlabCodegenIsDeleted = true;
          }
        }

        //
        // Arguments    : void
        // Return Type  : void
        //
        void b_RigidBody::matlabCodegenDestructor()
        {
          if (!matlabCodegenIsDeleted) {
            matlabCodegenIsDeleted = true;
          }
        }

        //
        // Arguments    : void
        // Return Type  : void
        //
        void b_RigidBodyTree::matlabCodegenDestructor()
        {
          if (!matlabCodegenIsDeleted) {
            matlabCodegenIsDeleted = true;
          }
        }

        //
        // Arguments    : void
        // Return Type  : void
        //
        void RigidBody::matlabCodegenDestructor()
        {
          if (!matlabCodegenIsDeleted) {
            matlabCodegenIsDeleted = true;
          }
        }

        //
        // Arguments    : void
        // Return Type  : void
        //
        void CollisionSet::matlabCodegenDestructor()
        {
          CollisionGeometry obj;
          if (!matlabCodegenIsDeleted) {
            double d;
            int i;
            matlabCodegenIsDeleted = true;
            d = Size;
            i = static_cast<int>(d);
            for (int b_i{0}; b_i < i; b_i++) {
              obj = CollisionGeometries[b_i];
              collisioncodegen_destructGeometry(&obj.CollisionPrimitive);
              CollisionGeometries[b_i] = obj;
            }
          }
        }

        //
        // Arguments    : void
        // Return Type  : void
        //
        void GIKProblem::matlabCodegenDestructor()
        {
          if (!matlabCodegenIsDeleted) {
            matlabCodegenIsDeleted = true;
          }
        }

        //
        // Arguments    : void
        // Return Type  : void
        //
        void PositionTarget::matlabCodegenDestructor()
        {
          if (!matlabCodegenIsDeleted) {
            matlabCodegenIsDeleted = true;
          }
        }

        //
        // Arguments    : const array<double, 1U> &x
        //                array<double, 1U> &f
        // Return Type  : void
        //
        void GIKProblem::residuals(const array<double, 1U> &x, array<double, 1U>
          &f)
        {
          array<double, 2U> J;
          double d;
          int i;
          bool flag;
          flag = true;
          d = NumVariables;
          i = 0;
          int exitg1;
          do {
            exitg1 = 0;
            if (i <= static_cast<int>(d) - 1) {
              if (x[i] != LastX[i]) {
                exitg1 = 1;
              } else {
                i++;
              }
            } else {
              flag = false;
              exitg1 = 1;
            }
          } while (exitg1 == 0);

          if (flag) {
            residualsInternal(x, f, J);
            i = x.size(0);
            LastX.set_size(x.size(0));
            for (int b_i{0}; b_i < i; b_i++) {
              LastX[b_i] = x[b_i];
            }

            i = f.size(0);
            LastF.set_size(f.size(0));
            for (int b_i{0}; b_i < i; b_i++) {
              LastF[b_i] = f[b_i];
            }

            LastJ.set_size(J.size(0), J.size(1));
            i = J.size(0) * J.size(1);
            for (int b_i{0}; b_i < i; b_i++) {
              LastJ[b_i] = J[b_i];
            }
          } else {
            f.set_size(LastF.size(0));
            i = LastF.size(0);
            for (int b_i{0}; b_i < i; b_i++) {
              f[b_i] = LastF[b_i];
            }
          }
        }

        //
        // Arguments    : const array<double, 1U> &x
        //                array<double, 1U> &f
        //                array<double, 2U> &J
        // Return Type  : void
        //
        void GIKProblem::residuals(const array<double, 1U> &x, array<double, 1U>
          &f, array<double, 2U> &J)
        {
          double d;
          int i;
          bool flag;
          flag = true;
          d = NumVariables;
          i = 0;
          int exitg1;
          do {
            exitg1 = 0;
            if (i <= static_cast<int>(d) - 1) {
              if (x[i] != LastX[i]) {
                exitg1 = 1;
              } else {
                i++;
              }
            } else {
              flag = false;
              exitg1 = 1;
            }
          } while (exitg1 == 0);

          if (flag) {
            residualsInternal(x, f, J);
            i = x.size(0);
            LastX.set_size(x.size(0));
            for (int b_i{0}; b_i < i; b_i++) {
              LastX[b_i] = x[b_i];
            }

            i = f.size(0);
            LastF.set_size(f.size(0));
            for (int b_i{0}; b_i < i; b_i++) {
              LastF[b_i] = f[b_i];
            }

            LastJ.set_size(J.size(0), J.size(1));
            i = J.size(0) * J.size(1);
            for (int b_i{0}; b_i < i; b_i++) {
              LastJ[b_i] = J[b_i];
            }
          } else {
            f.set_size(LastF.size(0));
            i = LastF.size(0);
            for (int b_i{0}; b_i < i; b_i++) {
              f[b_i] = LastF[b_i];
            }

            J.set_size(LastJ.size(0), LastJ.size(1));
            i = LastJ.size(0) * LastJ.size(1);
            for (int b_i{0}; b_i < i; b_i++) {
              J[b_i] = LastJ[b_i];
            }
          }
        }

        //
        // Arguments    : const array<double, 1U> &x
        //                array<double, 1U> &f
        //                array<double, 2U> &J
        // Return Type  : void
        //
        void GIKProblem::residualsInternal(const array<double, 1U> &x, array<
          double, 1U> &f, array<double, 2U> &J)
        {
          OrientationTarget *b_obj;
          PositionTarget *obj;
          array<double, 2U> C;
          array<double, 2U> Jrobot;
          array<double, 2U> b_Jrobot;
          array<double, 2U> cols;
          array<double, 2U> r3;
          array<double, 2U> rows;
          array<double, 1U> q;
          array<double, 1U> slacks;
          array<int, 2U> r1;
          array<int, 1U> r;
          array<int, 1U> r4;
          array<int, 1U> r5;
          array<int, 1U> r6;
          array<int, 1U> r7;
          array<signed char, 2U> r2;
          double T_data[16];
          double A[6];
          double JTwist[6];
          double d;
          double g;
          double gCell_idx_1;
          double posErr_idx_0;
          double posErr_idx_1;
          double posErr_idx_2;
          int T_size[2];
          int b_loop_ub;
          int boffset;
          int c_loop_ub;
          int loop_ub;
          int ndx_tmp_idx_0;
          d = NumPositions;
          if (d < 1.0) {
            loop_ub = 0;
          } else {
            loop_ub = static_cast<int>(d);
          }

          q.set_size(loop_ub);
          for (int j{0}; j < loop_ub; j++) {
            q[j] = x[j];
          }

          obj = Constraints.f1;
          obj->Tree->efficientFKAndJacobianForIK(q, obj->EndEffectorIndex,
            obj->ReferenceBodyIndex, T_data, T_size, Jrobot);
          posErr_idx_0 = obj->TargetPosition[0] - T_data[T_size[0] * 3];
          posErr_idx_1 = obj->TargetPosition[1] - T_data[T_size[0] * 3 + 1];
          posErr_idx_2 = obj->TargetPosition[2] - T_data[T_size[0] * 3 + 2];
          g = std::sqrt(((posErr_idx_0 * posErr_idx_0 + posErr_idx_1 *
                          posErr_idx_1) + posErr_idx_2 * posErr_idx_2) +
                        2.2204460492503131E-16);
          b_obj = Constraints.f2;
          b_obj->Tree->efficientFKAndJacobianForIK(q, b_obj->EndEffectorIndex,
            b_obj->ReferenceBodyIndex, T_data, T_size, b_Jrobot);
          gCell_idx_1 = b_obj->evaluateFromTransform(T_data, T_size, JTwist);
          f.set_size(static_cast<int>(NumResiduals));
          loop_ub = static_cast<int>(NumResiduals);
          for (int j{0}; j < loop_ub; j++) {
            f[j] = 0.0;
          }

          ndx_tmp_idx_0 = static_cast<int>(NumResiduals);
          J.set_size(ndx_tmp_idx_0, static_cast<int>(NumVariables));
          loop_ub = static_cast<int>(NumResiduals) * static_cast<int>
            (NumVariables);
          for (int j{0}; j < loop_ub; j++) {
            J[j] = 0.0;
          }

          loop_ub = ResidualIndices[0].f1.size(1);
          rows.set_size(1, loop_ub);
          b_loop_ub = ResidualIndices[0].f1.size(1);
          for (int j{0}; j < b_loop_ub; j++) {
            rows[j] = ResidualIndices[0].f1[j];
          }

          b_loop_ub = SlackIndices[0].f1.size(1);
          cols.set_size(1, b_loop_ub);
          c_loop_ub = SlackIndices[0].f1.size(1);
          for (int j{0}; j < c_loop_ub; j++) {
            cols[j] = SlackIndices[0].f1[j];
          }

          d = NumPositions;
          q.set_size(loop_ub);
          for (int j{0}; j < loop_ub; j++) {
            q[j] = rows[j];
          }

          r.set_size(loop_ub);
          for (int j{0}; j < loop_ub; j++) {
            r[j] = static_cast<int>(q[j]) - 1;
          }

          A[0] = -0.0;
          A[3] = -(posErr_idx_0 / g);
          A[1] = -0.0;
          A[4] = -(posErr_idx_1 / g);
          A[2] = -0.0;
          A[5] = -(posErr_idx_2 / g);
          c_loop_ub = Jrobot.size(1);
          C.set_size(1, Jrobot.size(1));
          for (int j{0}; j < c_loop_ub; j++) {
            boffset = j * 6;
            posErr_idx_0 = 0.0;
            for (int k{0}; k < 6; k++) {
              posErr_idx_0 += A[k] * Jrobot[boffset + k];
            }

            C[j] = posErr_idx_0;
          }

          if (d < 1.0) {
            c_loop_ub = 0;
          } else {
            c_loop_ub = static_cast<int>(d);
          }

          for (int j{0}; j < c_loop_ub; j++) {
            for (boffset = 0; boffset < loop_ub; boffset++) {
              J[r[boffset] + J.size(0) * j] = C[boffset + loop_ub * j];
            }
          }

          slacks.set_size(b_loop_ub);
          for (int j{0}; j < b_loop_ub; j++) {
            slacks[j] = x[static_cast<int>(cols[j]) - 1];
          }

          r1.set_size(1, loop_ub);
          for (int j{0}; j < loop_ub; j++) {
            r1[j] = static_cast<int>(rows[j]) + ndx_tmp_idx_0 * (static_cast<int>
              (cols[j]) - 1);
          }

          r2.set_size(EqualityFlags[0].f1.size(0), EqualityFlags[0].f1.size(1));
          b_loop_ub = EqualityFlags[0].f1.size(0) * EqualityFlags[0].f1.size(1);
          for (int j{0}; j < b_loop_ub; j++) {
            r2[j] = static_cast<signed char>(-!EqualityFlags[0].f1[j]);
          }

          for (int j{0}; j < loop_ub; j++) {
            J[r1[j] - 1] = r2[j];
          }

          r3.set_size(Constraints.f1->BoundsInternal.size(0), 2);
          b_loop_ub = Constraints.f1->BoundsInternal.size(0) << 1;
          for (int j{0}; j < b_loop_ub; j++) {
            r3[j] = Constraints.f1->BoundsInternal[j];
          }

          boffset = EqualityFlags[0].f1.size(0) * EqualityFlags[0].f1.size(1);
          c_loop_ub = 0;
          for (b_loop_ub = 0; b_loop_ub < boffset; b_loop_ub++) {
            if (EqualityFlags[0].f1[b_loop_ub]) {
              c_loop_ub++;
            }
          }

          r4.set_size(c_loop_ub);
          c_loop_ub = 0;
          for (b_loop_ub = 0; b_loop_ub < boffset; b_loop_ub++) {
            if (EqualityFlags[0].f1[b_loop_ub]) {
              r4[c_loop_ub] = b_loop_ub;
              c_loop_ub++;
            }
          }

          boffset = EqualityFlags[0].f1.size(0) * EqualityFlags[0].f1.size(1);
          c_loop_ub = 0;
          for (b_loop_ub = 0; b_loop_ub < boffset; b_loop_ub++) {
            if (EqualityFlags[0].f1[b_loop_ub]) {
              c_loop_ub++;
            }
          }

          r5.set_size(c_loop_ub);
          c_loop_ub = 0;
          for (b_loop_ub = 0; b_loop_ub < boffset; b_loop_ub++) {
            if (EqualityFlags[0].f1[b_loop_ub]) {
              r5[c_loop_ub] = b_loop_ub;
              c_loop_ub++;
            }
          }

          b_loop_ub = r5.size(0);
          for (int j{0}; j < b_loop_ub; j++) {
            slacks[r4[j]] = r3[r5[j]];
          }

          r.set_size(loop_ub);
          for (int j{0}; j < loop_ub; j++) {
            r[j] = static_cast<int>(q[j]) - 1;
          }

          for (int j{0}; j < loop_ub; j++) {
            f[r[j]] = g - slacks[j];
          }

          loop_ub = ResidualIndices[1].f1.size(1);
          rows.set_size(1, loop_ub);
          b_loop_ub = ResidualIndices[1].f1.size(1);
          for (int j{0}; j < b_loop_ub; j++) {
            rows[j] = ResidualIndices[1].f1[j];
          }

          b_loop_ub = SlackIndices[1].f1.size(1);
          cols.set_size(1, b_loop_ub);
          c_loop_ub = SlackIndices[1].f1.size(1);
          for (int j{0}; j < c_loop_ub; j++) {
            cols[j] = SlackIndices[1].f1[j];
          }

          d = NumPositions;
          q.set_size(loop_ub);
          for (int j{0}; j < loop_ub; j++) {
            q[j] = rows[j];
          }

          r.set_size(loop_ub);
          for (int j{0}; j < loop_ub; j++) {
            r[j] = static_cast<int>(q[j]) - 1;
          }

          c_loop_ub = b_Jrobot.size(1);
          C.set_size(1, b_Jrobot.size(1));
          for (int j{0}; j < c_loop_ub; j++) {
            boffset = j * 6;
            posErr_idx_0 = 0.0;
            for (int k{0}; k < 6; k++) {
              posErr_idx_0 += JTwist[k] * b_Jrobot[boffset + k];
            }

            C[j] = posErr_idx_0;
          }

          if (d < 1.0) {
            c_loop_ub = 0;
          } else {
            c_loop_ub = static_cast<int>(d);
          }

          for (int j{0}; j < c_loop_ub; j++) {
            for (boffset = 0; boffset < loop_ub; boffset++) {
              J[r[boffset] + J.size(0) * j] = C[boffset + loop_ub * j];
            }
          }

          slacks.set_size(b_loop_ub);
          for (int j{0}; j < b_loop_ub; j++) {
            slacks[j] = x[static_cast<int>(cols[j]) - 1];
          }

          r1.set_size(1, loop_ub);
          for (int j{0}; j < loop_ub; j++) {
            r1[j] = static_cast<int>(rows[j]) + ndx_tmp_idx_0 * (static_cast<int>
              (cols[j]) - 1);
          }

          r2.set_size(EqualityFlags[1].f1.size(0), EqualityFlags[1].f1.size(1));
          b_loop_ub = EqualityFlags[1].f1.size(0) * EqualityFlags[1].f1.size(1);
          for (int j{0}; j < b_loop_ub; j++) {
            r2[j] = static_cast<signed char>(-!EqualityFlags[1].f1[j]);
          }

          for (int j{0}; j < loop_ub; j++) {
            J[r1[j] - 1] = r2[j];
          }

          r3.set_size(Constraints.f2->BoundsInternal.size(0), 2);
          b_loop_ub = Constraints.f2->BoundsInternal.size(0) << 1;
          for (int j{0}; j < b_loop_ub; j++) {
            r3[j] = Constraints.f2->BoundsInternal[j];
          }

          boffset = EqualityFlags[1].f1.size(0) * EqualityFlags[1].f1.size(1);
          c_loop_ub = 0;
          for (b_loop_ub = 0; b_loop_ub < boffset; b_loop_ub++) {
            if (EqualityFlags[1].f1[b_loop_ub]) {
              c_loop_ub++;
            }
          }

          r6.set_size(c_loop_ub);
          c_loop_ub = 0;
          for (b_loop_ub = 0; b_loop_ub < boffset; b_loop_ub++) {
            if (EqualityFlags[1].f1[b_loop_ub]) {
              r6[c_loop_ub] = b_loop_ub;
              c_loop_ub++;
            }
          }

          boffset = EqualityFlags[1].f1.size(0) * EqualityFlags[1].f1.size(1);
          c_loop_ub = 0;
          for (b_loop_ub = 0; b_loop_ub < boffset; b_loop_ub++) {
            if (EqualityFlags[1].f1[b_loop_ub]) {
              c_loop_ub++;
            }
          }

          r7.set_size(c_loop_ub);
          c_loop_ub = 0;
          for (b_loop_ub = 0; b_loop_ub < boffset; b_loop_ub++) {
            if (EqualityFlags[1].f1[b_loop_ub]) {
              r7[c_loop_ub] = b_loop_ub;
              c_loop_ub++;
            }
          }

          b_loop_ub = r7.size(0);
          for (int j{0}; j < b_loop_ub; j++) {
            slacks[r6[j]] = r3[r7[j]];
          }

          r.set_size(loop_ub);
          for (int j{0}; j < loop_ub; j++) {
            r[j] = static_cast<int>(q[j]) - 1;
          }

          for (int j{0}; j < loop_ub; j++) {
            f[r[j]] = gCell_idx_1 - slacks[j];
          }
        }

        //
        // Arguments    : const char baseName_data[]
        //                const int baseName_size[2]
        // Return Type  : void
        //
        void b_RigidBodyTree::set_BaseName(const char baseName_data[], const int
          baseName_size[2])
        {
          CharacterVector obj;
          RigidBody *b_obj;
          int obj_size[2];
          int bid;
          int loop_ub;
          char obj_data[200];
          bid = -1;
          obj = Base.NameInternal;
          if (obj.Length < 1.0) {
            loop_ub = 0;
          } else {
            loop_ub = static_cast<int>(obj.Length);
          }

          obj_size[0] = 1;
          obj_size[1] = loop_ub;
          if (loop_ub - 1 >= 0) {
            ::std::copy(&obj.Vector[0], &obj.Vector[loop_ub], &obj_data[0]);
          }

          if (::coder::internal::b_strcmp(obj_data, obj_size, baseName_data,
               baseName_size)) {
            bid = 0;
          } else {
            double d;
            int i;
            bool exitg1;
            d = NumBodies;
            i = 0;
            exitg1 = false;
            while ((!exitg1) && (i <= static_cast<int>(d) - 1)) {
              b_obj = Bodies[i];
              obj = b_obj->NameInternal;
              if (obj.Length < 1.0) {
                loop_ub = 0;
              } else {
                loop_ub = static_cast<int>(obj.Length);
              }

              obj_size[0] = 1;
              obj_size[1] = loop_ub;
              if (loop_ub - 1 >= 0) {
                ::std::copy(&obj.Vector[0], &obj.Vector[loop_ub], &obj_data[0]);
              }

              if (::coder::internal::b_strcmp(obj_data, obj_size, baseName_data,
                   baseName_size)) {
                bid = i + 1;
                exitg1 = true;
              } else {
                i++;
              }
            }
          }

          if (bid < 0) {
            obj = Base.NameInternal;
            obj.Length = baseName_size[1];
            loop_ub = baseName_size[1];
            if (loop_ub - 1 >= 0) {
              ::std::copy(&baseName_data[0], &baseName_data[loop_ub],
                          &obj.Vector[0]);
            }

            Base.NameInternal = obj;
          }
        }

        //
        // Arguments    : bool b_value
        // Return Type  : void
        //
        void GIKProblem::set_EnforceJointLimits(bool b_value)
        {
          array<double, 2U> A;
          array<double, 2U> r;
          array<double, 2U> r1;
          array<double, 1U> b;
          EnforceJointLimitsInternal = b_value;
          if (EnforceJointLimitsInternal) {
            double d;
            int b_loop_ub;
            int c_loop_ub;
            int loop_ub;
            loop_ub = DesignVariableBoundsInternal.size(0);
            r.set_size(loop_ub, 2);
            b_loop_ub = DesignVariableBoundsInternal.size(0) << 1;
            for (int i{0}; i < b_loop_ub; i++) {
              r[i] = DesignVariableBoundsInternal[i];
            }

            d = NumPositions;
            Tree->get_JointPositionLimits(r1);
            if (d < 1.0) {
              b_loop_ub = 0;
            } else {
              b_loop_ub = static_cast<int>(d);
            }

            for (int i{0}; i < 2; i++) {
              for (c_loop_ub = 0; c_loop_ub < b_loop_ub; c_loop_ub++) {
                r[c_loop_ub + r.size(0) * i] = r1[c_loop_ub + r1.size(0) * i];
              }
            }

            DesignVariableBoundsInternal.set_size(loop_ub, 2);
            c_loop_ub = r.size(0) << 1;
            for (int i{0}; i < c_loop_ub; i++) {
              DesignVariableBoundsInternal[i] = r[i];
            }

            b_loop_ub = 2 * r.size(0);
            A.set_size(b_loop_ub, loop_ub);
            c_loop_ub = b_loop_ub * r.size(0);
            for (int i{0}; i < c_loop_ub; i++) {
              A[i] = 0.0;
            }

            b.set_size(b_loop_ub);
            for (int i{0}; i < b_loop_ub; i++) {
              b[i] = 0.0;
            }

            for (int i{0}; i < loop_ub; i++) {
              c_loop_ub = static_cast<int>(static_cast<unsigned int>(i + 1) << 1);
              A[(c_loop_ub + A.size(0) * i) - 2] = -1.0;
              A[(c_loop_ub + A.size(0) * i) - 1] = 1.0;
              b[c_loop_ub - 2] = -r[i];
              b[c_loop_ub - 1] = r[i + r.size(0)];
            }

            ConstraintMatrixInternal.set_size(loop_ub, b_loop_ub);
            for (int i{0}; i < b_loop_ub; i++) {
              for (c_loop_ub = 0; c_loop_ub < loop_ub; c_loop_ub++) {
                ConstraintMatrixInternal[c_loop_ub +
                  ConstraintMatrixInternal.size(0) * i] = A[i + A.size(0) *
                  c_loop_ub];
              }
            }

            ConstraintBoundInternal.set_size(b_loop_ub);
            for (int i{0}; i < b_loop_ub; i++) {
              ConstraintBoundInternal[i] = b[i];
            }
          } else {
            int b_loop_ub;
            int c_loop_ub;
            int loop_ub;
            loop_ub = DesignVariableBoundsInternal.size(0);
            r.set_size(loop_ub, 2);
            b_loop_ub = DesignVariableBoundsInternal.size(0) << 1;
            for (int i{0}; i < b_loop_ub; i++) {
              r[i] = DesignVariableBoundsInternal[i];
            }

            b_loop_ub = static_cast<int>(NumPositions);
            c_loop_ub = static_cast<int>(NumPositions);
            for (int i{0}; i < b_loop_ub; i++) {
              r[i] = rtMinusInf;
            }

            for (int i{0}; i < c_loop_ub; i++) {
              r[i + r.size(0)] = rtInf;
            }

            DesignVariableBoundsInternal.set_size(loop_ub, 2);
            c_loop_ub = r.size(0) << 1;
            for (int i{0}; i < c_loop_ub; i++) {
              DesignVariableBoundsInternal[i] = r[i];
            }

            b_loop_ub = 2 * r.size(0);
            A.set_size(b_loop_ub, loop_ub);
            c_loop_ub = b_loop_ub * r.size(0);
            for (int i{0}; i < c_loop_ub; i++) {
              A[i] = 0.0;
            }

            b.set_size(b_loop_ub);
            for (int i{0}; i < b_loop_ub; i++) {
              b[i] = 0.0;
            }

            for (int i{0}; i < loop_ub; i++) {
              c_loop_ub = static_cast<int>(static_cast<unsigned int>(i + 1) << 1);
              A[(c_loop_ub + A.size(0) * i) - 2] = -1.0;
              A[(c_loop_ub + A.size(0) * i) - 1] = 1.0;
              b[c_loop_ub - 2] = -r[i];
              b[c_loop_ub - 1] = r[i + r.size(0)];
            }

            ConstraintMatrixInternal.set_size(loop_ub, b_loop_ub);
            for (int i{0}; i < b_loop_ub; i++) {
              for (c_loop_ub = 0; c_loop_ub < loop_ub; c_loop_ub++) {
                ConstraintMatrixInternal[c_loop_ub +
                  ConstraintMatrixInternal.size(0) * i] = A[i + A.size(0) *
                  c_loop_ub];
              }
            }

            ConstraintBoundInternal.set_size(b_loop_ub);
            for (int i{0}; i < b_loop_ub; i++) {
              ConstraintBoundInternal[i] = b[i];
            }
          }
        }

        //
        // Arguments    : const constraintPositionTarget &varargin_1
        //                const constraintOrientationTarget &varargin_2
        // Return Type  : void
        //
        void GIKProblem::update(const constraintPositionTarget &varargin_1,
          const constraintOrientationTarget &varargin_2)
        {
          CharacterVector c_obj;
          OrientationTarget *d_obj;
          PositionTarget *obj;
          RigidBody *e_obj;
          b_RigidBodyTree *b_obj;
          array<double, 2U> r1;
          array<double, 1U> f_obj;
          array<double, 1U> r;
          double H[16];
          double dv[9];
          double b_bid;
          int a_size[2];
          int b_i;
          int bid;
          int exitg1;
          int i;
          int kstr;
          char a_data[200];
          bool b_bool;
          bool exitg2;
          obj = Constraints.f1;
          obj->Weights.set_size(1, 1);
          obj->Weights[0] = varargin_1.Weights;
          obj->get_EndEffector(a_data, a_size);
          b_bool = false;
          if (a_size[1] == 9) {
            kstr = 0;
            do {
              exitg1 = 0;
              if (kstr < 9) {
                if (a_data[kstr] != varargin_1.EndEffector[kstr]) {
                  exitg1 = 1;
                } else {
                  kstr++;
                }
              } else {
                b_bool = true;
                exitg1 = 1;
              }
            } while (exitg1 == 0);
          }

          if (!b_bool) {
            b_obj = obj->Tree;
            bid = -1;
            c_obj = b_obj->Base.NameInternal;
            if (c_obj.Length < 1.0) {
              i = 0;
            } else {
              i = static_cast<int>(c_obj.Length);
            }

            b_bool = false;
            if (i == 9) {
              kstr = 0;
              do {
                exitg1 = 0;
                if (kstr < 9) {
                  if (c_obj.Vector[kstr] != varargin_1.EndEffector[kstr]) {
                    exitg1 = 1;
                  } else {
                    kstr++;
                  }
                } else {
                  b_bool = true;
                  exitg1 = 1;
                }
              } while (exitg1 == 0);
            }

            if (b_bool) {
              bid = 0;
            } else {
              b_bid = b_obj->NumBodies;
              b_i = 0;
              exitg2 = false;
              while ((!exitg2) && (b_i <= static_cast<int>(b_bid) - 1)) {
                e_obj = b_obj->Bodies[b_i];
                c_obj = e_obj->NameInternal;
                if (c_obj.Length < 1.0) {
                  i = 0;
                } else {
                  i = static_cast<int>(c_obj.Length);
                }

                b_bool = false;
                if (i == 9) {
                  kstr = 0;
                  do {
                    exitg1 = 0;
                    if (kstr < 9) {
                      if (c_obj.Vector[kstr] != varargin_1.EndEffector[kstr]) {
                        exitg1 = 1;
                      } else {
                        kstr++;
                      }
                    } else {
                      b_bool = true;
                      exitg1 = 1;
                    }
                  } while (exitg1 == 0);
                }

                if (b_bool) {
                  bid = b_i + 1;
                  exitg2 = true;
                } else {
                  b_i++;
                }
              }
            }

            obj->EndEffectorIndex = bid;
          }

          obj->get_ReferenceBody(a_data, a_size);
          if (!::coder::internal::b_strcmp(a_data, a_size,
               varargin_1.ReferenceBody)) {
            if ((varargin_1.ReferenceBody.size(0) == 0) ||
                (varargin_1.ReferenceBody.size(1) == 0)) {
              obj->ReferenceBodyIndex = 0.0;
            } else {
              b_obj = obj->Tree;
              bid = -1;
              c_obj = b_obj->Base.NameInternal;
              if (c_obj.Length < 1.0) {
                kstr = 0;
              } else {
                kstr = static_cast<int>(c_obj.Length);
              }

              a_size[0] = 1;
              a_size[1] = kstr;
              if (kstr - 1 >= 0) {
                ::std::copy(&c_obj.Vector[0], &c_obj.Vector[kstr], &a_data[0]);
              }

              if (::coder::internal::b_strcmp(a_data, a_size,
                   varargin_1.ReferenceBody)) {
                bid = 0;
              } else {
                b_bid = b_obj->NumBodies;
                b_i = 0;
                exitg2 = false;
                while ((!exitg2) && (b_i <= static_cast<int>(b_bid) - 1)) {
                  e_obj = b_obj->Bodies[b_i];
                  c_obj = e_obj->NameInternal;
                  if (c_obj.Length < 1.0) {
                    kstr = 0;
                  } else {
                    kstr = static_cast<int>(c_obj.Length);
                  }

                  a_size[0] = 1;
                  a_size[1] = kstr;
                  if (kstr - 1 >= 0) {
                    ::std::copy(&c_obj.Vector[0], &c_obj.Vector[kstr], &a_data[0]);
                  }

                  if (::coder::internal::b_strcmp(a_data, a_size,
                       varargin_1.ReferenceBody)) {
                    bid = b_i + 1;
                    exitg2 = true;
                  } else {
                    b_i++;
                  }
                }
              }

              obj->ReferenceBodyIndex = bid;
            }
          }

          obj->TargetPosition[0] = varargin_1.TargetPosition[0];
          obj->TargetPosition[1] = varargin_1.TargetPosition[1];
          obj->TargetPosition[2] = varargin_1.TargetPosition[2];
          obj->BoundsInternal[obj->BoundsInternal.size(0)] =
            varargin_1.PositionTolerance;
          d_obj = Constraints.f2;
          d_obj->Weights.set_size(1, 1);
          d_obj->Weights[0] = varargin_2.Weights;
          d_obj->get_EndEffector(a_data, a_size);
          b_bool = false;
          if (a_size[1] == 10) {
            kstr = 0;
            do {
              exitg1 = 0;
              if (kstr < 10) {
                if (a_data[kstr] != varargin_2.EndEffector[kstr]) {
                  exitg1 = 1;
                } else {
                  kstr++;
                }
              } else {
                b_bool = true;
                exitg1 = 1;
              }
            } while (exitg1 == 0);
          }

          if (!b_bool) {
            b_obj = d_obj->Tree;
            b_bid = b_obj->c_findBodyIndexByName(varargin_2.EndEffector);
            d_obj->EndEffectorIndex = b_bid;
          }

          d_obj->get_ReferenceBody(a_data, a_size);
          if (static_cast<unsigned char>(a_size[1]) != 0) {
            d_obj->ReferenceBodyIndex = 0.0;
          }

          std::memset(&H[0], 0, 16U * sizeof(double));
          ::coder::robotics::internal::quat2rotm(varargin_2.TargetOrientation,
            dv);
          for (i = 0; i < 3; i++) {
            kstr = i << 2;
            H[kstr] = dv[3 * i];
            H[kstr + 1] = dv[3 * i + 1];
            H[kstr + 2] = dv[3 * i + 2];
          }

          H[15] = 1.0;
          for (i = 0; i < 16; i++) {
            d_obj->TargetTransform[i] = H[i];
          }

          d_obj->BoundsInternal[d_obj->BoundsInternal.size(0)] =
            varargin_2.OrientationTolerance;
          updateDesignVariableBounds();
          kstr = static_cast<int>(NumVariables);
          LastX.set_size(kstr);
          for (i = 0; i < kstr; i++) {
            LastX[i] = 0.0;
          }

          f_obj.set_size(LastX.size(0));
          kstr = LastX.size(0) - 1;
          for (i = 0; i <= kstr; i++) {
            f_obj[i] = LastX[i];
          }

          residualsInternal(f_obj, r, r1);
          kstr = r.size(0);
          LastF.set_size(r.size(0));
          for (i = 0; i < kstr; i++) {
            LastF[i] = r[i];
          }

          LastJ.set_size(r1.size(0), r1.size(1));
          kstr = r1.size(0) * r1.size(1);
          for (i = 0; i < kstr; i++) {
            LastJ[i] = r1[i];
          }
        }

        //
        // Arguments    : void
        // Return Type  : void
        //
        void GIKProblem::updateDesignVariableBounds()
        {
          array<double, 2U> A;
          array<double, 2U> bounds;
          array<double, 1U> y;
          array<int, 1U> r;
          array<int, 1U> r1;
          int b_loop_ub;
          int end;
          int i;
          int loop_ub;
          int nx;
          i = Constraints.f1->BoundsInternal.size(0);
          bounds.set_size(i, 2);
          loop_ub = Constraints.f1->BoundsInternal.size(0) << 1;
          for (nx = 0; nx < loop_ub; nx++) {
            bounds[nx] = Constraints.f1->BoundsInternal[nx];
          }

          ConstraintBoundInternal.set_size(i);
          if (bounds.size(0) != 0) {
            for (nx = 0; nx < i; nx++) {
              ConstraintBoundInternal[nx] = bounds[nx + i] - bounds[nx];
            }
          }

          nx = ConstraintBoundInternal.size(0);
          end = ConstraintBoundInternal.size(0);
          y.set_size(end);
          for (loop_ub = 0; loop_ub < nx; loop_ub++) {
            y[loop_ub] = std::abs(ConstraintBoundInternal[loop_ub]);
          }

          nx = 0;
          for (int b_i{0}; b_i < end; b_i++) {
            if (y[b_i] < 2.2204460492503131E-16) {
              nx++;
            }
          }

          r.set_size(nx);
          nx = 0;
          for (int b_i{0}; b_i < end; b_i++) {
            if (y[b_i] < 2.2204460492503131E-16) {
              r[nx] = b_i;
              nx++;
            }
          }

          loop_ub = r.size(0);
          for (i = 0; i < loop_ub; i++) {
            bounds[r[i]] = rtMinusInf;
            bounds[r[i] + bounds.size(0)] = rtInf;
          }

          loop_ub = SlackIndices[0].f1.size(1);
          r.set_size(loop_ub);
          b_loop_ub = SlackIndices[0].f1.size(1);
          for (i = 0; i < b_loop_ub; i++) {
            r[i] = static_cast<int>(SlackIndices[0].f1[i]) - 1;
          }

          for (i = 0; i < 2; i++) {
            for (nx = 0; nx < loop_ub; nx++) {
              DesignVariableBoundsInternal[r[nx] +
                DesignVariableBoundsInternal.size(0) * i] = bounds[nx +
                bounds.size(0) * i];
            }
          }

          nx = 2 * DesignVariableBoundsInternal.size(0);
          ConstraintBoundInternal.set_size(nx);
          for (i = 0; i < nx; i++) {
            ConstraintBoundInternal[i] = 0.0;
          }

          i = DesignVariableBoundsInternal.size(0);
          for (int b_i{0}; b_i < i; b_i++) {
            nx = static_cast<int>(static_cast<unsigned int>(b_i + 1) << 1);
            ConstraintBoundInternal[nx - 2] = -DesignVariableBoundsInternal[b_i];
            ConstraintBoundInternal[nx - 1] = DesignVariableBoundsInternal[b_i +
              DesignVariableBoundsInternal.size(0)];
          }

          EqualityFlags[0].f1.set_size(end, 1);
          for (i = 0; i < end; i++) {
            EqualityFlags[0].f1[i] = (y[i] < 2.2204460492503131E-16);
          }

          i = Constraints.f2->BoundsInternal.size(0);
          bounds.set_size(i, 2);
          loop_ub = Constraints.f2->BoundsInternal.size(0) << 1;
          for (nx = 0; nx < loop_ub; nx++) {
            bounds[nx] = Constraints.f2->BoundsInternal[nx];
          }

          ConstraintBoundInternal.set_size(i);
          if (bounds.size(0) != 0) {
            for (nx = 0; nx < i; nx++) {
              ConstraintBoundInternal[nx] = bounds[nx + i] - bounds[nx];
            }
          }

          nx = ConstraintBoundInternal.size(0);
          end = ConstraintBoundInternal.size(0);
          y.set_size(end);
          for (loop_ub = 0; loop_ub < nx; loop_ub++) {
            y[loop_ub] = std::abs(ConstraintBoundInternal[loop_ub]);
          }

          nx = 0;
          for (int b_i{0}; b_i < end; b_i++) {
            if (y[b_i] < 2.2204460492503131E-16) {
              nx++;
            }
          }

          r1.set_size(nx);
          nx = 0;
          for (int b_i{0}; b_i < end; b_i++) {
            if (y[b_i] < 2.2204460492503131E-16) {
              r1[nx] = b_i;
              nx++;
            }
          }

          loop_ub = r1.size(0);
          for (i = 0; i < loop_ub; i++) {
            bounds[r1[i]] = rtMinusInf;
            bounds[r1[i] + bounds.size(0)] = rtInf;
          }

          loop_ub = SlackIndices[1].f1.size(1);
          r.set_size(loop_ub);
          b_loop_ub = SlackIndices[1].f1.size(1);
          for (i = 0; i < b_loop_ub; i++) {
            r[i] = static_cast<int>(SlackIndices[1].f1[i]) - 1;
          }

          for (i = 0; i < 2; i++) {
            for (nx = 0; nx < loop_ub; nx++) {
              DesignVariableBoundsInternal[r[nx] +
                DesignVariableBoundsInternal.size(0) * i] = bounds[nx +
                bounds.size(0) * i];
            }
          }

          loop_ub = 2 * DesignVariableBoundsInternal.size(0);
          b_loop_ub = DesignVariableBoundsInternal.size(0);
          A.set_size(loop_ub, b_loop_ub);
          nx = 2 * DesignVariableBoundsInternal.size(0) *
            DesignVariableBoundsInternal.size(0);
          for (i = 0; i < nx; i++) {
            A[i] = 0.0;
          }

          nx = 2 * DesignVariableBoundsInternal.size(0);
          ConstraintBoundInternal.set_size(nx);
          for (i = 0; i < nx; i++) {
            ConstraintBoundInternal[i] = 0.0;
          }

          i = DesignVariableBoundsInternal.size(0);
          for (int b_i{0}; b_i < i; b_i++) {
            nx = static_cast<int>(static_cast<unsigned int>(b_i + 1) << 1);
            A[(nx + A.size(0) * b_i) - 2] = -1.0;
            A[(nx + A.size(0) * b_i) - 1] = 1.0;
            ConstraintBoundInternal[nx - 2] = -DesignVariableBoundsInternal[b_i];
            ConstraintBoundInternal[nx - 1] = DesignVariableBoundsInternal[b_i +
              DesignVariableBoundsInternal.size(0)];
          }

          ConstraintMatrixInternal.set_size(b_loop_ub, loop_ub);
          for (i = 0; i < loop_ub; i++) {
            for (nx = 0; nx < b_loop_ub; nx++) {
              ConstraintMatrixInternal[nx + ConstraintMatrixInternal.size(0) * i]
                = A[i + A.size(0) * nx];
            }
          }

          EqualityFlags[1].f1.set_size(end, 1);
          for (i = 0; i < end; i++) {
            EqualityFlags[1].f1[i] = (y[i] < 2.2204460492503131E-16);
          }
        }

        //
        // Arguments    : void
        // Return Type  : void
        //
      }
    }
  }

  void rigidBodyJoint::setFixedTransform()
  {
    for (int i{0}; i < 16; i++) {
      JointToParentTransform[i] = iv[i];
      ChildToJointTransform[i] = 0.0;
    }

    ChildToJointTransform[0] = 1.0;
    ChildToJointTransform[5] = 1.0;
    ChildToJointTransform[10] = 1.0;
    ChildToJointTransform[15] = 1.0;
  }

  //
  // Arguments    : const double input[16]
  // Return Type  : void
  //
  void rigidBodyJoint::setFixedTransform(const double input[16])
  {
    for (int i{0}; i < 16; i++) {
      JointToParentTransform[i] = input[i];
      ChildToJointTransform[i] = 0.0;
    }

    ChildToJointTransform[0] = 1.0;
    ChildToJointTransform[5] = 1.0;
    ChildToJointTransform[10] = 1.0;
    ChildToJointTransform[15] = 1.0;
  }

  //
  // Arguments    : void
  // Return Type  : void
  //
  void rigidBodyTree::set_BaseName()
  {
    robotics::manip::internal::b_RigidBodyTree *obj;
    double bid;
    obj = TreeInternal;
    bid = obj->findBodyIndexByName();
    if ((!(bid == 0.0)) && (bid < 0.0)) {
      robotics::manip::internal::CharacterVector b_obj;
      b_obj = obj->Base.NameInternal;
      b_obj.Length = 4.0;
      b_obj.Vector[0] = 'b';
      b_obj.Vector[1] = 'a';
      b_obj.Vector[2] = 's';
      b_obj.Vector[3] = 'e';
      obj->Base.NameInternal = b_obj;
    }
  }

  //
  // Arguments    : void
  // Return Type  : void
  //
  void rigidBody::set_CenterOfMass()
  {
    robotics::manip::internal::RigidBody *obj;
    double inertia[9];
    double sc[9];
    double com_idx_0;
    double com_idx_1;
    double com_idx_2;
    double mass;
    int i1;
    obj = BodyInternal;
    obj->CenterOfMassInternal[0] = 0.0;
    obj->CenterOfMassInternal[1] = 0.0;
    obj->CenterOfMassInternal[2] = 0.0;
    mass = obj->MassInternal;
    com_idx_0 = obj->CenterOfMassInternal[0];
    com_idx_1 = obj->CenterOfMassInternal[1];
    com_idx_2 = obj->CenterOfMassInternal[2];
    for (int i{0}; i < 9; i++) {
      inertia[i] = obj->InertiaInternal[i];
    }

    sc[0] = 0.0;
    sc[3] = -com_idx_2;
    sc[6] = com_idx_1;
    sc[1] = com_idx_2;
    sc[4] = 0.0;
    sc[7] = -com_idx_0;
    sc[2] = -com_idx_1;
    sc[5] = com_idx_0;
    sc[8] = 0.0;
    for (int i{0}; i < 3; i++) {
      obj->SpatialInertia[6 * i] = inertia[3 * i];
      obj->SpatialInertia[6 * i + 1] = inertia[3 * i + 1];
      obj->SpatialInertia[6 * i + 2] = inertia[3 * i + 2];
    }

    for (int i{0}; i < 3; i++) {
      i1 = 6 * (i + 3);
      obj->SpatialInertia[i1] = mass * sc[3 * i];
      obj->SpatialInertia[i1 + 1] = mass * sc[3 * i + 1];
      obj->SpatialInertia[i1 + 2] = mass * sc[3 * i + 2];
    }

    for (int i{0}; i < 3; i++) {
      obj->SpatialInertia[6 * i + 3] = mass * sc[i];
      obj->SpatialInertia[6 * i + 4] = mass * sc[i + 3];
      obj->SpatialInertia[6 * i + 5] = mass * sc[i + 6];
    }

    for (int i{0}; i < 3; i++) {
      i1 = 6 * (i + 3);
      obj->SpatialInertia[i1 + 3] = mass * static_cast<double>(iv1[3 * i]);
      obj->SpatialInertia[i1 + 4] = mass * static_cast<double>(iv1[3 * i + 1]);
      obj->SpatialInertia[i1 + 5] = mass * static_cast<double>(iv1[3 * i + 2]);
    }
  }

  //
  // Arguments    : void
  // Return Type  : void
  //
  void rigidBodyJoint::set_HomePosition()
  {
    double d;
    int loop_ub;
    d = PositionNumber;
    if (d < 1.0) {
      loop_ub = 0;
    } else {
      loop_ub = static_cast<int>(d);
    }

    if (loop_ub - 1 >= 0) {
      std::memset(&HomePositionInternal[0], 0, static_cast<unsigned int>(loop_ub)
                  * sizeof(double));
    }
  }

  //
  // Arguments    : void
  // Return Type  : void
  //
  void rigidBody::set_Inertia()
  {
    robotics::manip::internal::RigidBody *obj;
    double inertia[9];
    double sc[9];
    double com_idx_0;
    double com_idx_1;
    double com_idx_2;
    double mass;
    int i1;
    obj = BodyInternal;
    for (int i{0}; i < 9; i++) {
      obj->InertiaInternal[i] = iv1[i];
    }

    mass = obj->MassInternal;
    com_idx_0 = obj->CenterOfMassInternal[0];
    com_idx_1 = obj->CenterOfMassInternal[1];
    com_idx_2 = obj->CenterOfMassInternal[2];
    for (int i{0}; i < 9; i++) {
      inertia[i] = obj->InertiaInternal[i];
    }

    sc[0] = 0.0;
    sc[3] = -com_idx_2;
    sc[6] = com_idx_1;
    sc[1] = com_idx_2;
    sc[4] = 0.0;
    sc[7] = -com_idx_0;
    sc[2] = -com_idx_1;
    sc[5] = com_idx_0;
    sc[8] = 0.0;
    for (int i{0}; i < 3; i++) {
      obj->SpatialInertia[6 * i] = inertia[3 * i];
      obj->SpatialInertia[6 * i + 1] = inertia[3 * i + 1];
      obj->SpatialInertia[6 * i + 2] = inertia[3 * i + 2];
    }

    for (int i{0}; i < 3; i++) {
      i1 = 6 * (i + 3);
      obj->SpatialInertia[i1] = mass * sc[3 * i];
      obj->SpatialInertia[i1 + 1] = mass * sc[3 * i + 1];
      obj->SpatialInertia[i1 + 2] = mass * sc[3 * i + 2];
    }

    for (int i{0}; i < 3; i++) {
      obj->SpatialInertia[6 * i + 3] = mass * sc[i];
      obj->SpatialInertia[6 * i + 4] = mass * sc[i + 3];
      obj->SpatialInertia[6 * i + 5] = mass * sc[i + 6];
    }

    for (int i{0}; i < 3; i++) {
      i1 = 6 * (i + 3);
      obj->SpatialInertia[i1 + 3] = mass * static_cast<double>(iv1[3 * i]);
      obj->SpatialInertia[i1 + 4] = mass * static_cast<double>(iv1[3 * i + 1]);
      obj->SpatialInertia[i1 + 5] = mass * static_cast<double>(iv1[3 * i + 2]);
    }
  }

  //
  // Arguments    : void
  // Return Type  : void
  //
  void rigidBodyJoint::set_JointAxis()
  {
    static const double dv[6]{ 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 };

    static const double dv1[6]{ 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 };

    static const char b_cv[8]{ 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };

    int i;
    bool result;
    JointAxisInternal[0] = 0.0;
    JointAxisInternal[1] = 0.0;
    JointAxisInternal[2] = 1.0;
    if (TypeInternal.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(TypeInternal.Length);
    }

    result = false;
    if (i == 8) {
      i = 0;
      int exitg1;
      do {
        exitg1 = 0;
        if (i < 8) {
          if (b_cv[i] != TypeInternal.Vector[i]) {
            exitg1 = 1;
          } else {
            i++;
          }
        } else {
          result = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (result) {
      i = 0;
    } else {
      i = -1;
    }

    if (i == 0) {
      b_set_MotionSubspace(dv1);
    } else {
      b_set_MotionSubspace(dv);
    }
  }

  //
  // Arguments    : void
  // Return Type  : void
  //
  void rigidBody::set_Mass()
  {
    robotics::manip::internal::RigidBody *obj;
    double inertia[9];
    double sc[9];
    double com_idx_0;
    double com_idx_1;
    double com_idx_2;
    double mass;
    int i1;
    obj = BodyInternal;
    obj->MassInternal = 1.0;
    mass = obj->MassInternal;
    com_idx_0 = obj->CenterOfMassInternal[0];
    com_idx_1 = obj->CenterOfMassInternal[1];
    com_idx_2 = obj->CenterOfMassInternal[2];
    for (int i{0}; i < 9; i++) {
      inertia[i] = obj->InertiaInternal[i];
    }

    sc[0] = 0.0;
    sc[3] = -com_idx_2;
    sc[6] = com_idx_1;
    sc[1] = com_idx_2;
    sc[4] = 0.0;
    sc[7] = -com_idx_0;
    sc[2] = -com_idx_1;
    sc[5] = com_idx_0;
    sc[8] = 0.0;
    for (int i{0}; i < 3; i++) {
      obj->SpatialInertia[6 * i] = inertia[3 * i];
      obj->SpatialInertia[6 * i + 1] = inertia[3 * i + 1];
      obj->SpatialInertia[6 * i + 2] = inertia[3 * i + 2];
    }

    for (int i{0}; i < 3; i++) {
      i1 = 6 * (i + 3);
      obj->SpatialInertia[i1] = mass * sc[3 * i];
      obj->SpatialInertia[i1 + 1] = mass * sc[3 * i + 1];
      obj->SpatialInertia[i1 + 2] = mass * sc[3 * i + 2];
    }

    for (int i{0}; i < 3; i++) {
      obj->SpatialInertia[6 * i + 3] = mass * sc[i];
      obj->SpatialInertia[6 * i + 4] = mass * sc[i + 3];
      obj->SpatialInertia[6 * i + 5] = mass * sc[i + 6];
    }

    for (int i{0}; i < 3; i++) {
      i1 = 6 * (i + 3);
      obj->SpatialInertia[i1 + 3] = mass * static_cast<double>(iv1[3 * i]);
      obj->SpatialInertia[i1 + 4] = mass * static_cast<double>(iv1[3 * i + 1]);
      obj->SpatialInertia[i1 + 5] = mass * static_cast<double>(iv1[3 * i + 2]);
    }
  }

  //
  // Arguments    : const double msubspace_data[]
  // Return Type  : void
  //
  void rigidBodyJoint::set_MotionSubspace(const double msubspace_data[])
  {
    static const char b_cv[5]{ 'f', 'i', 'x', 'e', 'd' };

    int i;
    int kstr;
    bool b_bool;
    if (TypeInternal.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(TypeInternal.Length);
    }

    b_bool = false;
    if (i == 5) {
      kstr = 0;
      int exitg1;
      do {
        exitg1 = 0;
        if (kstr < 5) {
          if (TypeInternal.Vector[kstr] != b_cv[kstr]) {
            exitg1 = 1;
          } else {
            kstr++;
          }
        } else {
          b_bool = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (!b_bool) {
      double d;
      d = VelocityNumber;
      if (d < 1.0) {
        kstr = 0;
      } else {
        kstr = static_cast<int>(d);
      }

      for (i = 0; i < kstr; i++) {
        for (int i1{0}; i1 < 6; i1++) {
          int i2;
          i2 = i1 + 6 * i;
          MotionSubspaceInternal[i2] = msubspace_data[i2];
        }
      }
    } else {
      for (i = 0; i < 6; i++) {
        MotionSubspaceInternal[i] = 0.0;
      }
    }
  }

  //
  // Arguments    : void
  // Return Type  : void
  //
  void rigidBodyJoint::set_PositionLimits()
  {
    array<bool, 1U> x;
    double dv[2];
    double d;
    int ix;
    int loop_ub;
    bool resetHome;
    resetHome = false;
    switch (static_cast<int>(PositionNumber)) {
     case 0:
     case 7:
      break;

     default:
      {
        bool exitg1;
        bool y;
        d = PositionNumber;
        if (d < 1.0) {
          loop_ub = 0;
        } else {
          loop_ub = static_cast<int>(d);
        }

        x.set_size(loop_ub);
        for (ix = 0; ix < loop_ub; ix++) {
          x[ix] = (HomePositionInternal[ix] > 2.96705972839036);
        }

        y = false;
        ix = 1;
        exitg1 = false;
        while ((!exitg1) && (ix <= x.size(0))) {
          if (x[ix - 1]) {
            y = true;
            exitg1 = true;
          } else {
            ix++;
          }
        }

        if (y) {
          resetHome = true;
        } else {
          x.set_size(loop_ub);
          for (ix = 0; ix < loop_ub; ix++) {
            x[ix] = (HomePositionInternal[ix] < -2.96705972839036);
          }

          y = false;
          ix = 1;
          exitg1 = false;
          while ((!exitg1) && (ix <= x.size(0))) {
            if (x[ix - 1]) {
              y = true;
              exitg1 = true;
            } else {
              ix++;
            }
          }

          if (y) {
            resetHome = true;
          }
        }
      }
      break;
    }

    d = PositionNumber;
    dv[0] = -2.96705972839036;
    dv[1] = 2.96705972839036;
    if (d < 1.0) {
      loop_ub = 0;
    } else {
      loop_ub = static_cast<int>(d);
    }

    for (ix = 0; ix < 2; ix++) {
      for (int i{0}; i < loop_ub; i++) {
        PositionLimitsInternal[i + 7 * ix] = dv[i + loop_ub * ix];
      }
    }

    if (resetHome) {
      resetHomePosition();
    }
  }

  //
  // Arguments    : double solverparams_MaxIterations
  //                double solverparams_MaxTime
  //                double solverparams_GradientTolerance
  //                double solverparams_SolutionTolerance
  //                bool solverparams_EnforceJointLimits
  //                bool solverparams_AllowRandomRestart
  //                double solverparams_StepTolerance
  // Return Type  : void
  //
  void generalizedInverseKinematics::set_SolverParameters(double
    solverparams_MaxIterations, double solverparams_MaxTime, double
    solverparams_GradientTolerance, double solverparams_SolutionTolerance, bool
    solverparams_EnforceJointLimits, bool solverparams_AllowRandomRestart,
    double solverparams_StepTolerance)
  {
    robotics::core::internal::DampedBFGSwGradientProjection *obj;
    EnforceJointLimits = solverparams_EnforceJointLimits;
    obj = Solver;
    obj->MaxNumIteration = solverparams_MaxIterations;
    obj->MaxTime = solverparams_MaxTime;
    obj->GradientTolerance = solverparams_GradientTolerance;
    obj->SolutionTolerance = solverparams_SolutionTolerance;
    obj->ConstraintsOn = true;
    obj->RandomRestart = solverparams_AllowRandomRestart;
    obj->StepTolerance = solverparams_StepTolerance;
  }

  //
  // Arguments    : const double b_value[4]
  // Return Type  : void
  //
  void constraintOrientationTarget::set_TargetOrientation(const double b_value[4])
  {
    double b;
    TargetOrientation[0] = b_value[0] * b_value[0];
    TargetOrientation[1] = b_value[1] * b_value[1];
    TargetOrientation[2] = b_value[2] * b_value[2];
    TargetOrientation[3] = b_value[3] * b_value[3];
    b = 1.0 / std::sqrt(((TargetOrientation[0] + TargetOrientation[1]) +
                         TargetOrientation[2]) + TargetOrientation[3]);
    TargetOrientation[0] = b_value[0] * b;
    TargetOrientation[1] = b_value[1] * b;
    TargetOrientation[2] = b_value[2] * b;
    TargetOrientation[3] = b_value[3] * b;
  }

  //
  // Arguments    : const double varargin_1[6]
  //                constraintPositionTarget &varargin_2
  //                constraintOrientationTarget &varargin_3
  //                double varargout_1[6]
  //                struct2_T varargout_2_ConstraintViolations[2]
  //                char varargout_2_Status_data[]
  //                int varargout_2_Status_size[2]
  //                double &varargout_2_NumRandomRestarts
  //                double &varargout_2_ExitFlag
  // Return Type  : double
  //
  double generalizedInverseKinematics::step(const double varargin_1[6],
    constraintPositionTarget &varargin_2, constraintOrientationTarget &
    varargin_3, double varargout_1[6], struct2_T
    varargout_2_ConstraintViolations[2], char varargout_2_Status_data[], int
    varargout_2_Status_size[2], double &varargout_2_NumRandomRestarts, double
    &varargout_2_ExitFlag)
  {
    robotics::manip::internal::b_RigidBodyTree *tree;
    array<double, 2U> A;
    array<double, 2U> b_value;
    array<double, 2U> r;
    array<double, 2U> y;
    array<double, 1U> b;
    array<double, 1U> obj;
    cell_wrap_58 residualIndices[2];
    cell_wrap_58 slackIndices[2];
    cell_wrap_59 equalityFlags[2];
    double varargout_2_Iterations;
    if (isInitialized != 1) {
      double numResidualsTotal;
      int b_loop_ub;
      int loop_ub;
      int obj_idx_0;
      isSetupComplete = false;
      isInitialized = 1;
      tree = Tree;
      Problem.Tree = tree;
      Problem.NumPositions = Problem.Tree->PositionNumber;
      tree = Problem.Tree;
      Problem._pobj1.TargetPosition[0] = 0.0;
      Problem._pobj1.TargetPosition[1] = 0.0;
      Problem._pobj1.TargetPosition[2] = 0.0;
      Problem._pobj1.Tree = tree;
      Problem._pobj1.NumElements = 1.0;
      obj_idx_0 = static_cast<int>(Problem._pobj1.NumElements);
      Problem._pobj1.BoundsInternal.set_size(obj_idx_0, 2);
      loop_ub = obj_idx_0 << 1;
      for (int i{0}; i < loop_ub; i++) {
        Problem._pobj1.BoundsInternal[i] = 0.0;
      }

      obj_idx_0 = static_cast<int>(Problem._pobj1.NumElements);
      Problem._pobj1.Weights.set_size(1, obj_idx_0);
      for (int i{0}; i < obj_idx_0; i++) {
        Problem._pobj1.Weights[i] = 1.0;
      }

      Problem._pobj1.EndEffectorIndex = 1.0;
      Problem._pobj1.ReferenceBodyIndex = 0.0;
      Problem._pobj1.matlabCodegenIsDeleted = false;
      Problem.Constraints.f1 = &Problem._pobj1;
      varargout_2_Iterations = Problem.Constraints.f1->NumElements;
      if (std::isnan(varargout_2_Iterations)) {
        residualIndices[0].f1.set_size(1, 1);
        residualIndices[0].f1[0] = rtNaN;
      } else if (varargout_2_Iterations < 1.0) {
        residualIndices[0].f1.set_size(1, 0);
      } else {
        residualIndices[0].f1.set_size(1, static_cast<int>
          (varargout_2_Iterations - 1.0) + 1);
        loop_ub = static_cast<int>(varargout_2_Iterations - 1.0);
        for (int i{0}; i <= loop_ub; i++) {
          residualIndices[0].f1[i] = static_cast<double>(i) + 1.0;
        }
      }

      loop_ub = residualIndices[0].f1.size(1);
      slackIndices[0].f1.set_size(1, residualIndices[0].f1.size(1));
      for (int i{0}; i < loop_ub; i++) {
        slackIndices[0].f1[i] = Problem.NumPositions + residualIndices[0].f1[i];
      }

      obj_idx_0 = static_cast<int>(varargout_2_Iterations);
      equalityFlags[0].f1.set_size(1, obj_idx_0);
      for (int i{0}; i < obj_idx_0; i++) {
        equalityFlags[0].f1[i] = false;
      }

      numResidualsTotal = varargout_2_Iterations;
      tree = Problem.Tree;
      for (int i{0}; i < 16; i++) {
        Problem._pobj0.TargetTransform[i] = iv[i];
      }

      Problem._pobj0.Tree = tree;
      Problem._pobj0.NumElements = 1.0;
      obj_idx_0 = static_cast<int>(Problem._pobj0.NumElements);
      Problem._pobj0.BoundsInternal.set_size(obj_idx_0, 2);
      loop_ub = obj_idx_0 << 1;
      for (int i{0}; i < loop_ub; i++) {
        Problem._pobj0.BoundsInternal[i] = 0.0;
      }

      obj_idx_0 = static_cast<int>(Problem._pobj0.NumElements);
      Problem._pobj0.Weights.set_size(1, obj_idx_0);
      for (int i{0}; i < obj_idx_0; i++) {
        Problem._pobj0.Weights[i] = 1.0;
      }

      Problem._pobj0.EndEffectorIndex = 1.0;
      Problem._pobj0.ReferenceBodyIndex = 0.0;
      Problem._pobj0.matlabCodegenIsDeleted = false;
      Problem.Constraints.f2 = &Problem._pobj0;
      varargout_2_Iterations = Problem.Constraints.f2->NumElements;
      if (std::isnan(varargout_2_Iterations)) {
        y.set_size(1, 1);
        y[0] = rtNaN;
      } else if (varargout_2_Iterations < 1.0) {
        y.set_size(1, 0);
      } else {
        y.set_size(1, static_cast<int>(varargout_2_Iterations - 1.0) + 1);
        loop_ub = static_cast<int>(varargout_2_Iterations - 1.0);
        for (int i{0}; i <= loop_ub; i++) {
          y[i] = static_cast<double>(i) + 1.0;
        }
      }

      loop_ub = y.size(1);
      residualIndices[1].f1.set_size(1, y.size(1));
      for (int i{0}; i < loop_ub; i++) {
        residualIndices[1].f1[i] = numResidualsTotal + y[i];
      }

      loop_ub = residualIndices[1].f1.size(1);
      slackIndices[1].f1.set_size(1, residualIndices[1].f1.size(1));
      for (int i{0}; i < loop_ub; i++) {
        slackIndices[1].f1[i] = Problem.NumPositions + residualIndices[1].f1[i];
      }

      obj_idx_0 = static_cast<int>(varargout_2_Iterations);
      equalityFlags[1].f1.set_size(1, obj_idx_0);
      for (int i{0}; i < obj_idx_0; i++) {
        equalityFlags[1].f1[i] = false;
      }

      numResidualsTotal += varargout_2_Iterations;
      Problem.ResidualIndices[0] = residualIndices[0];
      Problem.ResidualIndices[1] = residualIndices[1];
      Problem.SlackIndices[0] = slackIndices[0];
      Problem.SlackIndices[1] = slackIndices[1];
      Problem.EqualityFlags[0] = equalityFlags[0];
      Problem.EqualityFlags[1] = equalityFlags[1];
      Problem.NumResiduals = numResidualsTotal;
      Problem.NumSlacks = numResidualsTotal;
      Problem.NumVariables = Problem.NumPositions + Problem.NumSlacks;
      loop_ub = static_cast<int>(Problem.NumVariables);
      b_loop_ub = static_cast<int>(Problem.NumVariables);
      b_value.set_size(loop_ub, 2);
      for (int i{0}; i < loop_ub; i++) {
        b_value[i] = rtMinusInf;
      }

      for (int i{0}; i < b_loop_ub; i++) {
        b_value[i + b_value.size(0)] = rtInf;
      }

      Problem.DesignVariableBoundsInternal.set_size(loop_ub, 2);
      obj_idx_0 = b_value.size(0) << 1;
      for (int i{0}; i < obj_idx_0; i++) {
        Problem.DesignVariableBoundsInternal[i] = b_value[i];
      }

      b_loop_ub = 2 * b_value.size(0);
      A.set_size(b_loop_ub, loop_ub);
      obj_idx_0 = b_loop_ub * b_value.size(0);
      for (int i{0}; i < obj_idx_0; i++) {
        A[i] = 0.0;
      }

      b.set_size(b_loop_ub);
      for (int i{0}; i < b_loop_ub; i++) {
        b[i] = 0.0;
      }

      for (int i{0}; i < loop_ub; i++) {
        obj_idx_0 = static_cast<int>(static_cast<unsigned int>(i + 1) << 1);
        A[(obj_idx_0 + A.size(0) * i) - 2] = -1.0;
        A[(obj_idx_0 + A.size(0) * i) - 1] = 1.0;
        b[obj_idx_0 - 2] = -b_value[i];
        b[obj_idx_0 - 1] = b_value[i + b_value.size(0)];
      }

      Problem.ConstraintMatrixInternal.set_size(loop_ub, b_loop_ub);
      for (int i{0}; i < b_loop_ub; i++) {
        for (obj_idx_0 = 0; obj_idx_0 < loop_ub; obj_idx_0++) {
          Problem.ConstraintMatrixInternal[obj_idx_0 +
            Problem.ConstraintMatrixInternal.size(0) * i] = A[i + A.size(0) *
            obj_idx_0];
        }
      }

      Problem.ConstraintBoundInternal.set_size(b_loop_ub);
      for (int i{0}; i < b_loop_ub; i++) {
        Problem.ConstraintBoundInternal[i] = b[i];
      }

      Problem.EnforceJointLimitsInternal = true;
      if (Problem.EnforceJointLimitsInternal) {
        loop_ub = Problem.DesignVariableBoundsInternal.size(0);
        b_value.set_size(loop_ub, 2);
        b_loop_ub = Problem.DesignVariableBoundsInternal.size(0) << 1;
        for (int i{0}; i < b_loop_ub; i++) {
          b_value[i] = Problem.DesignVariableBoundsInternal[i];
        }

        varargout_2_Iterations = Problem.NumPositions;
        Problem.Tree->get_JointPositionLimits(r);
        if (varargout_2_Iterations < 1.0) {
          b_loop_ub = 0;
        } else {
          b_loop_ub = static_cast<int>(varargout_2_Iterations);
        }

        for (int i{0}; i < 2; i++) {
          for (obj_idx_0 = 0; obj_idx_0 < b_loop_ub; obj_idx_0++) {
            b_value[obj_idx_0 + b_value.size(0) * i] = r[obj_idx_0 + r.size(0) *
              i];
          }
        }

        Problem.DesignVariableBoundsInternal.set_size(loop_ub, 2);
        obj_idx_0 = b_value.size(0) << 1;
        for (int i{0}; i < obj_idx_0; i++) {
          Problem.DesignVariableBoundsInternal[i] = b_value[i];
        }

        b_loop_ub = 2 * b_value.size(0);
        A.set_size(b_loop_ub, loop_ub);
        obj_idx_0 = b_loop_ub * b_value.size(0);
        for (int i{0}; i < obj_idx_0; i++) {
          A[i] = 0.0;
        }

        b.set_size(b_loop_ub);
        for (int i{0}; i < b_loop_ub; i++) {
          b[i] = 0.0;
        }

        for (int i{0}; i < loop_ub; i++) {
          obj_idx_0 = static_cast<int>(static_cast<unsigned int>(i + 1) << 1);
          A[(obj_idx_0 + A.size(0) * i) - 2] = -1.0;
          A[(obj_idx_0 + A.size(0) * i) - 1] = 1.0;
          b[obj_idx_0 - 2] = -b_value[i];
          b[obj_idx_0 - 1] = b_value[i + b_value.size(0)];
        }

        Problem.ConstraintMatrixInternal.set_size(loop_ub, b_loop_ub);
        for (int i{0}; i < b_loop_ub; i++) {
          for (obj_idx_0 = 0; obj_idx_0 < loop_ub; obj_idx_0++) {
            Problem.ConstraintMatrixInternal[obj_idx_0 +
              Problem.ConstraintMatrixInternal.size(0) * i] = A[i + A.size(0) *
              obj_idx_0];
          }
        }

        Problem.ConstraintBoundInternal.set_size(b_loop_ub);
        for (int i{0}; i < b_loop_ub; i++) {
          Problem.ConstraintBoundInternal[i] = b[i];
        }
      } else {
        loop_ub = Problem.DesignVariableBoundsInternal.size(0);
        b_value.set_size(loop_ub, 2);
        b_loop_ub = Problem.DesignVariableBoundsInternal.size(0) << 1;
        for (int i{0}; i < b_loop_ub; i++) {
          b_value[i] = Problem.DesignVariableBoundsInternal[i];
        }

        b_loop_ub = static_cast<int>(Problem.NumPositions);
        obj_idx_0 = static_cast<int>(Problem.NumPositions);
        for (int i{0}; i < b_loop_ub; i++) {
          b_value[i] = rtMinusInf;
        }

        for (int i{0}; i < obj_idx_0; i++) {
          b_value[i + b_value.size(0)] = rtInf;
        }

        Problem.DesignVariableBoundsInternal.set_size(loop_ub, 2);
        obj_idx_0 = b_value.size(0) << 1;
        for (int i{0}; i < obj_idx_0; i++) {
          Problem.DesignVariableBoundsInternal[i] = b_value[i];
        }

        b_loop_ub = 2 * b_value.size(0);
        A.set_size(b_loop_ub, loop_ub);
        obj_idx_0 = b_loop_ub * b_value.size(0);
        for (int i{0}; i < obj_idx_0; i++) {
          A[i] = 0.0;
        }

        b.set_size(b_loop_ub);
        for (int i{0}; i < b_loop_ub; i++) {
          b[i] = 0.0;
        }

        for (int i{0}; i < loop_ub; i++) {
          obj_idx_0 = static_cast<int>(static_cast<unsigned int>(i + 1) << 1);
          A[(obj_idx_0 + A.size(0) * i) - 2] = -1.0;
          A[(obj_idx_0 + A.size(0) * i) - 1] = 1.0;
          b[obj_idx_0 - 2] = -b_value[i];
          b[obj_idx_0 - 1] = b_value[i + b_value.size(0)];
        }

        Problem.ConstraintMatrixInternal.set_size(loop_ub, b_loop_ub);
        for (int i{0}; i < b_loop_ub; i++) {
          for (obj_idx_0 = 0; obj_idx_0 < loop_ub; obj_idx_0++) {
            Problem.ConstraintMatrixInternal[obj_idx_0 +
              Problem.ConstraintMatrixInternal.size(0) * i] = A[i + A.size(0) *
              obj_idx_0];
          }
        }

        Problem.ConstraintBoundInternal.set_size(b_loop_ub);
        for (int i{0}; i < b_loop_ub; i++) {
          Problem.ConstraintBoundInternal[i] = b[i];
        }
      }

      Problem.updateDesignVariableBounds();
      obj_idx_0 = static_cast<int>(Problem.NumVariables);
      Problem.LastX.set_size(obj_idx_0);
      for (int i{0}; i < obj_idx_0; i++) {
        Problem.LastX[i] = 0.0;
      }

      obj.set_size(Problem.LastX.size(0));
      loop_ub = Problem.LastX.size(0) - 1;
      for (int i{0}; i <= loop_ub; i++) {
        obj[i] = Problem.LastX[i];
      }

      Problem.residualsInternal(obj, b, A);
      loop_ub = b.size(0);
      Problem.LastF.set_size(b.size(0));
      for (int i{0}; i < loop_ub; i++) {
        Problem.LastF[i] = b[i];
      }

      Problem.LastJ.set_size(A.size(0), A.size(1));
      obj_idx_0 = A.size(0) * A.size(1);
      for (int i{0}; i < obj_idx_0; i++) {
        Problem.LastJ[i] = A[i];
      }

      bool solverparams_EnforceJointLimits;
      Problem.matlabCodegenIsDeleted = false;
      solverparams_EnforceJointLimits = EnforceJointLimits;
      Problem.set_EnforceJointLimits(solverparams_EnforceJointLimits);
      Solver->ExtraArgs = &Problem;
      isSetupComplete = true;
    }

    return stepImpl(varargin_1, varargin_2, varargin_3, varargout_1,
                    varargout_2_ConstraintViolations, varargout_2_Status_data,
                    varargout_2_Status_size, varargout_2_NumRandomRestarts,
                    varargout_2_ExitFlag);
  }

  //
  // Arguments    : const double initialGuess[6]
  //                const constraintPositionTarget &varargin_1
  //                const constraintOrientationTarget &varargin_2
  //                double QSol[6]
  //                struct2_T solutionInfo_ConstraintViolations[2]
  //                char solutionInfo_Status_data[]
  //                int solutionInfo_Status_size[2]
  //                double &solutionInfo_NumRandomRestarts
  //                double &solutionInfo_ExitFlag
  // Return Type  : double
  //
  double generalizedInverseKinematics::stepImpl(const double initialGuess[6],
    const constraintPositionTarget &varargin_1, const
    constraintOrientationTarget &varargin_2, double QSol[6], struct2_T
    solutionInfo_ConstraintViolations[2], char solutionInfo_Status_data[], int
    solutionInfo_Status_size[2], double &solutionInfo_NumRandomRestarts, double
    &solutionInfo_ExitFlag)
  {
    static const char b_cv[14]{ 'b', 'e', 's', 't', ' ', 'a', 'v', 'a', 'i', 'l',
      'a', 'b', 'l', 'e' };

    static const char b_cv3[11]{ 'o', 'r', 'i', 'e', 'n', 't', 'a', 't', 'i',
      'o', 'n' };

    static const char b_cv2[8]{ 'p', 'o', 's', 'i', 't', 'i', 'o', 'n' };

    static const char b_cv1[7]{ 's', 'u', 'c', 'c', 'e', 's', 's' };

    robotics::core::internal::DampedBFGSwGradientProjection *b_obj;
    robotics::manip::internal::OrientationTarget *d_obj;
    robotics::manip::internal::PositionTarget *c_obj;
    robotics::manip::internal::b_RigidBodyTree *obj;
    array<double, 2U> Jrobot;
    array<double, 2U> b_value;
    array<double, 2U> b_y;
    array<double, 2U> limits;
    array<double, 2U> positionIndices;
    array<double, 1U> b_varargin_2;
    array<double, 1U> newseed;
    array<double, 1U> q;
    array<double, 1U> xSolPrev;
    array<int, 2U> r;
    cell_wrap_58 violationsCell[2];
    double positionMap_data[52];
    double kinematicPath_data[26];
    double T_data[16];
    double JTwist[6];
    double err;
    double errPrev;
    double iter;
    double solutionInfo_Iterations;
    double tol;
    int indicesUpperBoundViolation_data[6];
    int T_size[2];
    int i;
    int indicesUpperBoundViolation_size;
    int k;
    int nm1d2;
    int trueCount;
    signed char tmp_data[26];
    bool lbOK[6];
    bool ubOK[6];
    bool exitg1;
    bool guard1;
    bool y;
    robotics::core::internal::NLPSolverExitFlags exitFlag;
    robotics::core::internal::NLPSolverExitFlags exitFlagPrev;
    obj = Tree;
    for (i = 0; i < 6; i++) {
      QSol[i] = initialGuess[i];
    }

    obj->get_JointPositionLimits(limits);
    if (limits.size(0) == 6) {
      for (i = 0; i < 6; i++) {
        ubOK[i] = (initialGuess[i] <= limits[i + limits.size(0)] +
                   4.4408920985006262E-16);
      }
    } else {
      binary_expand_op_4(ubOK, initialGuess, limits);
    }

    if (limits.size(0) == 6) {
      for (i = 0; i < 6; i++) {
        lbOK[i] = (initialGuess[i] >= limits[i] - 4.4408920985006262E-16);
      }
    } else {
      binary_expand_op_3(lbOK, initialGuess, limits);
    }

    y = true;
    k = 0;
    exitg1 = false;
    while ((!exitg1) && (k <= 5)) {
      if (!ubOK[k]) {
        y = false;
        exitg1 = true;
      } else {
        k++;
      }
    }

    guard1 = false;
    if (y) {
      y = true;
      k = 0;
      exitg1 = false;
      while ((!exitg1) && (k <= 5)) {
        if (!lbOK[k]) {
          y = false;
          exitg1 = true;
        } else {
          k++;
        }
      }

      if (!y) {
        guard1 = true;
      }
    } else {
      guard1 = true;
    }

    if (guard1) {
      for (i = 0; i < 6; i++) {
        ubOK[i] = !ubOK[i];
      }

      indicesUpperBoundViolation_size = b_eml_find(ubOK,
        indicesUpperBoundViolation_data);
      for (i = 0; i < indicesUpperBoundViolation_size; i++) {
        k = indicesUpperBoundViolation_data[i];
        QSol[k - 1] = limits[(k + limits.size(0)) - 1];
      }

      for (i = 0; i < 6; i++) {
        lbOK[i] = !lbOK[i];
      }

      indicesUpperBoundViolation_size = b_eml_find(lbOK,
        indicesUpperBoundViolation_data);
      for (i = 0; i < indicesUpperBoundViolation_size; i++) {
        k = indicesUpperBoundViolation_data[i];
        QSol[k - 1] = limits[k - 1];
      }
    }

    Problem.update(varargin_1, varargin_2);
    Problem.set_EnforceJointLimits(EnforceJointLimits);
    i = Problem.ConstraintMatrixInternal.size(0);
    k = Problem.ConstraintMatrixInternal.size(1);
    b_value.set_size(i, k);
    nm1d2 = Problem.ConstraintMatrixInternal.size(0) *
      Problem.ConstraintMatrixInternal.size(1);
    for (trueCount = 0; trueCount < nm1d2; trueCount++) {
      b_value[trueCount] = Problem.ConstraintMatrixInternal[trueCount];
    }

    nm1d2 = b_value.size(0) * b_value.size(1);
    Solver->ConstraintMatrix.set_size(i, k);
    for (i = 0; i < nm1d2; i++) {
      Solver->ConstraintMatrix[i] = b_value[i];
    }

    nm1d2 = Problem.ConstraintBoundInternal.size(0);
    newseed.set_size(nm1d2);
    indicesUpperBoundViolation_size = Problem.ConstraintBoundInternal.size(0);
    for (i = 0; i < indicesUpperBoundViolation_size; i++) {
      newseed[i] = Problem.ConstraintBoundInternal[i];
    }

    Solver->ConstraintBound.set_size(nm1d2);
    for (i = 0; i < nm1d2; i++) {
      Solver->ConstraintBound[i] = newseed[i];
    }

    limits.set_size(Problem.DesignVariableBoundsInternal.size(0), 2);
    nm1d2 = Problem.DesignVariableBoundsInternal.size(0) << 1;
    for (i = 0; i < nm1d2; i++) {
      limits[i] = Problem.DesignVariableBoundsInternal[i];
    }

    err = Problem.NumPositions + 1.0;
    if (err > limits.size(0)) {
      i = 0;
      k = -1;
    } else {
      i = static_cast<int>(err) - 1;
      k = limits.size(0) - 1;
    }

    indicesUpperBoundViolation_size = static_cast<int>(Problem.NumSlacks);
    xSolPrev.set_size(indicesUpperBoundViolation_size + 6);
    for (trueCount = 0; trueCount < 6; trueCount++) {
      xSolPrev[trueCount] = QSol[trueCount];
    }

    for (trueCount = 0; trueCount < indicesUpperBoundViolation_size; trueCount++)
    {
      xSolPrev[trueCount + 6] = 0.0;
    }

    Problem.residuals(xSolPrev, newseed);
    nm1d2 = k - i;
    if (nm1d2 + 1 == newseed.size(0)) {
      q.set_size(nm1d2 + 1);
      for (k = 0; k <= nm1d2; k++) {
        err = limits[i + k];
        iter = newseed[k];
        q[k] = std::fmax(err, iter);
      }
    } else {
      xSolPrev.set_size(nm1d2 + 1);
      for (k = 0; k <= nm1d2; k++) {
        xSolPrev[k] = limits[i + k];
      }

      internal::expand_max(xSolPrev, newseed, q);
    }

    if (nm1d2 + 1 == q.size(0)) {
      newseed.set_size(nm1d2 + 1);
      for (k = 0; k <= nm1d2; k++) {
        err = limits[(i + k) + limits.size(0)];
        iter = q[k];
        newseed[k] = std::fmin(err, iter);
      }
    } else {
      xSolPrev.set_size(nm1d2 + 1);
      for (k = 0; k <= nm1d2; k++) {
        xSolPrev[k] = limits[(i + k) + limits.size(0)];
      }

      internal::expand_min(xSolPrev, q, newseed);
    }

    b_obj = Solver;
    b_obj->MaxNumIterationInternal = b_obj->MaxNumIteration;
    b_obj->MaxTimeInternal = b_obj->MaxTime;
    b_obj->SeedInternal.set_size(newseed.size(0) + 6);
    for (i = 0; i < 6; i++) {
      b_obj->SeedInternal[i] = QSol[i];
    }

    nm1d2 = newseed.size(0);
    for (i = 0; i < nm1d2; i++) {
      b_obj->SeedInternal[i + 6] = newseed[i];
    }

    tol = b_obj->SolutionTolerance;
    b_obj->TimeObj.StartTime.tv_sec = tic(b_obj->TimeObj.StartTime.tv_nsec);
    exitFlag = b_obj->solveInternal(xSolPrev, err, iter);
    solutionInfo_NumRandomRestarts = 0.0;
    solutionInfo_Iterations = iter;
    errPrev = err;
    exitFlagPrev = exitFlag;
    exitg1 = false;
    while ((!exitg1) && (b_obj->RandomRestart && (err > tol))) {
      b_obj->MaxNumIterationInternal -= iter;
      err = toc(b_obj->TimeObj.StartTime.tv_sec,
                b_obj->TimeObj.StartTime.tv_nsec);
      b_obj->MaxTimeInternal = b_obj->MaxTime - err;
      if (b_obj->MaxNumIterationInternal <= 0.0) {
        exitFlag = robotics::core::internal::NLPSolverExitFlags::
          IterationLimitExceeded;
      }

      if ((exitFlag == robotics::core::internal::NLPSolverExitFlags::
           IterationLimitExceeded) || (exitFlag == robotics::core::internal::
           NLPSolverExitFlags::TimeLimitExceeded)) {
        exitFlagPrev = exitFlag;
        exitg1 = true;
      } else {
        rigidBodyJoint::randomConfig(b_obj->ExtraArgs, newseed);
        nm1d2 = newseed.size(0);
        b_obj->SeedInternal.set_size(newseed.size(0));
        for (i = 0; i < nm1d2; i++) {
          b_obj->SeedInternal[i] = newseed[i];
        }

        exitFlag = b_obj->solveInternal(q, err, iter);
        if (err < errPrev) {
          nm1d2 = q.size(0);
          xSolPrev.set_size(q.size(0));
          for (i = 0; i < nm1d2; i++) {
            xSolPrev[i] = q[i];
          }

          errPrev = err;
          exitFlagPrev = exitFlag;
        }

        solutionInfo_NumRandomRestarts++;
        solutionInfo_Iterations += iter;
      }
    }

    if (errPrev < tol) {
      solutionInfo_Status_size[0] = 1;
      solutionInfo_Status_size[1] = 7;
      for (i = 0; i < 7; i++) {
        solutionInfo_Status_data[i] = b_cv1[i];
      }
    } else {
      solutionInfo_Status_size[0] = 1;
      solutionInfo_Status_size[1] = 14;
      for (i = 0; i < 14; i++) {
        solutionInfo_Status_data[i] = b_cv[i];
      }
    }

    err = Problem.NumPositions;
    if (err < 1.0) {
      nm1d2 = 0;
    } else {
      nm1d2 = static_cast<int>(err);
    }

    q.set_size(nm1d2);
    for (i = 0; i < nm1d2; i++) {
      q[i] = xSolPrev[i];
    }

    c_obj = Problem.Constraints.f1;
    c_obj->Tree->efficientFKAndJacobianForIK(q, c_obj->EndEffectorIndex,
      c_obj->ReferenceBodyIndex, T_data, T_size, Jrobot);
    err = c_obj->TargetPosition[0] - T_data[T_size[0] * 3];
    iter = c_obj->TargetPosition[1] - T_data[T_size[0] * 3 + 1];
    tol = c_obj->TargetPosition[2] - T_data[T_size[0] * 3 + 2];
    err = std::sqrt(((err * err + iter * iter) + tol * tol) +
                    2.2204460492503131E-16);
    nm1d2 = c_obj->BoundsInternal.size(0);
    newseed.set_size(nm1d2);
    indicesUpperBoundViolation_size = c_obj->BoundsInternal.size(0);
    for (i = 0; i < indicesUpperBoundViolation_size; i++) {
      newseed[i] = err - c_obj->BoundsInternal[i];
    }

    b_varargin_2.set_size(c_obj->BoundsInternal.size(0));
    indicesUpperBoundViolation_size = c_obj->BoundsInternal.size(0);
    for (i = 0; i < indicesUpperBoundViolation_size; i++) {
      b_varargin_2[i] = err - c_obj->BoundsInternal[i +
        c_obj->BoundsInternal.size(0)];
    }

    if (newseed.size(0) == b_varargin_2.size(0)) {
      violationsCell[0].f1.set_size(1, nm1d2);
      for (i = 0; i < nm1d2; i++) {
        iter = newseed[i];
        err = b_varargin_2[i];
        violationsCell[0].f1[i] = std::fmin(0.0, iter) + std::fmax(0.0, err);
      }
    } else {
      binary_expand_op_2(violationsCell, newseed, b_varargin_2);
    }

    d_obj = Problem.Constraints.f2;
    d_obj->Tree->efficientFKAndJacobianForIK(q, d_obj->EndEffectorIndex,
      d_obj->ReferenceBodyIndex, T_data, T_size, Jrobot);
    err = d_obj->evaluateFromTransform(T_data, T_size, JTwist);
    nm1d2 = d_obj->BoundsInternal.size(0);
    newseed.set_size(nm1d2);
    indicesUpperBoundViolation_size = d_obj->BoundsInternal.size(0);
    for (i = 0; i < indicesUpperBoundViolation_size; i++) {
      newseed[i] = err - d_obj->BoundsInternal[i];
    }

    b_varargin_2.set_size(d_obj->BoundsInternal.size(0));
    indicesUpperBoundViolation_size = d_obj->BoundsInternal.size(0);
    for (i = 0; i < indicesUpperBoundViolation_size; i++) {
      b_varargin_2[i] = err - d_obj->BoundsInternal[i +
        d_obj->BoundsInternal.size(0)];
    }

    if (newseed.size(0) == b_varargin_2.size(0)) {
      violationsCell[1].f1.set_size(1, nm1d2);
      for (i = 0; i < nm1d2; i++) {
        iter = newseed[i];
        err = b_varargin_2[i];
        violationsCell[1].f1[i] = std::fmin(0.0, iter) + std::fmax(0.0, err);
      }
    } else {
      binary_expand_op_1(violationsCell, newseed, b_varargin_2);
    }

    solutionInfo_ConstraintViolations[0].Type.size[0] = 1;
    solutionInfo_ConstraintViolations[0].Type.size[1] = 8;
    for (i = 0; i < 8; i++) {
      solutionInfo_ConstraintViolations[0].Type.data[i] = b_cv2[i];
    }

    solutionInfo_ConstraintViolations[1].Type.size[0] = 1;
    solutionInfo_ConstraintViolations[1].Type.size[1] = 11;
    for (i = 0; i < 11; i++) {
      solutionInfo_ConstraintViolations[1].Type.data[i] = b_cv3[i];
    }

    for (nm1d2 = 0; nm1d2 < 2; nm1d2++) {
      indicesUpperBoundViolation_size = violationsCell[nm1d2].f1.size(1);
      solutionInfo_ConstraintViolations[nm1d2].Violation.set_size(1,
        indicesUpperBoundViolation_size);
      for (i = 0; i < indicesUpperBoundViolation_size; i++) {
        solutionInfo_ConstraintViolations[nm1d2].Violation[i] =
          violationsCell[nm1d2].f1[i];
      }
    }

    Problem.get_KinematicPath(kinematicPath_data, T_size);
    obj = Tree;
    indicesUpperBoundViolation_size = T_size[1];
    trueCount = 0;
    nm1d2 = 0;
    for (int b_i{0}; b_i < indicesUpperBoundViolation_size; b_i++) {
      if (kinematicPath_data[b_i] != 0.0) {
        trueCount++;
        tmp_data[nm1d2] = static_cast<signed char>(b_i);
        nm1d2++;
      }
    }

    for (i = 0; i < 2; i++) {
      for (k = 0; k < trueCount; k++) {
        positionMap_data[k + trueCount * i] = obj->PositionDoFMap[(static_cast<
          int>(kinematicPath_data[tmp_data[k]]) + 12 * i) - 1];
      }
    }

    positionIndices.set_size(1, static_cast<int>(obj->PositionNumber));
    nm1d2 = static_cast<int>(obj->PositionNumber);
    for (i = 0; i < nm1d2; i++) {
      positionIndices[i] = 0.0;
    }

    err = 0.0;
    for (int b_i{0}; b_i < trueCount; b_i++) {
      iter = positionMap_data[b_i + trueCount];
      tol = iter - positionMap_data[b_i];
      if (tol + 1.0 > 0.0) {
        if (tol + 1.0 < 1.0) {
          b_y.set_size(1, 0);
        } else {
          b_y.set_size(1, static_cast<int>((tol + 1.0) - 1.0) + 1);
          nm1d2 = static_cast<int>((tol + 1.0) - 1.0);
          for (i = 0; i <= nm1d2; i++) {
            b_y[i] = static_cast<double>(i) + 1.0;
          }
        }

        nm1d2 = b_y.size(1);
        r.set_size(1, b_y.size(1));
        for (i = 0; i < nm1d2; i++) {
          r[i] = static_cast<int>(err + b_y[i]);
        }

        errPrev = positionMap_data[b_i];
        if (std::isnan(errPrev) || std::isnan(iter)) {
          b_y.set_size(1, 1);
          b_y[0] = rtNaN;
        } else if (iter < errPrev) {
          b_y.set_size(1, 0);
        } else if ((std::isinf(errPrev) || std::isinf(iter)) && (errPrev == iter))
        {
          b_y.set_size(1, 1);
          b_y[0] = rtNaN;
        } else if (std::floor(errPrev) == errPrev) {
          indicesUpperBoundViolation_size = static_cast<int>(tol);
          b_y.set_size(1, static_cast<int>(tol) + 1);
          for (i = 0; i <= indicesUpperBoundViolation_size; i++) {
            b_y[i] = errPrev + static_cast<double>(i);
          }
        } else {
          double apnd;
          double cdiff;
          double ndbl;
          ndbl = std::floor(tol + 0.5);
          apnd = errPrev + ndbl;
          cdiff = apnd - iter;
          if (std::abs(cdiff) < 4.4408920985006262E-16 * std::fmax(std::abs
               (errPrev), std::abs(iter))) {
            ndbl++;
            apnd = iter;
          } else if (cdiff > 0.0) {
            apnd = errPrev + (ndbl - 1.0);
          } else {
            ndbl++;
          }

          if (ndbl >= 0.0) {
            indicesUpperBoundViolation_size = static_cast<int>(ndbl);
          } else {
            indicesUpperBoundViolation_size = 0;
          }

          b_y.set_size(1, indicesUpperBoundViolation_size);
          if (indicesUpperBoundViolation_size > 0) {
            b_y[0] = errPrev;
            if (indicesUpperBoundViolation_size > 1) {
              b_y[indicesUpperBoundViolation_size - 1] = apnd;
              nm1d2 = (indicesUpperBoundViolation_size - 1) / 2;
              for (k = 0; k <= nm1d2 - 2; k++) {
                b_y[k + 1] = errPrev + (static_cast<double>(k) + 1.0);
                b_y[(indicesUpperBoundViolation_size - k) - 2] = apnd - (
                  static_cast<double>(k) + 1.0);
              }

              if (nm1d2 << 1 == indicesUpperBoundViolation_size - 1) {
                b_y[nm1d2] = (positionMap_data[b_i] + apnd) / 2.0;
              } else {
                b_y[nm1d2] = positionMap_data[b_i] + static_cast<double>(nm1d2);
                b_y[nm1d2 + 1] = apnd - static_cast<double>(nm1d2);
              }
            }
          }
        }

        nm1d2 = b_y.size(1) - 1;
        for (i = 0; i <= nm1d2; i++) {
          positionIndices[r[i] - 1] = b_y[i];
        }

        err += tol + 1.0;
      }
    }

    if (err < 1.0) {
      nm1d2 = 0;
    } else {
      nm1d2 = static_cast<int>(err);
    }

    positionIndices.set_size(positionIndices.size(0), nm1d2);
    for (i = 0; i < nm1d2; i++) {
      err = positionIndices[i];
      QSol[static_cast<int>(err) - 1] = xSolPrev[static_cast<int>(err) - 1];
    }

    solutionInfo_ExitFlag = static_cast<int>(exitFlagPrev);
    return solutionInfo_Iterations;
  }

  //
  // Arguments    : const array<double, 1U> &q
  //                double T[16]
  // Return Type  : void
  //
  void rigidBodyJoint::transformBodyToParent(const array<double, 1U> &q, double
    T[16]) const
  {
    static const char b_cv[8]{ 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };

    static const char b_cv1[8]{ 'f', 'l', 'o', 'a', 't', 'i', 'n', 'g' };

    double b[16];
    double b_I[16];
    double b_b[16];
    double d;
    double d1;
    double d2;
    double d3;
    int exitg1;
    int i;
    int kstr;
    bool result;
    if (TypeInternal.Length < 1.0) {
      i = 0;
    } else {
      i = static_cast<int>(TypeInternal.Length);
    }

    result = false;
    if (i == 8) {
      kstr = 0;
      do {
        exitg1 = 0;
        if (kstr < 8) {
          if (b_cv[kstr] != TypeInternal.Vector[kstr]) {
            exitg1 = 1;
          } else {
            kstr++;
          }
        } else {
          result = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);
    }

    if (result) {
      kstr = 0;
    } else {
      result = false;
      if (i == 9) {
        kstr = 0;
        do {
          exitg1 = 0;
          if (kstr < 9) {
            if (cv1[kstr] != TypeInternal.Vector[kstr]) {
              exitg1 = 1;
            } else {
              kstr++;
            }
          } else {
            result = true;
            exitg1 = 1;
          }
        } while (exitg1 == 0);
      }

      if (result) {
        kstr = 1;
      } else {
        result = false;
        if (i == 8) {
          kstr = 0;
          do {
            exitg1 = 0;
            if (kstr < 8) {
              if (b_cv1[kstr] != TypeInternal.Vector[kstr]) {
                exitg1 = 1;
              } else {
                kstr++;
              }
            } else {
              result = true;
              exitg1 = 1;
            }
          } while (exitg1 == 0);
        }

        if (result) {
          kstr = 2;
        } else {
          kstr = -1;
        }
      }
    }

    switch (kstr) {
     case 0:
      {
        double reshapes_f1_data[4];
        double v[3];
        signed char input_sizes_idx_1;
        get_JointAxis(v);
        input_sizes_idx_1 = static_cast<signed char>(q.size(0) != 0);
        reshapes_f1_data[0] = v[0];
        reshapes_f1_data[1] = v[1];
        reshapes_f1_data[2] = v[2];
        kstr = input_sizes_idx_1;
        if (kstr - 1 >= 0) {
          reshapes_f1_data[3] = q[0];
        }

        axang2tform(reshapes_f1_data, b);
      }
      break;

     case 1:
      {
        double v[3];
        signed char c_I[9];
        get_JointAxis(v);
        for (i = 0; i < 9; i++) {
          c_I[i] = 0;
        }

        c_I[0] = 1;
        c_I[4] = 1;
        c_I[8] = 1;
        for (i = 0; i < 3; i++) {
          kstr = i << 2;
          b[kstr] = c_I[3 * i];
          b[kstr + 1] = c_I[3 * i + 1];
          b[kstr + 2] = c_I[3 * i + 2];
          b[i + 12] = v[i] * q[0];
        }

        b[3] = 0.0;
        b[7] = 0.0;
        b[11] = 0.0;
        b[15] = 1.0;
      }
      break;

     case 2:
      {
        double dv[9];
        double reshapes_f1_data[4];
        std::memset(&b_I[0], 0, 16U * sizeof(double));
        b_I[0] = 1.0;
        b_I[5] = 1.0;
        b_I[10] = 1.0;
        b_I[15] = 1.0;
        b_I[12] = q[4];
        b_I[13] = q[5];
        b_I[14] = q[6];
        std::memset(&b_b[0], 0, 16U * sizeof(double));
        reshapes_f1_data[0] = q[0];
        reshapes_f1_data[1] = q[1];
        reshapes_f1_data[2] = q[2];
        reshapes_f1_data[3] = q[3];
        robotics::internal::quat2rotm(reshapes_f1_data, dv);
        for (i = 0; i < 3; i++) {
          kstr = i << 2;
          b_b[kstr] = dv[3 * i];
          b_b[kstr + 1] = dv[3 * i + 1];
          b_b[kstr + 2] = dv[3 * i + 2];
        }

        b_b[15] = 1.0;
        for (i = 0; i < 4; i++) {
          d = b_I[i];
          d1 = b_I[i + 4];
          d2 = b_I[i + 8];
          d3 = b_I[i + 12];
          for (int i1{0}; i1 < 4; i1++) {
            kstr = i1 << 2;
            b[i + kstr] = ((d * b_b[kstr] + d1 * b_b[kstr + 1]) + d2 * b_b[kstr
                           + 2]) + d3 * b_b[kstr + 3];
          }
        }
      }
      break;

     default:
      std::memset(&b[0], 0, 16U * sizeof(double));
      b[0] = 1.0;
      b[5] = 1.0;
      b[10] = 1.0;
      b[15] = 1.0;
      break;
    }

    for (i = 0; i < 4; i++) {
      d = JointToParentTransform[i];
      d1 = JointToParentTransform[i + 4];
      d2 = JointToParentTransform[i + 8];
      d3 = JointToParentTransform[i + 12];
      for (int i1{0}; i1 < 4; i1++) {
        kstr = i1 << 2;
        b_I[i + kstr] = ((d * b[kstr] + d1 * b[kstr + 1]) + d2 * b[kstr + 2]) +
          d3 * b[kstr + 3];
      }

      d = b_I[i];
      d1 = b_I[i + 4];
      d2 = b_I[i + 8];
      d3 = b_I[i + 12];
      for (int i1{0}; i1 < 4; i1++) {
        kstr = i1 << 2;
        T[i + kstr] = ((d * ChildToJointTransform[kstr] + d1 *
                        ChildToJointTransform[kstr + 1]) + d2 *
                       ChildToJointTransform[kstr + 2]) + d3 *
          ChildToJointTransform[kstr + 3];
      }
    }
  }

  //
  // Arguments    : void
  // Return Type  : void
  //
}

static void Matlab_checkCollision_delete()
{
  coder::robotics::manip::internal::RigidBody *obj;
  if (!robot.matlabCodegenIsDeleted) {
    robot.matlabCodegenIsDeleted = true;
  }

  if (!robot._pobj1.matlabCodegenIsDeleted) {
    robot._pobj1.matlabCodegenIsDeleted = true;
  }

  if (!robot._pobj1.Base.matlabCodegenIsDeleted) {
    robot._pobj1.Base.matlabCodegenIsDeleted = true;
  }

  for (int i{0}; i < 12; i++) {
    obj = &robot._pobj1._pobj2[i];
    if (!obj->matlabCodegenIsDeleted) {
      obj->matlabCodegenIsDeleted = true;
    }
  }

  robot._pobj0.matlabCodegenDestructor();
  robot._pobj1.Base._pobj0.matlabCodegenDestructor();
  robot._pobj1._pobj0[0].matlabCodegenDestructor();
  robot._pobj1._pobj0[1].matlabCodegenDestructor();
  robot._pobj1._pobj0[2].matlabCodegenDestructor();
  for (int i{0}; i < 12; i++) {
    robot._pobj1._pobj2[i]._pobj0.matlabCodegenDestructor();
  }
}

//
// Arguments    : void
// Return Type  : void
//
static void Matlab_checkCollision_init()
{
  robot_not_empty = false;
}

//
// Arguments    : void
// Return Type  : void
//
static void Matlab_checkCollision_new()
{
  for (int i{0}; i < 12; i++) {
    robot._pobj1._pobj2[i]._pobj0.matlabCodegenIsDeleted = true;
  }

  robot._pobj1._pobj0[0].matlabCodegenIsDeleted = true;
  robot._pobj1._pobj0[1].matlabCodegenIsDeleted = true;
  robot._pobj1._pobj0[2].matlabCodegenIsDeleted = true;
  robot._pobj1.Base._pobj0.matlabCodegenIsDeleted = true;
  robot._pobj0.matlabCodegenIsDeleted = true;
  for (int i{0}; i < 12; i++) {
    robot._pobj1._pobj2[i].matlabCodegenIsDeleted = true;
  }

  robot._pobj1.Base.matlabCodegenIsDeleted = true;
  robot._pobj1.matlabCodegenIsDeleted = true;
  robot.matlabCodegenIsDeleted = true;
}

//
// Arguments    : void
// Return Type  : void
//
static void Matlab_getForwardKinematics_delete()
{
  coder::robotics::manip::internal::RigidBody *obj;
  if (!gobj_3[0].matlabCodegenIsDeleted) {
    gobj_3[0].matlabCodegenIsDeleted = true;
  }

  if (!gobj_3[1].matlabCodegenIsDeleted) {
    gobj_3[1].matlabCodegenIsDeleted = true;
  }

  if (!gobj_3[0]._pobj1.matlabCodegenIsDeleted) {
    gobj_3[0]._pobj1.matlabCodegenIsDeleted = true;
  }

  if (!gobj_3[1]._pobj1.matlabCodegenIsDeleted) {
    gobj_3[1]._pobj1.matlabCodegenIsDeleted = true;
  }

  if (!gobj_3[0]._pobj1.Base.matlabCodegenIsDeleted) {
    gobj_3[0]._pobj1.Base.matlabCodegenIsDeleted = true;
  }

  if (!gobj_3[1]._pobj1.Base.matlabCodegenIsDeleted) {
    gobj_3[1]._pobj1.Base.matlabCodegenIsDeleted = true;
  }

  for (int i{0}; i < 2; i++) {
    for (int i1{0}; i1 < 12; i1++) {
      obj = &gobj_3[i]._pobj1._pobj2[i1];
      if (!obj->matlabCodegenIsDeleted) {
        obj->matlabCodegenIsDeleted = true;
      }
    }
  }

  gobj_3[0]._pobj0.matlabCodegenDestructor();
  gobj_3[1]._pobj0.matlabCodegenDestructor();
  gobj_3[0]._pobj1.Base._pobj0.matlabCodegenDestructor();
  gobj_3[1]._pobj1.Base._pobj0.matlabCodegenDestructor();
  for (int i{0}; i < 2; i++) {
    gobj_3[i]._pobj1._pobj0[0].matlabCodegenDestructor();
    gobj_3[i]._pobj1._pobj0[1].matlabCodegenDestructor();
    gobj_3[i]._pobj1._pobj0[2].matlabCodegenDestructor();
  }

  for (int i{0}; i < 2; i++) {
    for (int i1{0}; i1 < 12; i1++) {
      gobj_3[i]._pobj1._pobj2[i1]._pobj0.matlabCodegenDestructor();
    }
  }
}

//
// Arguments    : void
// Return Type  : void
//
static void Matlab_getForwardKinematics_init()
{
  b_robot_not_empty = false;
}

//
// Arguments    : void
// Return Type  : void
//
static void Matlab_getForwardKinematics_new()
{
  for (int i{0}; i < 2; i++) {
    for (int i1{0}; i1 < 12; i1++) {
      gobj_3[i]._pobj1._pobj2[i1]._pobj0.matlabCodegenIsDeleted = true;
    }
  }

  for (int i{0}; i < 2; i++) {
    gobj_3[i]._pobj1._pobj0[0].matlabCodegenIsDeleted = true;
    gobj_3[i]._pobj1._pobj0[1].matlabCodegenIsDeleted = true;
    gobj_3[i]._pobj1._pobj0[2].matlabCodegenIsDeleted = true;
  }

  gobj_3[0]._pobj1.Base._pobj0.matlabCodegenIsDeleted = true;
  gobj_3[1]._pobj1.Base._pobj0.matlabCodegenIsDeleted = true;
  gobj_3[0]._pobj0.matlabCodegenIsDeleted = true;
  gobj_3[1]._pobj0.matlabCodegenIsDeleted = true;
  for (int i{0}; i < 2; i++) {
    for (int i1{0}; i1 < 12; i1++) {
      gobj_3[i]._pobj1._pobj2[i1].matlabCodegenIsDeleted = true;
    }
  }

  gobj_3[0]._pobj1.Base.matlabCodegenIsDeleted = true;
  gobj_3[1]._pobj1.Base.matlabCodegenIsDeleted = true;
  gobj_3[0]._pobj1.matlabCodegenIsDeleted = true;
  gobj_3[1]._pobj1.matlabCodegenIsDeleted = true;
  gobj_3[0].matlabCodegenIsDeleted = true;
  gobj_3[1].matlabCodegenIsDeleted = true;
}

//
// Arguments    : void
// Return Type  : void
//
static void Matlab_getGikCut_delete()
{
  coder::robotics::manip::internal::RigidBody *obj;
  if (!robot_rbt.matlabCodegenIsDeleted) {
    robot_rbt.matlabCodegenIsDeleted = true;
  }

  if (!robot_rbt._pobj1.matlabCodegenIsDeleted) {
    robot_rbt._pobj1.matlabCodegenIsDeleted = true;
  }

  if (!robot_rbt._pobj1.Base.matlabCodegenIsDeleted) {
    robot_rbt._pobj1.Base.matlabCodegenIsDeleted = true;
  }

  for (int i{0}; i < 12; i++) {
    obj = &robot_rbt._pobj1._pobj2[i];
    if (!obj->matlabCodegenIsDeleted) {
      obj->matlabCodegenIsDeleted = true;
    }
  }

  robot_rbt._pobj0.matlabCodegenDestructor();
  robot_rbt._pobj1.Base._pobj0.matlabCodegenDestructor();
  robot_rbt._pobj1._pobj0[0].matlabCodegenDestructor();
  robot_rbt._pobj1._pobj0[1].matlabCodegenDestructor();
  robot_rbt._pobj1._pobj0[2].matlabCodegenDestructor();
  for (int i{0}; i < 12; i++) {
    robot_rbt._pobj1._pobj2[i]._pobj0.matlabCodegenDestructor();
  }
}

//
// Arguments    : void
// Return Type  : void
//
static void Matlab_getGikCut_init()
{
  robot_rbt_not_empty = false;
}

//
// Arguments    : void
// Return Type  : void
//
static void Matlab_getGikCut_new()
{
  for (int i{0}; i < 12; i++) {
    robot_rbt._pobj1._pobj2[i]._pobj0.matlabCodegenIsDeleted = true;
  }

  robot_rbt._pobj1._pobj0[0].matlabCodegenIsDeleted = true;
  robot_rbt._pobj1._pobj0[1].matlabCodegenIsDeleted = true;
  robot_rbt._pobj1._pobj0[2].matlabCodegenIsDeleted = true;
  robot_rbt._pobj1.Base._pobj0.matlabCodegenIsDeleted = true;
  robot_rbt._pobj0.matlabCodegenIsDeleted = true;
  for (int i{0}; i < 12; i++) {
    robot_rbt._pobj1._pobj2[i].matlabCodegenIsDeleted = true;
  }

  robot_rbt._pobj1.Base.matlabCodegenIsDeleted = true;
  robot_rbt._pobj1.matlabCodegenIsDeleted = true;
  robot_rbt.matlabCodegenIsDeleted = true;
}

//
// Arguments    : void
// Return Type  : void
//
static void Matlab_getGikFull_delete()
{
  coder::robotics::manip::internal::RigidBody *obj;
  if (!b_robot_rbt.matlabCodegenIsDeleted) {
    b_robot_rbt.matlabCodegenIsDeleted = true;
  }

  if (!b_robot_rbt._pobj1.matlabCodegenIsDeleted) {
    b_robot_rbt._pobj1.matlabCodegenIsDeleted = true;
  }

  if (!b_robot_rbt._pobj1.Base.matlabCodegenIsDeleted) {
    b_robot_rbt._pobj1.Base.matlabCodegenIsDeleted = true;
  }

  for (int i{0}; i < 12; i++) {
    obj = &b_robot_rbt._pobj1._pobj2[i];
    if (!obj->matlabCodegenIsDeleted) {
      obj->matlabCodegenIsDeleted = true;
    }
  }

  for (int i{0}; i < 50; i++) {
    obj = &gobj_6[i];
    if (!obj->matlabCodegenIsDeleted) {
      obj->matlabCodegenIsDeleted = true;
    }
  }

  b_robot_rbt._pobj0.matlabCodegenDestructor();
  b_robot_rbt._pobj1.Base._pobj0.matlabCodegenDestructor();
  b_robot_rbt._pobj1._pobj0[0].matlabCodegenDestructor();
  b_robot_rbt._pobj1._pobj0[1].matlabCodegenDestructor();
  b_robot_rbt._pobj1._pobj0[2].matlabCodegenDestructor();
  for (int i{0}; i < 12; i++) {
    b_robot_rbt._pobj1._pobj2[i]._pobj0.matlabCodegenDestructor();
  }

  for (int i{0}; i < 100; i++) {
    gobj_4[i].matlabCodegenDestructor();
  }

  for (int i{0}; i < 50; i++) {
    gobj_6[i]._pobj0.matlabCodegenDestructor();
  }
}

//
// Arguments    : void
// Return Type  : void
//
static void Matlab_getGikFull_init()
{
  b_robot_rbt_not_empty = false;
}

//
// Arguments    : void
// Return Type  : void
//
static void Matlab_getGikFull_new()
{
  for (int i{0}; i < 50; i++) {
    gobj_6[i]._pobj0.matlabCodegenIsDeleted = true;
  }

  for (int i{0}; i < 100; i++) {
    gobj_4[i].matlabCodegenIsDeleted = true;
  }

  for (int i{0}; i < 12; i++) {
    b_robot_rbt._pobj1._pobj2[i]._pobj0.matlabCodegenIsDeleted = true;
  }

  b_robot_rbt._pobj1._pobj0[0].matlabCodegenIsDeleted = true;
  b_robot_rbt._pobj1._pobj0[1].matlabCodegenIsDeleted = true;
  b_robot_rbt._pobj1._pobj0[2].matlabCodegenIsDeleted = true;
  b_robot_rbt._pobj1.Base._pobj0.matlabCodegenIsDeleted = true;
  b_robot_rbt._pobj0.matlabCodegenIsDeleted = true;
  for (int i{0}; i < 50; i++) {
    gobj_6[i].matlabCodegenIsDeleted = true;
  }

  for (int i{0}; i < 12; i++) {
    b_robot_rbt._pobj1._pobj2[i].matlabCodegenIsDeleted = true;
  }

  b_robot_rbt._pobj1.Base.matlabCodegenIsDeleted = true;
  b_robot_rbt._pobj1.matlabCodegenIsDeleted = true;
  b_robot_rbt.matlabCodegenIsDeleted = true;
}

//
// Arguments    : cell_wrap_58 in1[2]
//                const coder::array<double, 1U> &in3
//                const coder::array<double, 1U> &in5
// Return Type  : void
//
static void binary_expand_op_1(cell_wrap_58 in1[2], const coder::array<double,
  1U> &in3, const coder::array<double, 1U> &in5)
{
  int loop_ub;
  int stride_0_1;
  int stride_1_1;
  in1[1].f1.set_size(1, in1[1].f1.size(1));
  if (in5.size(0) == 1) {
    loop_ub = in3.size(0);
  } else {
    loop_ub = in5.size(0);
  }

  in1[1].f1.set_size(in1[1].f1.size(0), loop_ub);
  stride_0_1 = (in3.size(0) != 1);
  stride_1_1 = (in5.size(0) != 1);
  for (int i{0}; i < loop_ub; i++) {
    double b_varargin_2;
    double varargin_2;
    varargin_2 = in3[i * stride_0_1];
    b_varargin_2 = in5[i * stride_1_1];
    in1[1].f1[i] = std::fmin(0.0, varargin_2) + std::fmax(0.0, b_varargin_2);
  }
}

//
// Arguments    : coder::array<double, 1U> &in1
//                const coder::array<double, 1U> &in2
//                double in3
//                const coder::array<double, 1U> &in4
// Return Type  : void
//
static void binary_expand_op_10(coder::array<double, 1U> &in1, const coder::
  array<double, 1U> &in2, double in3, const coder::array<double, 1U> &in4)
{
  int loop_ub;
  int stride_0_0;
  int stride_1_0;
  if (in4.size(0) == 1) {
    loop_ub = in2.size(0);
  } else {
    loop_ub = in4.size(0);
  }

  in1.set_size(loop_ub);
  stride_0_0 = (in2.size(0) != 1);
  stride_1_0 = (in4.size(0) != 1);
  for (int i{0}; i < loop_ub; i++) {
    in1[i] = in2[i * stride_0_0] + in3 * in4[i * stride_1_0];
  }
}

//
// Arguments    : coder::array<double, 1U> &in1
//                const coder::array<double, 1U> &in2
//                const coder::array<double, 1U> &in3
// Return Type  : void
//
static void binary_expand_op_12(coder::array<double, 1U> &in1, const coder::
  array<double, 1U> &in2, const coder::array<double, 1U> &in3)
{
  coder::array<double, 1U> b_in1;
  int loop_ub;
  int stride_0_0;
  int stride_1_0;
  int stride_2_0;
  if (in3.size(0) == 1) {
    if (in2.size(0) == 1) {
      loop_ub = in1.size(0);
    } else {
      loop_ub = in2.size(0);
    }
  } else {
    loop_ub = in3.size(0);
  }

  b_in1.set_size(loop_ub);
  stride_0_0 = (in1.size(0) != 1);
  stride_1_0 = (in2.size(0) != 1);
  stride_2_0 = (in3.size(0) != 1);
  for (int i{0}; i < loop_ub; i++) {
    b_in1[i] = (in1[i * stride_0_0] - in2[i * stride_1_0]) / in3[i * stride_2_0];
  }

  in1.set_size(loop_ub);
  for (int i{0}; i < loop_ub; i++) {
    in1[i] = b_in1[i];
  }
}

//
// Arguments    : const coder::array<double, 1U> &in1
//                const coder::array<double, 1U> &in2
//                int &out2
// Return Type  : double
//
static double binary_expand_op_13(const coder::array<double, 1U> &in1, const
  coder::array<double, 1U> &in2, int &out2)
{
  coder::array<double, 1U> b_in1;
  int loop_ub;
  int stride_0_0;
  int stride_1_0;
  if (in2.size(0) == 1) {
    loop_ub = in1.size(0);
  } else {
    loop_ub = in2.size(0);
  }

  b_in1.set_size(loop_ub);
  stride_0_0 = (in1.size(0) != 1);
  stride_1_0 = (in2.size(0) != 1);
  for (int i{0}; i < loop_ub; i++) {
    b_in1[i] = in1[i * stride_0_0] / in2[i * stride_1_0];
  }

  return coder::internal::maximum(b_in1, out2);
}

//
// Arguments    : coder::array<int, 1U> &in1
//                const coder::array<double, 1U> &in2
//                const coder::robotics::core::internal::DampedBFGSwGradientProjection *in3
// Return Type  : void
//
static void binary_expand_op_14(coder::array<int, 1U> &in1, const coder::array<
  double, 1U> &in2, const coder::robotics::core::internal::
  DampedBFGSwGradientProjection *in3)
{
  coder::array<bool, 1U> b_in2;
  int loop_ub;
  int stride_0_0;
  int stride_1_0;
  if (in3->ConstraintBound.size(0) == 1) {
    loop_ub = in2.size(0);
  } else {
    loop_ub = in3->ConstraintBound.size(0);
  }

  b_in2.set_size(loop_ub);
  stride_0_0 = (in2.size(0) != 1);
  stride_1_0 = (in3->ConstraintBound.size(0) != 1);
  for (int i{0}; i < loop_ub; i++) {
    b_in2[i] = (in2[i * stride_0_0] >= in3->ConstraintBound[i * stride_1_0]);
  }

  coder::c_eml_find(b_in2, in1);
}

//
// Arguments    : coder::array<bool, 1U> &in1
//                const coder::array<double, 1U> &in2
//                const coder::robotics::core::internal::DampedBFGSwGradientProjection *in3
// Return Type  : void
//
static void binary_expand_op_15(coder::array<bool, 1U> &in1, const coder::array<
  double, 1U> &in2, const coder::robotics::core::internal::
  DampedBFGSwGradientProjection *in3)
{
  int loop_ub;
  int stride_0_0;
  int stride_1_0;
  if (in3->ConstraintBound.size(0) == 1) {
    loop_ub = in2.size(0);
  } else {
    loop_ub = in3->ConstraintBound.size(0);
  }

  in1.set_size(loop_ub);
  stride_0_0 = (in2.size(0) != 1);
  stride_1_0 = (in3->ConstraintBound.size(0) != 1);
  for (int i{0}; i < loop_ub; i++) {
    in1[i] = (in2[i * stride_0_0] - in3->ConstraintBound[i * stride_1_0] >
              1.4901161193847656E-8);
  }
}

//
// Arguments    : coder::array<double, 1U> &in1
//                const double in2_data[]
//                const int in2_size[2]
// Return Type  : void
//
static void binary_expand_op_16(coder::array<double, 1U> &in1, const double
  in2_data[], const int in2_size[2])
{
  double b_in2_data[7];
  int i;
  int loop_ub;
  int stride_0_0_tmp;
  int stride_1_0;
  if (in2_size[0] == 1) {
    i = in1.size(0);
  } else {
    i = in2_size[0];
  }

  if (i == 1) {
    loop_ub = in2_size[0];
  } else {
    loop_ub = i;
  }

  stride_0_0_tmp = (in2_size[0] != 1);
  stride_1_0 = (in1.size(0) != 1);
  for (i = 0; i < loop_ub; i++) {
    double b_in2_tmp;
    int in2_tmp;
    in2_tmp = i * stride_0_0_tmp;
    b_in2_tmp = in2_data[in2_tmp];
    b_in2_data[i] = b_in2_tmp + in1[i * stride_1_0] * (in2_data[in2_tmp +
      in2_size[0]] - b_in2_tmp);
  }

  in1.set_size(loop_ub);
  for (i = 0; i < loop_ub; i++) {
    in1[i] = b_in2_data[i];
  }
}

//
// Arguments    : coder::array<double, 1U> &in1
//                const double in2_data[]
//                const int in2_size[2]
//                const coder::array<double, 1U> &in3
// Return Type  : void
//
static void binary_expand_op_17(coder::array<double, 1U> &in1, const double
  in2_data[], const int in2_size[2], const coder::array<double, 1U> &in3)
{
  int loop_ub;
  int stride_0_0;
  int stride_1_0;
  if (in3.size(0) == 1) {
    loop_ub = in2_size[0];
  } else {
    loop_ub = in3.size(0);
  }

  in1.set_size(loop_ub);
  stride_0_0 = (in2_size[0] != 1);
  stride_1_0 = (in3.size(0) != 1);
  for (int i{0}; i < loop_ub; i++) {
    in1[i] = in2_data[i * stride_0_0] + in3[i * stride_1_0];
  }
}

//
// Arguments    : coder::array<double, 1U> &in1
//                const double in2_data[]
//                const int in2_size[2]
//                const coder::array<double, 1U> &in3
// Return Type  : void
//
static void binary_expand_op_18(coder::array<double, 1U> &in1, const double
  in2_data[], const int in2_size[2], const coder::array<double, 1U> &in3)
{
  int loop_ub;
  int stride_0_0;
  int stride_1_0;
  if (in3.size(0) == 1) {
    loop_ub = in2_size[0];
  } else {
    loop_ub = in3.size(0);
  }

  in1.set_size(loop_ub);
  stride_0_0 = (in2_size[0] != 1);
  stride_1_0 = (in3.size(0) != 1);
  for (int i{0}; i < loop_ub; i++) {
    in1[i] = in2_data[i * stride_0_0 + in2_size[0]] - in3[i * stride_1_0];
  }
}

//
// Arguments    : cell_wrap_58 in1[2]
//                const coder::array<double, 1U> &in3
//                const coder::array<double, 1U> &in5
// Return Type  : void
//
static void binary_expand_op_2(cell_wrap_58 in1[2], const coder::array<double,
  1U> &in3, const coder::array<double, 1U> &in5)
{
  int loop_ub;
  int stride_0_1;
  int stride_1_1;
  in1[0].f1.set_size(1, in1[0].f1.size(1));
  if (in5.size(0) == 1) {
    loop_ub = in3.size(0);
  } else {
    loop_ub = in5.size(0);
  }

  in1[0].f1.set_size(in1[0].f1.size(0), loop_ub);
  stride_0_1 = (in3.size(0) != 1);
  stride_1_1 = (in5.size(0) != 1);
  for (int i{0}; i < loop_ub; i++) {
    double b_varargin_2;
    double varargin_2;
    varargin_2 = in3[i * stride_0_1];
    b_varargin_2 = in5[i * stride_1_1];
    in1[0].f1[i] = std::fmin(0.0, varargin_2) + std::fmax(0.0, b_varargin_2);
  }
}

//
// Arguments    : bool in1[6]
//                const double in2[6]
//                const coder::array<double, 2U> &in3
// Return Type  : void
//
static void binary_expand_op_3(bool in1[6], const double in2[6], const coder::
  array<double, 2U> &in3)
{
  int stride_0_0;
  stride_0_0 = (in3.size(0) != 1);
  for (int i{0}; i < 6; i++) {
    in1[i] = (in2[i] >= in3[i * stride_0_0] - 4.4408920985006262E-16);
  }
}

//
// Arguments    : bool in1[6]
//                const double in2[6]
//                const coder::array<double, 2U> &in3
// Return Type  : void
//
static void binary_expand_op_4(bool in1[6], const double in2[6], const coder::
  array<double, 2U> &in3)
{
  int stride_0_0;
  stride_0_0 = (in3.size(0) != 1);
  for (int i{0}; i < 6; i++) {
    in1[i] = (in2[i] <= in3[i * stride_0_0 + in3.size(0)] +
              4.4408920985006262E-16);
  }
}

//
// Arguments    : const coder::array<double, 1U> &in1
//                double in2
//                const coder::array<double, 1U> &in3
//                coder::robotics::core::internal::DampedBFGSwGradientProjection *in4
//                coder::array<double, 2U> &in5
//                coder::array<double, 2U> &in6
//                coder::robotics::manip::internal::GIKProblem **out2
// Return Type  : double
//
static double binary_expand_op_5(const coder::array<double, 1U> &in1, double in2,
  const coder::array<double, 1U> &in3, coder::robotics::core::internal::
  DampedBFGSwGradientProjection *in4, coder::array<double, 2U> &in5, coder::
  array<double, 2U> &in6, coder::robotics::manip::internal::GIKProblem **out2)
{
  coder::array<double, 1U> b_in1;
  int loop_ub;
  int stride_0_0;
  int stride_1_0;
  if (in3.size(0) == 1) {
    loop_ub = in1.size(0);
  } else {
    loop_ub = in3.size(0);
  }

  b_in1.set_size(loop_ub);
  stride_0_0 = (in1.size(0) != 1);
  stride_1_0 = (in3.size(0) != 1);
  for (int i{0}; i < loop_ub; i++) {
    b_in1[i] = in1[i * stride_0_0] + in2 * in3[i * stride_1_0];
  }

  return coder::robotics::manip::internal::GIKHelpers::computeCost(b_in1,
    in4->ExtraArgs, in5, in6, out2);
}

//
// Arguments    : coder::array<double, 2U> &in1
//                double in2
//                const coder::array<double, 2U> &in3
// Return Type  : void
//
static void binary_expand_op_6(coder::array<double, 2U> &in1, double in2, const
  coder::array<double, 2U> &in3)
{
  coder::array<double, 2U> b_in1;
  int aux_0_1;
  int aux_1_1;
  int b_loop_ub;
  int loop_ub;
  int stride_0_0;
  int stride_0_1;
  int stride_1_0;
  int stride_1_1;
  if (in3.size(0) == 1) {
    loop_ub = in1.size(0);
  } else {
    loop_ub = in3.size(0);
  }

  if (in3.size(1) == 1) {
    b_loop_ub = in1.size(1);
  } else {
    b_loop_ub = in3.size(1);
  }

  b_in1.set_size(loop_ub, b_loop_ub);
  stride_0_0 = (in1.size(0) != 1);
  stride_0_1 = (in1.size(1) != 1);
  stride_1_0 = (in3.size(0) != 1);
  stride_1_1 = (in3.size(1) != 1);
  aux_0_1 = 0;
  aux_1_1 = 0;
  for (int i{0}; i < b_loop_ub; i++) {
    for (int i1{0}; i1 < loop_ub; i1++) {
      b_in1[i1 + b_in1.size(0) * i] = in1[i1 * stride_0_0 + in1.size(0) *
        aux_0_1] - in2 * in3[i1 * stride_1_0 + in3.size(0) * aux_1_1];
    }

    aux_1_1 += stride_1_1;
    aux_0_1 += stride_0_1;
  }

  in1.set_size(loop_ub, b_loop_ub);
  for (int i{0}; i < b_loop_ub; i++) {
    for (int i1{0}; i1 < loop_ub; i1++) {
      in1[i1 + in1.size(0) * i] = b_in1[i1 + b_in1.size(0) * i];
    }
  }
}

//
// Arguments    : coder::array<double, 2U> &in1
//                const coder::array<double, 2U> &in2
//                const coder::array<double, 1U> &in3
//                double in4
// Return Type  : void
//
static void binary_expand_op_7(coder::array<double, 2U> &in1, const coder::array<
  double, 2U> &in2, const coder::array<double, 1U> &in3, double in4)
{
  coder::array<double, 2U> b_in2;
  int aux_0_1;
  int aux_1_1;
  int b_loop_ub;
  int loop_ub;
  int stride_0_0;
  int stride_0_1;
  int stride_1_0_tmp;
  loop_ub = in3.size(0);
  in1.set_size(loop_ub, loop_ub);
  for (int i{0}; i < loop_ub; i++) {
    for (int i1{0}; i1 < loop_ub; i1++) {
      in1[i1 + in1.size(0) * i] = in3[i1] * in3[i] / in4;
    }
  }

  if (in1.size(0) == 1) {
    loop_ub = in2.size(0);
  } else {
    loop_ub = in1.size(0);
  }

  if (in1.size(1) == 1) {
    b_loop_ub = in2.size(1);
  } else {
    b_loop_ub = in1.size(1);
  }

  b_in2.set_size(loop_ub, b_loop_ub);
  stride_0_0 = (in2.size(0) != 1);
  stride_0_1 = (in2.size(1) != 1);
  stride_1_0_tmp = (in1.size(0) != 1);
  aux_0_1 = 0;
  aux_1_1 = 0;
  for (int i{0}; i < b_loop_ub; i++) {
    for (int i1{0}; i1 < loop_ub; i1++) {
      b_in2[i1 + b_in2.size(0) * i] = in2[i1 * stride_0_0 + in2.size(0) *
        aux_0_1] + in1[i1 * stride_1_0_tmp + in1.size(0) * aux_1_1];
    }

    aux_1_1 += stride_1_0_tmp;
    aux_0_1 += stride_0_1;
  }

  in1.set_size(loop_ub, b_loop_ub);
  for (int i{0}; i < b_loop_ub; i++) {
    for (int i1{0}; i1 < loop_ub; i1++) {
      in1[i1 + in1.size(0) * i] = b_in2[i1 + b_in2.size(0) * i];
    }
  }
}

//
// Arguments    : coder::array<double, 2U> &in1
//                const coder::array<double, 2U> &in2
//                const coder::array<double, 1U> &in3
//                const coder::array<double, 1U> &in4
//                double in5
// Return Type  : void
//
static void binary_expand_op_8(coder::array<double, 2U> &in1, const coder::array<
  double, 2U> &in2, const coder::array<double, 1U> &in3, const coder::array<
  double, 1U> &in4, double in5)
{
  coder::array<double, 2U> b_in2;
  int aux_0_1;
  int aux_1_1;
  int b_loop_ub;
  int loop_ub;
  int stride_0_0;
  int stride_0_1;
  int stride_1_0;
  int stride_1_1;
  loop_ub = in3.size(0);
  in1.set_size(loop_ub, in1.size(1));
  b_loop_ub = in4.size(0);
  in1.set_size(in1.size(0), b_loop_ub);
  for (int i{0}; i < b_loop_ub; i++) {
    for (int i1{0}; i1 < loop_ub; i1++) {
      in1[i1 + in1.size(0) * i] = in3[i1] * in4[i] / in5;
    }
  }

  if (in1.size(0) == 1) {
    loop_ub = in2.size(0);
  } else {
    loop_ub = in1.size(0);
  }

  if (in1.size(1) == 1) {
    b_loop_ub = in2.size(1);
  } else {
    b_loop_ub = in1.size(1);
  }

  b_in2.set_size(loop_ub, b_loop_ub);
  stride_0_0 = (in2.size(0) != 1);
  stride_0_1 = (in2.size(1) != 1);
  stride_1_0 = (in1.size(0) != 1);
  stride_1_1 = (in1.size(1) != 1);
  aux_0_1 = 0;
  aux_1_1 = 0;
  for (int i{0}; i < b_loop_ub; i++) {
    for (int i1{0}; i1 < loop_ub; i1++) {
      b_in2[i1 + b_in2.size(0) * i] = in2[i1 * stride_0_0 + in2.size(0) *
        aux_0_1] - in1[i1 * stride_1_0 + in1.size(0) * aux_1_1];
    }

    aux_1_1 += stride_1_1;
    aux_0_1 += stride_0_1;
  }

  in1.set_size(loop_ub, b_loop_ub);
  for (int i{0}; i < b_loop_ub; i++) {
    for (int i1{0}; i1 < loop_ub; i1++) {
      in1[i1 + in1.size(0) * i] = b_in2[i1 + b_in2.size(0) * i];
    }
  }
}

//
// Arguments    : coder::array<double, 1U> &in1
//                double in2
//                const coder::array<double, 1U> &in3
// Return Type  : void
//
static void binary_expand_op_9(coder::array<double, 1U> &in1, double in2, const
  coder::array<double, 1U> &in3)
{
  coder::array<double, 1U> b_in2;
  int loop_ub;
  int stride_0_0;
  int stride_1_0;
  if (in3.size(0) == 1) {
    loop_ub = in1.size(0);
  } else {
    loop_ub = in3.size(0);
  }

  b_in2.set_size(loop_ub);
  stride_0_0 = (in1.size(0) != 1);
  stride_1_0 = (in3.size(0) != 1);
  for (int i{0}; i < loop_ub; i++) {
    b_in2[i] = in2 * in1[i * stride_0_0] + in3[i * stride_1_0];
  }

  in1.set_size(loop_ub);
  for (int i{0}; i < loop_ub; i++) {
    in1[i] = b_in2[i];
  }
}

//
// Arguments    : const double axang_data[]
//                double H[16]
// Return Type  : void
//
namespace coder
{
  static void axang2tform(const double axang_data[], double H[16])
  {
    double R[9];
    double tempR[9];
    double b_tempR_tmp;
    double c_tempR_tmp;
    double cth;
    double d_tempR_tmp;
    double e_tempR_tmp;
    double f_tempR_tmp;
    double g_tempR_tmp;
    double h_tempR_tmp;
    double tempR_tmp;
    double theta;
    double v_idx_0;
    double v_idx_1;
    double v_idx_2;
    int k;
    theta = axang_data[0];
    v_idx_0 = theta * theta;
    theta = axang_data[1];
    v_idx_1 = theta * theta;
    theta = axang_data[2];
    theta = 1.0 / std::sqrt((v_idx_0 + v_idx_1) + theta * theta);
    v_idx_0 = axang_data[0] * theta;
    v_idx_1 = axang_data[1] * theta;
    v_idx_2 = axang_data[2] * theta;
    theta = axang_data[3];
    cth = std::cos(theta);
    theta = std::sin(theta);
    tempR_tmp = v_idx_0 * v_idx_0 * (1.0 - cth) + cth;
    tempR[0] = tempR_tmp;
    b_tempR_tmp = v_idx_0 * v_idx_1 * (1.0 - cth);
    c_tempR_tmp = v_idx_2 * theta;
    d_tempR_tmp = b_tempR_tmp - c_tempR_tmp;
    tempR[1] = d_tempR_tmp;
    e_tempR_tmp = v_idx_0 * v_idx_2 * (1.0 - cth);
    f_tempR_tmp = v_idx_1 * theta;
    g_tempR_tmp = e_tempR_tmp + f_tempR_tmp;
    tempR[2] = g_tempR_tmp;
    b_tempR_tmp += c_tempR_tmp;
    tempR[3] = b_tempR_tmp;
    c_tempR_tmp = v_idx_1 * v_idx_1 * (1.0 - cth) + cth;
    tempR[4] = c_tempR_tmp;
    h_tempR_tmp = v_idx_1 * v_idx_2 * (1.0 - cth);
    theta *= v_idx_0;
    v_idx_1 = h_tempR_tmp - theta;
    tempR[5] = v_idx_1;
    e_tempR_tmp -= f_tempR_tmp;
    tempR[6] = e_tempR_tmp;
    f_tempR_tmp = h_tempR_tmp + theta;
    tempR[7] = f_tempR_tmp;
    h_tempR_tmp = v_idx_2 * v_idx_2 * (1.0 - cth) + cth;
    tempR[8] = h_tempR_tmp;
    R[0] = tempR_tmp;
    R[1] = d_tempR_tmp;
    R[2] = g_tempR_tmp;
    R[3] = b_tempR_tmp;
    R[4] = c_tempR_tmp;
    R[5] = v_idx_1;
    R[6] = e_tempR_tmp;
    R[7] = f_tempR_tmp;
    R[8] = h_tempR_tmp;
    for (k = 0; k < 3; k++) {
      R[k] = tempR[3 * k];
      R[k + 3] = tempR[3 * k + 1];
      R[k + 6] = tempR[3 * k + 2];
    }

    std::memset(&H[0], 0, 16U * sizeof(double));
    for (int i{0}; i < 3; i++) {
      k = i << 2;
      H[k] = R[3 * i];
      H[k + 1] = R[3 * i + 1];
      H[k + 2] = R[3 * i + 2];
    }

    H[15] = 1.0;
  }

  //
  // Arguments    : const bool x[6]
  //                int i_data[]
  // Return Type  : int
  //
  static int b_eml_find(const bool x[6], int i_data[])
  {
    int i_size;
    int ii;
    bool exitg1;
    i_size = 0;
    ii = 0;
    exitg1 = false;
    while ((!exitg1) && (ii < 6)) {
      if (x[ii]) {
        i_size++;
        i_data[i_size - 1] = ii + 1;
        if (i_size >= 6) {
          exitg1 = true;
        } else {
          ii++;
        }
      } else {
        ii++;
      }
    }

    if (i_size < 1) {
      i_size = 0;
    }

    return i_size;
  }

  //
  // Arguments    : const double x[3]
  // Return Type  : double
  //
  static double b_norm(const double x[3])
  {
    double absxk;
    double scale;
    double t;
    double y;
    scale = 3.3121686421112381E-170;
    absxk = std::abs(x[0]);
    if (absxk > 3.3121686421112381E-170) {
      y = 1.0;
      scale = absxk;
    } else {
      t = absxk / 3.3121686421112381E-170;
      y = t * t;
    }

    absxk = std::abs(x[1]);
    if (absxk > scale) {
      t = scale / absxk;
      y = y * t * t + 1.0;
      scale = absxk;
    } else {
      t = absxk / scale;
      y += t * t;
    }

    absxk = std::abs(x[2]);
    if (absxk > scale) {
      t = scale / absxk;
      y = y * t * t + 1.0;
      scale = absxk;
    } else {
      t = absxk / scale;
      y += t * t;
    }

    return scale * std::sqrt(y);
  }

  //
  // Arguments    : const array<double, 1U> &x
  // Return Type  : double
  //
  static double b_norm(const array<double, 1U> &x)
  {
    double y;
    if (x.size(0) == 0) {
      y = 0.0;
    } else {
      y = 0.0;
      if (x.size(0) == 1) {
        y = std::abs(x[0]);
      } else {
        double scale;
        int kend;
        scale = 3.3121686421112381E-170;
        kend = x.size(0);
        for (int k{0}; k < kend; k++) {
          double absxk;
          absxk = std::abs(x[k]);
          if (absxk > scale) {
            double t;
            t = scale / absxk;
            y = y * t * t + 1.0;
            scale = absxk;
          } else {
            double t;
            t = absxk / scale;
            y += t * t;
          }
        }

        y = scale * std::sqrt(y);
      }
    }

    return y;
  }

  //
  // Arguments    : double varargin_1
  //                double r_data[]
  // Return Type  : int
  //
  static int b_rand(double varargin_1, double r_data[])
  {
    int i;
    int r_size;
    i = static_cast<int>(varargin_1);
    r_size = static_cast<int>(varargin_1);
    for (int k{0}; k < i; k++) {
      unsigned int u[2];

      // ========================= COPYRIGHT NOTICE ============================
      //  This is a uniform (0,1) pseudorandom number generator based on:
      //
      //  A C-program for MT19937, with initialization improved 2002/1/26.
      //  Coded by Takuji Nishimura and Makoto Matsumoto.
      //
      //  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
      //  All rights reserved.
      //
      //  Redistribution and use in source and binary forms, with or without
      //  modification, are permitted provided that the following conditions
      //  are met:
      //
      //    1. Redistributions of source code must retain the above copyright
      //       notice, this list of conditions and the following disclaimer.
      //
      //    2. Redistributions in binary form must reproduce the above copyright
      //       notice, this list of conditions and the following disclaimer
      //       in the documentation and/or other materials provided with the
      //       distribution.
      //
      //    3. The names of its contributors may not be used to endorse or
      //       promote products derived from this software without specific
      //       prior written permission.
      //
      //  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
      //  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
      //  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
      //  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
      //  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
      //  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
      //  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
      //  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
      //  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
      //  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
      //  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
      //
      // =============================   END   =================================
      do {
        internal::randfun::genrand_uint32_vector(state, u);
        u[0] >>= 5U;
        u[1] >>= 6U;
      } while ((u[0] == 0U) && (u[1] == 0U));

      r_data[k] = 1.1102230246251565E-16 * (static_cast<double>(u[0]) *
        6.7108864E+7 + static_cast<double>(u[1]));
    }

    return r_size;
  }

  //
  // Arguments    : double r[5]
  // Return Type  : void
  //
  static void b_rand(double r[5])
  {
    for (int k{0}; k < 5; k++) {
      unsigned int u[2];

      // ========================= COPYRIGHT NOTICE ============================
      //  This is a uniform (0,1) pseudorandom number generator based on:
      //
      //  A C-program for MT19937, with initialization improved 2002/1/26.
      //  Coded by Takuji Nishimura and Makoto Matsumoto.
      //
      //  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
      //  All rights reserved.
      //
      //  Redistribution and use in source and binary forms, with or without
      //  modification, are permitted provided that the following conditions
      //  are met:
      //
      //    1. Redistributions of source code must retain the above copyright
      //       notice, this list of conditions and the following disclaimer.
      //
      //    2. Redistributions in binary form must reproduce the above copyright
      //       notice, this list of conditions and the following disclaimer
      //       in the documentation and/or other materials provided with the
      //       distribution.
      //
      //    3. The names of its contributors may not be used to endorse or
      //       promote products derived from this software without specific
      //       prior written permission.
      //
      //  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
      //  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
      //  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
      //  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
      //  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
      //  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
      //  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
      //  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
      //  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
      //  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
      //  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
      //
      // =============================   END   =================================
      do {
        internal::randfun::genrand_uint32_vector(state, u);
        u[0] >>= 5U;
        u[1] >>= 6U;
      } while ((u[0] == 0U) && (u[1] == 0U));

      r[k] = 1.1102230246251565E-16 * (static_cast<double>(u[0]) * 6.7108864E+7
        + static_cast<double>(u[1]));
    }
  }

  //
  // Arguments    : double r[3]
  // Return Type  : void
  //
  static void b_randn(double r[3])
  {
    r[0] = internal::randfun::b_eml_rand_mt19937ar(state);
    r[1] = internal::randfun::b_eml_rand_mt19937ar(state);
    r[2] = internal::randfun::b_eml_rand_mt19937ar(state);
  }

  //
  // Arguments    : const array<bool, 1U> &x
  //                array<int, 1U> &i
  // Return Type  : void
  //
  static void c_eml_find(const array<bool, 1U> &x, array<int, 1U> &i)
  {
    int idx;
    int ii;
    int nx_tmp;
    bool exitg1;
    nx_tmp = x.size(0);
    idx = 0;
    i.set_size(x.size(0));
    ii = 0;
    exitg1 = false;
    while ((!exitg1) && (ii <= nx_tmp - 1)) {
      if (x[ii]) {
        idx++;
        i[idx - 1] = ii + 1;
        if (idx >= nx_tmp) {
          exitg1 = true;
        } else {
          ii++;
        }
      } else {
        ii++;
      }
    }

    if (x.size(0) == 1) {
      if (idx == 0) {
        i.set_size(0);
      }
    } else {
      if (idx < 1) {
        idx = 0;
      }

      i.set_size(idx);
    }
  }

  //
  // Arguments    : double r[3]
  // Return Type  : void
  //
  static void c_rand(double r[3])
  {
    for (int k{0}; k < 3; k++) {
      unsigned int u[2];

      // ========================= COPYRIGHT NOTICE ============================
      //  This is a uniform (0,1) pseudorandom number generator based on:
      //
      //  A C-program for MT19937, with initialization improved 2002/1/26.
      //  Coded by Takuji Nishimura and Makoto Matsumoto.
      //
      //  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
      //  All rights reserved.
      //
      //  Redistribution and use in source and binary forms, with or without
      //  modification, are permitted provided that the following conditions
      //  are met:
      //
      //    1. Redistributions of source code must retain the above copyright
      //       notice, this list of conditions and the following disclaimer.
      //
      //    2. Redistributions in binary form must reproduce the above copyright
      //       notice, this list of conditions and the following disclaimer
      //       in the documentation and/or other materials provided with the
      //       distribution.
      //
      //    3. The names of its contributors may not be used to endorse or
      //       promote products derived from this software without specific
      //       prior written permission.
      //
      //  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
      //  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
      //  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
      //  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
      //  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
      //  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
      //  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
      //  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
      //  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
      //  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
      //  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
      //
      // =============================   END   =================================
      do {
        internal::randfun::genrand_uint32_vector(state, u);
        u[0] >>= 5U;
        u[1] >>= 6U;
      } while ((u[0] == 0U) && (u[1] == 0U));

      r[k] = 1.1102230246251565E-16 * (static_cast<double>(u[0]) * 6.7108864E+7
        + static_cast<double>(u[1]));
    }
  }

  //
  // Arguments    : const double A[16]
  //                creal_T V[16]
  //                creal_T D[4]
  // Return Type  : void
  //
  static void eigStandard(const double A[16], creal_T V[16], creal_T D[4])
  {
    double b_A[16];
    double vr[16];
    double absxk;
    double anrm;
    int ihi;
    int k;
    bool exitg1;
    ::std::copy(&A[0], &A[16], &b_A[0]);
    anrm = 0.0;
    k = 0;
    exitg1 = false;
    while ((!exitg1) && (k < 16)) {
      absxk = std::abs(A[k]);
      if (std::isnan(absxk)) {
        anrm = rtNaN;
        exitg1 = true;
      } else {
        if (absxk > anrm) {
          anrm = absxk;
        }

        k++;
      }
    }

    if (std::isinf(anrm) || std::isnan(anrm)) {
      D[0].re = rtNaN;
      D[0].im = 0.0;
      D[1].re = rtNaN;
      D[1].im = 0.0;
      D[2].re = rtNaN;
      D[2].im = 0.0;
      D[3].re = rtNaN;
      D[3].im = 0.0;
      for (int g1_tmp_tmp{0}; g1_tmp_tmp < 16; g1_tmp_tmp++) {
        V[g1_tmp_tmp].re = rtNaN;
        V[g1_tmp_tmp].im = 0.0;
      }
    } else {
      double scale[4];
      double wi[4];
      double wr[4];
      double tau[3];
      double cscale;
      int ilo;
      int info;
      bool scalea;
      cscale = anrm;
      scalea = false;
      if ((anrm > 0.0) && (anrm < 6.7178761075670888E-139)) {
        scalea = true;
        cscale = 6.7178761075670888E-139;
        internal::reflapack::xzlascl(anrm, cscale, b_A);
      } else if (anrm > 1.4885657073574029E+138) {
        scalea = true;
        cscale = 1.4885657073574029E+138;
        internal::reflapack::xzlascl(anrm, cscale, b_A);
      }

      ilo = internal::reflapack::xzgebal(b_A, ihi, scale);
      internal::reflapack::xzgehrd(b_A, ilo, ihi, tau);
      ::std::copy(&b_A[0], &b_A[16], &vr[0]);
      internal::reflapack::xzunghr(ilo, ihi, vr, tau);
      info = internal::reflapack::xdlahqr(ilo, ihi, b_A, ilo, ihi, vr, wr, wi);
      if (info == 0) {
        double f1;
        int g1_tmp_tmp;
        internal::reflapack::xdtrevc3(b_A, vr);
        if (ilo != ihi) {
          for (int i{ilo}; i <= ihi; i++) {
            g1_tmp_tmp = i + 12;
            for (k = i; k <= g1_tmp_tmp; k += 4) {
              vr[k - 1] *= scale[i - 1];
            }
          }
        }

        g1_tmp_tmp = ilo - 1;
        for (int i{g1_tmp_tmp}; i >= 1; i--) {
          f1 = scale[i - 1];
          if (static_cast<int>(f1) != i) {
            absxk = vr[i - 1];
            vr[i - 1] = vr[static_cast<int>(f1) - 1];
            vr[static_cast<int>(f1) - 1] = absxk;
            absxk = vr[i + 3];
            vr[i + 3] = vr[static_cast<int>(f1) + 3];
            vr[static_cast<int>(f1) + 3] = absxk;
            absxk = vr[i + 7];
            vr[i + 7] = vr[static_cast<int>(f1) + 7];
            vr[static_cast<int>(f1) + 7] = absxk;
            absxk = vr[i + 11];
            vr[i + 11] = vr[static_cast<int>(f1) + 11];
            vr[static_cast<int>(f1) + 11] = absxk;
          }
        }

        g1_tmp_tmp = ihi + 1;
        for (int i{g1_tmp_tmp}; i < 5; i++) {
          f1 = scale[i - 1];
          if (static_cast<int>(f1) != i) {
            absxk = vr[i - 1];
            vr[i - 1] = vr[static_cast<int>(f1) - 1];
            vr[static_cast<int>(f1) - 1] = absxk;
            absxk = vr[i + 3];
            vr[i + 3] = vr[static_cast<int>(f1) + 3];
            vr[static_cast<int>(f1) + 3] = absxk;
            absxk = vr[i + 7];
            vr[i + 7] = vr[static_cast<int>(f1) + 7];
            vr[static_cast<int>(f1) + 7] = absxk;
            absxk = vr[i + 11];
            vr[i + 11] = vr[static_cast<int>(f1) + 11];
            vr[static_cast<int>(f1) + 11] = absxk;
          }
        }

        for (int i{0}; i < 4; i++) {
          f1 = wi[i];
          if (!(f1 < 0.0)) {
            if ((i + 1 != 4) && (f1 > 0.0)) {
              double c;
              double d;
              double d1;
              double f1_tmp;
              double g1_tmp;
              double s;
              int b_tmp;
              ihi = i << 2;
              absxk = std::abs(internal::blas::xnrm2(4, vr, ihi + 1));
              b_tmp = (i + 1) << 2;
              f1 = std::abs(internal::blas::xnrm2(4, vr, b_tmp + 1));
              if (absxk < f1) {
                absxk /= f1;
                absxk = f1 * std::sqrt(absxk * absxk + 1.0);
              } else if (absxk > f1) {
                f1 /= absxk;
                absxk *= std::sqrt(f1 * f1 + 1.0);
              } else if (std::isnan(f1)) {
                absxk = rtNaN;
              } else {
                absxk *= 1.4142135623730951;
              }

              absxk = 1.0 / absxk;
              g1_tmp_tmp = ihi + 4;
              for (k = ihi + 1; k <= g1_tmp_tmp; k++) {
                vr[k - 1] *= absxk;
              }

              g1_tmp_tmp = b_tmp + 4;
              for (k = b_tmp + 1; k <= g1_tmp_tmp; k++) {
                vr[k - 1] *= absxk;
              }

              f1 = vr[ihi];
              absxk = vr[b_tmp];
              s = vr[ihi + 1];
              g1_tmp = vr[b_tmp + 1];
              f1_tmp = vr[ihi + 2];
              c = vr[b_tmp + 2];
              d = vr[ihi + 3];
              d1 = vr[b_tmp + 3];
              k = 0;
              absxk = std::abs(f1 * f1 + absxk * absxk);
              s = std::abs(s * s + g1_tmp * g1_tmp);
              if (s > absxk) {
                k = 1;
                absxk = s;
              }

              s = std::abs(f1_tmp * f1_tmp + c * c);
              if (s > absxk) {
                k = 2;
                absxk = s;
              }

              if (std::abs(d * d + d1 * d1) > absxk) {
                k = 3;
              }

              f1_tmp = vr[k + ihi];
              f1 = std::abs(f1_tmp);
              g1_tmp_tmp = k + b_tmp;
              g1_tmp = vr[g1_tmp_tmp];
              absxk = std::abs(g1_tmp);
              if (g1_tmp == 0.0) {
                c = 1.0;
                s = 0.0;
              } else if (f1_tmp == 0.0) {
                c = 0.0;
                if (g1_tmp >= 0.0) {
                  s = 1.0;
                } else {
                  s = -1.0;
                }
              } else if ((f1 > 1.4916681462400413E-154) && (f1 <
                          4.7403759540545887E+153) && (absxk >
                          1.4916681462400413E-154) && (absxk <
                          4.7403759540545887E+153)) {
                s = std::sqrt(f1_tmp * f1_tmp + g1_tmp * g1_tmp);
                c = f1 / s;
                if (!(f1_tmp >= 0.0)) {
                  s = -s;
                }

                s = g1_tmp / s;
              } else {
                absxk = std::fmin(4.49423283715579E+307, std::fmax
                                  (2.2250738585072014E-308, std::fmax(f1, absxk)));
                f1 = f1_tmp / absxk;
                absxk = g1_tmp / absxk;
                s = std::sqrt(f1 * f1 + absxk * absxk);
                c = std::abs(f1) / s;
                if (!(f1_tmp >= 0.0)) {
                  s = -s;
                }

                s = absxk / s;
              }

              absxk = c * vr[ihi] + s * vr[b_tmp];
              vr[b_tmp] = c * vr[b_tmp] - s * vr[ihi];
              vr[ihi] = absxk;
              absxk = vr[b_tmp + 1];
              f1 = vr[ihi + 1];
              vr[b_tmp + 1] = c * absxk - s * f1;
              vr[ihi + 1] = c * f1 + s * absxk;
              absxk = vr[b_tmp + 2];
              f1 = vr[ihi + 2];
              vr[b_tmp + 2] = c * absxk - s * f1;
              vr[ihi + 2] = c * f1 + s * absxk;
              absxk = vr[b_tmp + 3];
              f1 = vr[ihi + 3];
              vr[b_tmp + 3] = c * absxk - s * f1;
              vr[ihi + 3] = c * f1 + s * absxk;
              vr[g1_tmp_tmp] = 0.0;
            } else {
              ihi = i << 2;
              absxk = 1.0 / internal::blas::xnrm2(4, vr, ihi + 1);
              g1_tmp_tmp = ihi + 4;
              for (k = ihi + 1; k <= g1_tmp_tmp; k++) {
                vr[k - 1] *= absxk;
              }
            }
          }
        }

        for (g1_tmp_tmp = 0; g1_tmp_tmp < 16; g1_tmp_tmp++) {
          V[g1_tmp_tmp].re = vr[g1_tmp_tmp];
          V[g1_tmp_tmp].im = 0.0;
        }

        for (ihi = 0; ihi < 3; ihi++) {
          if ((wi[ihi] > 0.0) && (wi[ihi + 1] < 0.0)) {
            g1_tmp_tmp = ihi << 2;
            k = (ihi + 1) << 2;
            absxk = V[k].re;
            V[g1_tmp_tmp].im = absxk;
            V[k].re = V[g1_tmp_tmp].re;
            V[k].im = -absxk;
            absxk = V[k + 1].re;
            V[g1_tmp_tmp + 1].im = absxk;
            V[k + 1].re = V[g1_tmp_tmp + 1].re;
            V[k + 1].im = -absxk;
            absxk = V[k + 2].re;
            V[g1_tmp_tmp + 2].im = absxk;
            V[k + 2].re = V[g1_tmp_tmp + 2].re;
            V[k + 2].im = -absxk;
            absxk = V[k + 3].re;
            V[g1_tmp_tmp + 3].im = absxk;
            V[k + 3].re = V[g1_tmp_tmp + 3].re;
            V[k + 3].im = -absxk;
          }
        }
      } else {
        for (int g1_tmp_tmp{0}; g1_tmp_tmp < 16; g1_tmp_tmp++) {
          V[g1_tmp_tmp].re = rtNaN;
          V[g1_tmp_tmp].im = 0.0;
        }
      }

      if (scalea) {
        internal::reflapack::xzlascl(cscale, anrm, 4 - info, wr, info + 1);
        internal::reflapack::xzlascl(cscale, anrm, 4 - info, wi, info + 1);
        if (info != 0) {
          internal::reflapack::xzlascl(cscale, anrm, ilo - 1, wr, 1);
          internal::reflapack::xzlascl(cscale, anrm, ilo - 1, wi, 1);
        }
      }

      if (info != 0) {
        for (int i{ilo}; i <= info; i++) {
          wr[i - 1] = rtNaN;
          wi[i - 1] = 0.0;
        }
      }

      D[0].re = wr[0];
      D[0].im = wi[0];
      D[1].re = wr[1];
      D[1].im = wi[1];
      D[2].re = wr[2];
      D[2].im = wi[2];
      D[3].re = wr[3];
      D[3].im = wi[3];
    }
  }

  //
  // Arguments    : const array<bool, 2U> &x
  //                array<int, 1U> &i
  //                array<int, 1U> &j
  // Return Type  : void
  //
  static void eml_find(const array<bool, 2U> &x, array<int, 1U> &i, array<int,
                       1U> &j)
  {
    int nx;
    nx = x.size(0) * x.size(1);
    if (nx == 0) {
      i.set_size(0);
      j.set_size(0);
    } else {
      int idx;
      int ii;
      int jj;
      bool exitg1;
      idx = 0;
      i.set_size(nx);
      j.set_size(nx);
      ii = 1;
      jj = 1;
      exitg1 = false;
      while ((!exitg1) && (jj <= x.size(1))) {
        bool guard1;
        guard1 = false;
        if (x[(ii + x.size(0) * (jj - 1)) - 1]) {
          idx++;
          i[idx - 1] = ii;
          j[idx - 1] = jj;
          if (idx >= nx) {
            exitg1 = true;
          } else {
            guard1 = true;
          }
        } else {
          guard1 = true;
        }

        if (guard1) {
          ii++;
          if (ii > x.size(0)) {
            ii = 1;
            jj++;
          }
        }
      }

      if (nx == 1) {
        if (idx == 0) {
          i.set_size(0);
          j.set_size(0);
        }
      } else {
        if (idx < 1) {
          nx = 0;
        } else {
          nx = idx;
        }

        i.set_size(nx);
        j.set_size(nx);
      }
    }
  }

  //
  // Arguments    : double d
  //                array<double, 2U> &y
  // Return Type  : void
  //
  static void eml_float_colon(double d, array<double, 2U> &y)
  {
    double apnd;
    double cdiff;
    double ndbl;
    int n;
    ndbl = std::floor(6.2731853071795864 / d + 0.5);
    apnd = ndbl * d;
    if (d > 0.0) {
      cdiff = apnd - 6.2731853071795864;
    } else {
      cdiff = 6.2731853071795864 - apnd;
    }

    if (std::abs(cdiff) < 2.7858539063084049E-15) {
      ndbl++;
      apnd = 6.2731853071795864;
    } else if (cdiff > 0.0) {
      apnd = (ndbl - 1.0) * d;
    } else {
      ndbl++;
    }

    if (ndbl >= 0.0) {
      n = static_cast<int>(ndbl);
    } else {
      n = 0;
    }

    y.set_size(1, n);
    if (n > 0) {
      y[0] = 0.0;
      if (n > 1) {
        int nm1d2;
        y[n - 1] = apnd;
        nm1d2 = (n - 1) / 2;
        for (int k{0}; k <= nm1d2 - 2; k++) {
          ndbl = (static_cast<double>(k) + 1.0) * d;
          y[k + 1] = ndbl;
          y[(n - k) - 2] = apnd - ndbl;
        }

        if (nm1d2 << 1 == n - 1) {
          y[nm1d2] = apnd / 2.0;
        } else {
          ndbl = static_cast<double>(nm1d2) * d;
          y[nm1d2] = ndbl;
          y[nm1d2 + 1] = apnd - ndbl;
        }
      }
    }
  }

  //
  // Arguments    : const char a_data[]
  //                const int a_size[2]
  //                const char b_data[]
  //                const int b_size[2]
  // Return Type  : bool
  //
  namespace internal
  {
    static bool b_strcmp(const char a_data[], const int a_size[2], const char
                         b_data[], const int b_size[2])
    {
      bool b;
      bool b_bool;
      b_bool = false;
      b = (a_size[1] == 0);
      if (b && (b_size[1] == 0)) {
        b_bool = true;
      } else if (a_size[1] == b_size[1]) {
        int kstr;
        kstr = 0;
        int exitg1;
        do {
          exitg1 = 0;
          if (kstr <= b_size[1] - 1) {
            if (a_data[kstr] != b_data[kstr]) {
              exitg1 = 1;
            } else {
              kstr++;
            }
          } else {
            b_bool = true;
            exitg1 = 1;
          }
        } while (exitg1 == 0);
      }

      return b_bool;
    }

    //
    // Arguments    : const char a_data[]
    //                const int a_size[2]
    //                const array<char, 2U> &b
    // Return Type  : bool
    //
    static bool b_strcmp(const char a_data[], const int a_size[2], const array<
                         char, 2U> &b)
    {
      int nb;
      bool b_b;
      bool b_bool;
      b_bool = false;
      nb = b.size(0) * b.size(1);
      b_b = (a_size[1] == 0);
      if (b_b && ((b.size(0) == 0) || (b.size(1) == 0))) {
        b_bool = true;
      } else if ((b.size(0) == 1) && (a_size[1] == b.size(1))) {
        int kstr;
        kstr = 0;
        int exitg1;
        do {
          exitg1 = 0;
          if (kstr <= nb - 1) {
            if (a_data[kstr] != b[kstr]) {
              exitg1 = 1;
            } else {
              kstr++;
            }
          } else {
            b_bool = true;
            exitg1 = 1;
          }
        } while (exitg1 == 0);
      }

      return b_bool;
    }

    //
    // Arguments    : const array<double, 2U> &A
    //                const array<double, 2U> &B
    //                array<double, 2U> &C
    // Return Type  : void
    //
    namespace blas
    {
      static void b_mtimes(const array<double, 2U> &A, const array<double, 2U>
                           &B, array<double, 2U> &C)
      {
        int inner;
        int mc_tmp;
        int nc_tmp;
        mc_tmp = A.size(1);
        inner = A.size(0);
        nc_tmp = B.size(1);
        C.set_size(A.size(1), B.size(1));
        for (int j{0}; j < nc_tmp; j++) {
          int boffset;
          int coffset;
          coffset = j * mc_tmp;
          boffset = j * B.size(0);
          for (int i{0}; i < mc_tmp; i++) {
            C[coffset + i] = 0.0;
          }

          for (int k{0}; k < inner; k++) {
            double bkj;
            bkj = B[boffset + k];
            for (int i{0}; i < mc_tmp; i++) {
              int b_i;
              b_i = coffset + i;
              C[b_i] = C[b_i] + A[i * A.size(0) + k] * bkj;
            }
          }
        }
      }

      //
      // Arguments    : int n
      //                const double x[9]
      //                int ix0
      // Return Type  : double
      //
      static double b_xnrm2(int n, const double x[9], int ix0)
      {
        double scale;
        double y;
        int kend;
        y = 0.0;
        scale = 3.3121686421112381E-170;
        kend = ix0 + n;
        for (int k{ix0}; k < kend; k++) {
          double absxk;
          absxk = std::abs(x[k - 1]);
          if (absxk > scale) {
            double t;
            t = scale / absxk;
            y = y * t * t + 1.0;
            scale = absxk;
          } else {
            double t;
            t = absxk / scale;
            y += t * t;
          }
        }

        return scale * std::sqrt(y);
      }

      //
      // Arguments    : const array<double, 2U> &A
      //                const array<double, 2U> &B
      //                array<double, 2U> &C
      // Return Type  : void
      //
      static void c_mtimes(const array<double, 2U> &A, const array<double, 2U>
                           &B, array<double, 2U> &C)
      {
        int inner;
        int mc_tmp;
        int nc_tmp;
        mc_tmp = A.size(0);
        inner = A.size(1);
        nc_tmp = B.size(0);
        C.set_size(A.size(0), B.size(0));
        for (int j{0}; j < nc_tmp; j++) {
          int coffset;
          coffset = j * mc_tmp;
          for (int i{0}; i < mc_tmp; i++) {
            C[coffset + i] = 0.0;
          }

          for (int k{0}; k < inner; k++) {
            double bkj;
            int aoffset;
            aoffset = k * A.size(0);
            bkj = B[k * B.size(0) + j];
            for (int i{0}; i < mc_tmp; i++) {
              int b_i;
              b_i = coffset + i;
              C[b_i] = C[b_i] + A[aoffset + i] * bkj;
            }
          }
        }
      }

      //
      // Arguments    : const array<double, 2U> &A
      //                const array<double, 2U> &B
      //                array<double, 2U> &C
      // Return Type  : void
      //
      static void mtimes(const array<double, 2U> &A, const array<double, 2U> &B,
                         array<double, 2U> &C)
      {
        int inner;
        int mc_tmp;
        int nc_tmp;
        mc_tmp = A.size(0);
        inner = A.size(1);
        nc_tmp = B.size(1);
        C.set_size(A.size(0), B.size(1));
        for (int j{0}; j < nc_tmp; j++) {
          int boffset;
          int coffset;
          coffset = j * mc_tmp;
          boffset = j * B.size(0);
          for (int i{0}; i < mc_tmp; i++) {
            C[coffset + i] = 0.0;
          }

          for (int k{0}; k < inner; k++) {
            double bkj;
            int aoffset;
            aoffset = k * A.size(0);
            bkj = B[boffset + k];
            for (int i{0}; i < mc_tmp; i++) {
              int b_i;
              b_i = coffset + i;
              C[b_i] = C[b_i] + A[aoffset + i] * bkj;
            }
          }
        }
      }

      //
      // Arguments    : int n
      //                double a
      //                const array<double, 1U> &x
      //                int ix0
      //                array<double, 2U> &y
      //                int iy0
      // Return Type  : void
      //
      static void xaxpy(int n, double a, const array<double, 1U> &x, int ix0,
                        array<double, 2U> &y, int iy0)
      {
        if ((n >= 1) && (!(a == 0.0))) {
          for (int k{0}; k < n; k++) {
            int i;
            i = (iy0 + k) - 1;
            y[i] = y[i] + a * x[(ix0 + k) - 1];
          }
        }
      }

      //
      // Arguments    : int n
      //                double a
      //                const array<double, 2U> &x
      //                int ix0
      //                array<double, 1U> &y
      //                int iy0
      // Return Type  : void
      //
      static void xaxpy(int n, double a, const array<double, 2U> &x, int ix0,
                        array<double, 1U> &y, int iy0)
      {
        if ((n >= 1) && (!(a == 0.0))) {
          for (int k{0}; k < n; k++) {
            int i;
            i = (iy0 + k) - 1;
            y[i] = y[i] + a * x[(ix0 + k) - 1];
          }
        }
      }

      //
      // Arguments    : int n
      //                double a
      //                int ix0
      //                array<double, 2U> &y
      //                int iy0
      // Return Type  : void
      //
      static void xaxpy(int n, double a, int ix0, array<double, 2U> &y, int iy0)
      {
        if ((n >= 1) && (!(a == 0.0))) {
          for (int k{0}; k < n; k++) {
            int i;
            i = (iy0 + k) - 1;
            y[i] = y[i] + a * y[(ix0 + k) - 1];
          }
        }
      }

      //
      // Arguments    : int n
      //                double a
      //                const double x[16]
      //                int ix0
      //                double y[12]
      // Return Type  : void
      //
      static void xaxpy(int n, double a, const double x[16], int ix0, double y
                        [12])
      {
        if ((n >= 1) && (!(a == 0.0))) {
          for (int k{0}; k < n; k++) {
            y[k + 8] += a * x[(ix0 + k) - 1];
          }
        }
      }

      //
      // Arguments    : double a
      //                const double x[9]
      //                int ix0
      //                double y[3]
      // Return Type  : void
      //
      static void xaxpy(double a, const double x[9], int ix0, double y[3])
      {
        if (!(a == 0.0)) {
          for (int k{0}; k < 2; k++) {
            y[k + 1] += a * x[(ix0 + k) - 1];
          }
        }
      }

      //
      // Arguments    : double a
      //                const double x[3]
      //                double y[9]
      //                int iy0
      // Return Type  : void
      //
      static void xaxpy(double a, const double x[3], double y[9], int iy0)
      {
        if (!(a == 0.0)) {
          for (int k{0}; k < 2; k++) {
            int i;
            i = (iy0 + k) - 1;
            y[i] += a * x[k + 1];
          }
        }
      }

      //
      // Arguments    : int n
      //                double a
      //                int ix0
      //                double y[9]
      //                int iy0
      // Return Type  : void
      //
      static void xaxpy(int n, double a, int ix0, double y[9], int iy0)
      {
        if (!(a == 0.0)) {
          for (int k{0}; k < n; k++) {
            int i;
            i = (iy0 + k) - 1;
            y[i] += a * y[(ix0 + k) - 1];
          }
        }
      }

      //
      // Arguments    : int n
      //                const double x[9]
      //                int ix0
      //                const double y[9]
      //                int iy0
      // Return Type  : double
      //
      static double xdotc(int n, const double x[9], int ix0, const double y[9],
                          int iy0)
      {
        double d;
        int i;
        d = 0.0;
        i = static_cast<unsigned char>(n);
        for (int k{0}; k < i; k++) {
          d += x[(ix0 + k) - 1] * y[(iy0 + k) - 1];
        }

        return d;
      }

      //
      // Arguments    : int n
      //                const double x[12]
      //                double beta1
      //                double y[16]
      //                int iy0
      // Return Type  : void
      //
      static void xgemv(int n, const double x[12], double beta1, double y[16],
                        int iy0)
      {
        int iy;
        int iyend;
        iyend = iy0 + 3;
        if (beta1 != 1.0) {
          if (beta1 == 0.0) {
            if (iy0 <= iyend) {
              std::memset(&y[iy0 + -1], 0, static_cast<unsigned int>((iyend -
                iy0) + 1) * sizeof(double));
            }
          } else {
            for (iy = iy0; iy <= iyend; iy++) {
              y[iy - 1] *= beta1;
            }
          }
        }

        iyend = 8;
        iy = ((n - 1) << 2) + 1;
        for (int iac{1}; iac <= iy; iac += 4) {
          int i;
          i = iac + 3;
          for (int ia{iac}; ia <= i; ia++) {
            int i1;
            i1 = ((iy0 + ia) - iac) - 1;
            y[i1] += y[ia - 1] * x[iyend];
          }

          iyend++;
        }
      }

      //
      // Arguments    : int n
      //                const double x[16]
      //                int ix0
      // Return Type  : double
      //
      static double xnrm2(int n, const double x[16], int ix0)
      {
        double y;
        y = 0.0;
        if (n >= 1) {
          if (n == 1) {
            y = std::abs(x[ix0 - 1]);
          } else {
            double scale;
            int kend;
            scale = 3.3121686421112381E-170;
            kend = ix0 + n;
            for (int k{ix0}; k < kend; k++) {
              double absxk;
              absxk = std::abs(x[k - 1]);
              if (absxk > scale) {
                double t;
                t = scale / absxk;
                y = y * t * t + 1.0;
                scale = absxk;
              } else {
                double t;
                t = absxk / scale;
                y += t * t;
              }
            }

            y = scale * std::sqrt(y);
          }
        }

        return y;
      }

      //
      // Arguments    : int n
      //                const array<double, 1U> &x
      //                int ix0
      // Return Type  : double
      //
      static double xnrm2(int n, const array<double, 1U> &x, int ix0)
      {
        double y;
        y = 0.0;
        if (n >= 1) {
          if (n == 1) {
            y = std::abs(x[ix0 - 1]);
          } else {
            double scale;
            int kend;
            scale = 3.3121686421112381E-170;
            kend = ix0 + n;
            for (int k{ix0}; k < kend; k++) {
              double absxk;
              absxk = std::abs(x[k - 1]);
              if (absxk > scale) {
                double t;
                t = scale / absxk;
                y = y * t * t + 1.0;
                scale = absxk;
              } else {
                double t;
                t = absxk / scale;
                y += t * t;
              }
            }

            y = scale * std::sqrt(y);
          }
        }

        return y;
      }

      //
      // Arguments    : int n
      //                const double x[3]
      // Return Type  : double
      //
      static double xnrm2(int n, const double x[3])
      {
        double y;
        y = 0.0;
        if (n >= 1) {
          if (n == 1) {
            y = std::abs(x[1]);
          } else {
            double absxk;
            double scale;
            double t;
            scale = 3.3121686421112381E-170;
            absxk = std::abs(x[1]);
            if (absxk > 3.3121686421112381E-170) {
              y = 1.0;
              scale = absxk;
            } else {
              t = absxk / 3.3121686421112381E-170;
              y = t * t;
            }

            absxk = std::abs(x[2]);
            if (absxk > scale) {
              t = scale / absxk;
              y = y * t * t + 1.0;
              scale = absxk;
            } else {
              t = absxk / scale;
              y += t * t;
            }

            y = scale * std::sqrt(y);
          }
        }

        return y;
      }

      //
      // Arguments    : const double x[3]
      // Return Type  : double
      //
      static double xnrm2(const double x[3])
      {
        double scale;
        double y;
        y = 0.0;
        scale = 3.3121686421112381E-170;
        for (int k{2}; k < 4; k++) {
          double absxk;
          absxk = std::abs(x[k - 1]);
          if (absxk > scale) {
            double t;
            t = scale / absxk;
            y = y * t * t + 1.0;
            scale = absxk;
          } else {
            double t;
            t = absxk / scale;
            y += t * t;
          }
        }

        return scale * std::sqrt(y);
      }

      //
      // Arguments    : int n
      //                const array<double, 2U> &x
      //                int ix0
      // Return Type  : double
      //
      static double xnrm2(int n, const array<double, 2U> &x, int ix0)
      {
        double y;
        y = 0.0;
        if (n >= 1) {
          if (n == 1) {
            y = std::abs(x[ix0 - 1]);
          } else {
            double scale;
            int kend;
            scale = 3.3121686421112381E-170;
            kend = ix0 + n;
            for (int k{ix0}; k < kend; k++) {
              double absxk;
              absxk = std::abs(x[k - 1]);
              if (absxk > scale) {
                double t;
                t = scale / absxk;
                y = y * t * t + 1.0;
                scale = absxk;
              } else {
                double t;
                t = absxk / scale;
                y += t * t;
              }
            }

            y = scale * std::sqrt(y);
          }
        }

        return y;
      }

      //
      // Arguments    : double x[9]
      //                int ix0
      //                int iy0
      //                double c
      //                double s
      // Return Type  : void
      //
      static void xrot(double x[9], int ix0, int iy0, double c, double s)
      {
        double temp;
        double temp_tmp;
        temp = x[iy0 - 1];
        temp_tmp = x[ix0 - 1];
        x[iy0 - 1] = c * temp - s * temp_tmp;
        x[ix0 - 1] = c * temp_tmp + s * temp;
        temp = c * x[ix0] + s * x[iy0];
        x[iy0] = c * x[iy0] - s * x[ix0];
        x[ix0] = temp;
        temp = x[iy0 + 1];
        temp_tmp = x[ix0 + 1];
        x[iy0 + 1] = c * temp - s * temp_tmp;
        x[ix0 + 1] = c * temp_tmp + s * temp;
      }

      //
      // Arguments    : double *a
      //                double &b
      //                double &s
      // Return Type  : double
      //
      static double xrotg(double *a, double &b, double &s)
      {
        double absa;
        double absb;
        double c;
        double scale;
        c = b;
        absa = std::abs(*a);
        absb = std::abs(b);
        if (absa > absb) {
          c = *a;
        }

        scale = absa + absb;
        if (scale == 0.0) {
          s = 0.0;
          c = 1.0;
          *a = 0.0;
          b = 0.0;
        } else {
          double ads;
          double bds;
          ads = absa / scale;
          bds = absb / scale;
          scale *= std::sqrt(ads * ads + bds * bds);
          if (c < 0.0) {
            scale = -scale;
          }

          c = *a / scale;
          s = b / scale;
          if (absa > absb) {
            b = s;
          } else if (c != 0.0) {
            b = 1.0 / c;
          } else {
            b = 1.0;
          }

          *a = scale;
        }

        return c;
      }

      //
      // Arguments    : double x[9]
      //                int ix0
      //                int iy0
      // Return Type  : void
      //
      static void xswap(double x[9], int ix0, int iy0)
      {
        double temp;
        temp = x[ix0 - 1];
        x[ix0 - 1] = x[iy0 - 1];
        x[iy0 - 1] = temp;
        temp = x[ix0];
        x[ix0] = x[iy0];
        x[iy0] = temp;
        temp = x[ix0 + 1];
        x[ix0 + 1] = x[iy0 + 1];
        x[iy0 + 1] = temp;
      }

      //
      // Arguments    : const array<double, 1U> &a
      //                const array<double, 1U> &b
      //                array<double, 1U> &c
      // Return Type  : void
      //
    }

    static void expand_max(const array<double, 1U> &a, const array<double, 1U>
      &b, array<double, 1U> &c)
    {
      int csz_idx_0;
      int u1;
      csz_idx_0 = a.size(0);
      u1 = b.size(0);
      if (csz_idx_0 <= u1) {
        u1 = csz_idx_0;
      }

      if (b.size(0) == 1) {
        csz_idx_0 = a.size(0);
      } else if (a.size(0) == 1) {
        csz_idx_0 = b.size(0);
      } else {
        csz_idx_0 = u1;
      }

      c.set_size(csz_idx_0);
      if (csz_idx_0 != 0) {
        bool b1;
        bool b_b;
        b_b = (a.size(0) != 1);
        b1 = (b.size(0) != 1);
        for (u1 = 0; u1 < csz_idx_0; u1++) {
          c[u1] = std::fmax(a[b_b * u1], b[b1 * u1]);
        }
      }
    }

    //
    // Arguments    : const array<double, 1U> &a
    //                const array<double, 1U> &b
    //                array<double, 1U> &c
    // Return Type  : void
    //
    static void expand_min(const array<double, 1U> &a, const array<double, 1U>
      &b, array<double, 1U> &c)
    {
      int csz_idx_0;
      int u1;
      csz_idx_0 = a.size(0);
      u1 = b.size(0);
      if (csz_idx_0 <= u1) {
        u1 = csz_idx_0;
      }

      if (b.size(0) == 1) {
        csz_idx_0 = a.size(0);
      } else if (a.size(0) == 1) {
        csz_idx_0 = b.size(0);
      } else {
        csz_idx_0 = u1;
      }

      c.set_size(csz_idx_0);
      if (csz_idx_0 != 0) {
        bool b1;
        bool b_b;
        b_b = (a.size(0) != 1);
        b1 = (b.size(0) != 1);
        for (u1 = 0; u1 < csz_idx_0; u1++) {
          c[u1] = std::fmin(a[b_b * u1], b[b1 * u1]);
        }
      }
    }

    //
    // Arguments    : array<double, 2U> &A
    //                array<double, 1U> &tau
    //                array<int, 2U> &jpvt
    // Return Type  : void
    //
    namespace lapack
    {
      static void xgeqp3(array<double, 2U> &A, array<double, 1U> &tau, array<int,
                         2U> &jpvt)
      {
        array<double, 1U> vn1;
        array<double, 1U> vn2;
        array<double, 1U> work;
        int i;
        int knt;
        int m_tmp;
        int minmana;
        int n_tmp;
        bool guard1;
        m_tmp = A.size(0);
        n_tmp = A.size(1);
        knt = A.size(0);
        minmana = A.size(1);
        if (knt <= minmana) {
          minmana = knt;
        }

        tau.set_size(minmana);
        for (i = 0; i < minmana; i++) {
          tau[i] = 0.0;
        }

        guard1 = false;
        if ((A.size(0) == 0) || (A.size(1) == 0)) {
          guard1 = true;
        } else {
          knt = A.size(0);
          minmana = A.size(1);
          if (knt <= minmana) {
            minmana = knt;
          }

          if (minmana < 1) {
            guard1 = true;
          } else {
            double smax;
            int k;
            int minmn;
            jpvt.set_size(1, n_tmp);
            knt = A.size(0);
            minmn = A.size(1);
            if (knt <= minmn) {
              minmn = knt;
            }

            work.set_size(n_tmp);
            vn1.set_size(n_tmp);
            vn2.set_size(n_tmp);
            for (k = 0; k < n_tmp; k++) {
              jpvt[k] = k + 1;
              work[k] = 0.0;
              smax = blas::xnrm2(m_tmp, A, k * m_tmp + 1);
              vn1[k] = smax;
              vn2[k] = smax;
            }

            for (int b_i{0}; b_i < minmn; b_i++) {
              double s;
              double temp2;
              int ii;
              int ip1;
              int lastc;
              int mmi;
              int nmi;
              int pvt;
              ip1 = b_i + 2;
              lastc = b_i * m_tmp;
              ii = lastc + b_i;
              nmi = n_tmp - b_i;
              mmi = m_tmp - b_i;
              if (nmi < 1) {
                minmana = -1;
              } else {
                minmana = 0;
                if (nmi > 1) {
                  smax = std::abs(vn1[b_i]);
                  for (k = 2; k <= nmi; k++) {
                    s = std::abs(vn1[(b_i + k) - 1]);
                    if (s > smax) {
                      minmana = k - 1;
                      smax = s;
                    }
                  }
                }
              }

              pvt = b_i + minmana;
              if (pvt + 1 != b_i + 1) {
                minmana = pvt * m_tmp;
                for (k = 0; k < m_tmp; k++) {
                  knt = minmana + k;
                  smax = A[knt];
                  i = lastc + k;
                  A[knt] = A[i];
                  A[i] = smax;
                }

                minmana = jpvt[pvt];
                jpvt[pvt] = jpvt[b_i];
                jpvt[b_i] = minmana;
                vn1[pvt] = vn1[b_i];
                vn2[pvt] = vn2[b_i];
              }

              if (b_i + 1 < m_tmp) {
                temp2 = A[ii];
                minmana = ii + 2;
                tau[b_i] = 0.0;
                if (mmi > 0) {
                  smax = blas::xnrm2(mmi - 1, A, ii + 2);
                  if (smax != 0.0) {
                    s = std::abs(A[ii]);
                    smax = std::abs(smax);
                    if (s < smax) {
                      s /= smax;
                      smax *= std::sqrt(s * s + 1.0);
                    } else if (s > smax) {
                      smax /= s;
                      smax = s * std::sqrt(smax * smax + 1.0);
                    } else if (std::isnan(smax)) {
                      smax = rtNaN;
                    } else {
                      smax = s * 1.4142135623730951;
                    }

                    if (A[ii] >= 0.0) {
                      smax = -smax;
                    }

                    if (std::abs(smax) < 1.0020841800044864E-292) {
                      knt = 0;
                      i = ii + mmi;
                      do {
                        knt++;
                        for (k = minmana; k <= i; k++) {
                          A[k - 1] = 9.9792015476736E+291 * A[k - 1];
                        }

                        smax *= 9.9792015476736E+291;
                        temp2 *= 9.9792015476736E+291;
                      } while ((std::abs(smax) < 1.0020841800044864E-292) &&
                               (knt < 20));

                      s = std::abs(temp2);
                      smax = std::abs(blas::xnrm2(mmi - 1, A, ii + 2));
                      if (s < smax) {
                        s /= smax;
                        smax *= std::sqrt(s * s + 1.0);
                      } else if (s > smax) {
                        smax /= s;
                        smax = s * std::sqrt(smax * smax + 1.0);
                      } else if (std::isnan(smax)) {
                        smax = rtNaN;
                      } else {
                        smax = s * 1.4142135623730951;
                      }

                      if (temp2 >= 0.0) {
                        smax = -smax;
                      }

                      tau[b_i] = (smax - temp2) / smax;
                      s = 1.0 / (temp2 - smax);
                      for (k = minmana; k <= i; k++) {
                        A[k - 1] = s * A[k - 1];
                      }

                      for (k = 0; k < knt; k++) {
                        smax *= 1.0020841800044864E-292;
                      }

                      temp2 = smax;
                    } else {
                      tau[b_i] = (smax - A[ii]) / smax;
                      s = 1.0 / (A[ii] - smax);
                      i = ii + mmi;
                      for (k = minmana; k <= i; k++) {
                        A[k - 1] = s * A[k - 1];
                      }

                      temp2 = smax;
                    }
                  }
                }

                A[ii] = temp2;
              } else {
                tau[b_i] = 0.0;
              }

              if (b_i + 1 < n_tmp) {
                int jA;
                int lastv;
                temp2 = A[ii];
                A[ii] = 1.0;
                jA = (ii + m_tmp) + 1;
                if (tau[b_i] != 0.0) {
                  bool exitg2;
                  lastv = mmi - 1;
                  minmana = (ii + mmi) - 1;
                  while ((lastv + 1 > 0) && (A[minmana] == 0.0)) {
                    lastv--;
                    minmana--;
                  }

                  lastc = nmi - 2;
                  exitg2 = false;
                  while ((!exitg2) && (lastc + 1 > 0)) {
                    int exitg1;
                    minmana = jA + lastc * m_tmp;
                    k = minmana;
                    do {
                      exitg1 = 0;
                      if (k <= minmana + lastv) {
                        if (A[k - 1] != 0.0) {
                          exitg1 = 1;
                        } else {
                          k++;
                        }
                      } else {
                        lastc--;
                        exitg1 = 2;
                      }
                    } while (exitg1 == 0);

                    if (exitg1 == 1) {
                      exitg2 = true;
                    }
                  }
                } else {
                  lastv = -1;
                  lastc = -1;
                }

                if (lastv + 1 > 0) {
                  if (lastc + 1 != 0) {
                    for (knt = 0; knt <= lastc; knt++) {
                      work[knt] = 0.0;
                    }

                    knt = 0;
                    i = jA + m_tmp * lastc;
                    for (pvt = jA; m_tmp < 0 ? pvt >= i : pvt <= i; pvt += m_tmp)
                    {
                      smax = 0.0;
                      minmana = pvt + lastv;
                      for (k = pvt; k <= minmana; k++) {
                        smax += A[k - 1] * A[(ii + k) - pvt];
                      }

                      work[knt] = work[knt] + smax;
                      knt++;
                    }
                  }

                  if (!(-tau[b_i] == 0.0)) {
                    for (knt = 0; knt <= lastc; knt++) {
                      if (work[knt] != 0.0) {
                        smax = work[knt] * -tau[b_i];
                        i = lastv + jA;
                        for (minmana = jA; minmana <= i; minmana++) {
                          A[minmana - 1] = A[minmana - 1] + A[(ii + minmana) -
                            jA] * smax;
                        }
                      }

                      jA += m_tmp;
                    }
                  }
                }

                A[ii] = temp2;
              }

              for (knt = ip1; knt <= n_tmp; knt++) {
                minmana = b_i + (knt - 1) * m_tmp;
                smax = vn1[knt - 1];
                if (smax != 0.0) {
                  s = std::abs(A[minmana]) / smax;
                  s = 1.0 - s * s;
                  if (s < 0.0) {
                    s = 0.0;
                  }

                  temp2 = smax / vn2[knt - 1];
                  temp2 = s * (temp2 * temp2);
                  if (temp2 <= 1.4901161193847656E-8) {
                    if (b_i + 1 < m_tmp) {
                      smax = blas::xnrm2(mmi - 1, A, minmana + 2);
                      vn1[knt - 1] = smax;
                      vn2[knt - 1] = smax;
                    } else {
                      vn1[knt - 1] = 0.0;
                      vn2[knt - 1] = 0.0;
                    }
                  } else {
                    vn1[knt - 1] = smax * std::sqrt(s);
                  }
                }
              }
            }
          }
        }

        if (guard1) {
          jpvt.set_size(1, n_tmp);
          for (knt = 0; knt < n_tmp; knt++) {
            jpvt[knt] = knt + 1;
          }
        }
      }

      //
      // Arguments    : const double x[4]
      //                int &idx
      // Return Type  : double
      //
    }

    static double maximum(const double x[4], int &idx)
    {
      double ex;
      int k;
      if (!std::isnan(x[0])) {
        idx = 1;
      } else {
        bool exitg1;
        idx = 0;
        k = 2;
        exitg1 = false;
        while ((!exitg1) && (k < 5)) {
          if (!std::isnan(x[k - 1])) {
            idx = k;
            exitg1 = true;
          } else {
            k++;
          }
        }
      }

      if (idx == 0) {
        ex = x[0];
        idx = 1;
      } else {
        int i;
        ex = x[idx - 1];
        i = idx + 1;
        for (k = i; k < 5; k++) {
          double d;
          d = x[k - 1];
          if (ex < d) {
            ex = d;
            idx = k;
          }
        }
      }

      return ex;
    }

    //
    // Arguments    : const array<double, 1U> &x
    //                int &idx
    // Return Type  : double
    //
    static double maximum(const array<double, 1U> &x, int &idx)
    {
      double ex;
      int last_tmp;
      last_tmp = x.size(0);
      if (x.size(0) <= 2) {
        if (x.size(0) == 1) {
          ex = x[0];
          idx = 1;
        } else {
          ex = x[x.size(0) - 1];
          if ((x[0] < ex) || (std::isnan(x[0]) && (!std::isnan(ex)))) {
            idx = x.size(0);
          } else {
            ex = x[0];
            idx = 1;
          }
        }
      } else {
        int k;
        if (!std::isnan(x[0])) {
          idx = 1;
        } else {
          bool exitg1;
          idx = 0;
          k = 2;
          exitg1 = false;
          while ((!exitg1) && (k <= last_tmp)) {
            if (!std::isnan(x[k - 1])) {
              idx = k;
              exitg1 = true;
            } else {
              k++;
            }
          }
        }

        if (idx == 0) {
          ex = x[0];
          idx = 1;
        } else {
          int i;
          ex = x[idx - 1];
          i = idx + 1;
          for (k = i; k <= last_tmp; k++) {
            double d;
            d = x[k - 1];
            if (ex < d) {
              ex = d;
              idx = k;
            }
          }
        }
      }

      return ex;
    }

    //
    // Arguments    : int idx_data[]
    //                double x_data[]
    //                int offset
    //                int np
    //                int nq
    //                int iwork_data[]
    //                double xwork_data[]
    // Return Type  : void
    //
    static void merge(int idx_data[], double x_data[], int offset, int np, int
                      nq, int iwork_data[], double xwork_data[])
    {
      if (nq != 0) {
        int iout;
        int n_tmp;
        int p;
        int q;
        n_tmp = np + nq;
        for (int j{0}; j < n_tmp; j++) {
          iout = offset + j;
          iwork_data[j] = idx_data[iout];
          xwork_data[j] = x_data[iout];
        }

        p = 0;
        q = np;
        iout = offset - 1;
        int exitg1;
        do {
          exitg1 = 0;
          iout++;
          if (xwork_data[p] <= xwork_data[q]) {
            idx_data[iout] = iwork_data[p];
            x_data[iout] = xwork_data[p];
            if (p + 1 < np) {
              p++;
            } else {
              exitg1 = 1;
            }
          } else {
            idx_data[iout] = iwork_data[q];
            x_data[iout] = xwork_data[q];
            if (q + 1 < n_tmp) {
              q++;
            } else {
              q = iout - p;
              for (int j{p + 1}; j <= np; j++) {
                iout = q + j;
                idx_data[iout] = iwork_data[j - 1];
                x_data[iout] = xwork_data[j - 1];
              }

              exitg1 = 1;
            }
          }
        } while (exitg1 == 0);
      }
    }

    //
    // Arguments    : array<int, 1U> &idx
    //                array<double, 1U> &x
    //                int offset
    //                int np
    //                int nq
    //                array<int, 1U> &iwork
    //                array<double, 1U> &xwork
    // Return Type  : void
    //
    static void merge(array<int, 1U> &idx, array<double, 1U> &x, int offset, int
                      np, int nq, array<int, 1U> &iwork, array<double, 1U>
                      &xwork)
    {
      if (nq != 0) {
        int iout;
        int n_tmp;
        int p;
        int q;
        n_tmp = np + nq;
        for (int j{0}; j < n_tmp; j++) {
          iout = offset + j;
          iwork[j] = idx[iout];
          xwork[j] = x[iout];
        }

        p = 0;
        q = np;
        iout = offset - 1;
        int exitg1;
        do {
          exitg1 = 0;
          iout++;
          if (xwork[p] <= xwork[q]) {
            idx[iout] = iwork[p];
            x[iout] = xwork[p];
            if (p + 1 < np) {
              p++;
            } else {
              exitg1 = 1;
            }
          } else {
            idx[iout] = iwork[q];
            x[iout] = xwork[q];
            if (q + 1 < n_tmp) {
              q++;
            } else {
              q = iout - p;
              for (int j{p + 1}; j <= np; j++) {
                iout = q + j;
                idx[iout] = iwork[j - 1];
                x[iout] = xwork[j - 1];
              }

              exitg1 = 1;
            }
          }
        } while (exitg1 == 0);
      }
    }

    //
    // Arguments    : array<int, 1U> &idx
    //                array<double, 1U> &x
    //                int offset
    //                int n
    //                int preSortLevel
    //                array<int, 1U> &iwork
    //                array<double, 1U> &xwork
    // Return Type  : void
    //
    static void merge_block(array<int, 1U> &idx, array<double, 1U> &x, int
      offset, int n, int preSortLevel, array<int, 1U> &iwork, array<double, 1U>
      &xwork)
    {
      int bLen;
      int nPairs;
      nPairs = n >> preSortLevel;
      bLen = 1 << preSortLevel;
      while (nPairs > 1) {
        int nTail;
        int tailOffset;
        if ((static_cast<unsigned int>(nPairs) & 1U) != 0U) {
          nPairs--;
          tailOffset = bLen * nPairs;
          nTail = n - tailOffset;
          if (nTail > bLen) {
            merge(idx, x, offset + tailOffset, bLen, nTail - bLen, iwork, xwork);
          }
        }

        tailOffset = bLen << 1;
        nPairs >>= 1;
        for (nTail = 0; nTail < nPairs; nTail++) {
          merge(idx, x, offset + nTail * tailOffset, bLen, bLen, iwork, xwork);
        }

        bLen = tailOffset;
      }

      if (n > bLen) {
        merge(idx, x, offset, bLen, n - bLen, iwork, xwork);
      }
    }

    //
    // Arguments    : const array<double, 1U> &x
    //                int &idx
    // Return Type  : double
    //
    static double minimum(const array<double, 1U> &x, int &idx)
    {
      double ex;
      int last_tmp;
      last_tmp = x.size(0);
      if (x.size(0) <= 2) {
        if (x.size(0) == 1) {
          ex = x[0];
          idx = 1;
        } else {
          ex = x[x.size(0) - 1];
          if ((x[0] > ex) || (std::isnan(x[0]) && (!std::isnan(ex)))) {
            idx = x.size(0);
          } else {
            ex = x[0];
            idx = 1;
          }
        }
      } else {
        int k;
        if (!std::isnan(x[0])) {
          idx = 1;
        } else {
          bool exitg1;
          idx = 0;
          k = 2;
          exitg1 = false;
          while ((!exitg1) && (k <= last_tmp)) {
            if (!std::isnan(x[k - 1])) {
              idx = k;
              exitg1 = true;
            } else {
              k++;
            }
          }
        }

        if (idx == 0) {
          ex = x[0];
          idx = 1;
        } else {
          int i;
          ex = x[idx - 1];
          i = idx + 1;
          for (k = i; k <= last_tmp; k++) {
            double d;
            d = x[k - 1];
            if (ex > d) {
              ex = d;
              idx = k;
            }
          }
        }
      }

      return ex;
    }

    //
    // Arguments    : unsigned int b_state[625]
    // Return Type  : double
    //
    namespace randfun
    {
      static double b_eml_rand_mt19937ar(unsigned int b_state[625])
      {
        static const double dv[257]{ 0.0, 0.215241895984875, 0.286174591792068,
          0.335737519214422, 0.375121332878378, 0.408389134611989,
          0.43751840220787, 0.46363433679088, 0.487443966139235,
          0.50942332960209, 0.529909720661557, 0.549151702327164,
          0.567338257053817, 0.584616766106378, 0.601104617755991,
          0.61689699000775, 0.63207223638606, 0.646695714894993,
          0.660822574244419, 0.674499822837293, 0.687767892795788,
          0.700661841106814, 0.713212285190975, 0.725446140909999,
          0.737387211434295, 0.749056662017815, 0.760473406430107,
          0.771654424224568, 0.782615023307232, 0.793369058840623,
          0.80392911698997, 0.814306670135215, 0.824512208752291,
          0.834555354086381, 0.844444954909153, 0.854189171008163,
          0.863795545553308, 0.87327106808886, 0.882622229585165,
          0.891855070732941, 0.900975224461221, 0.909987953496718,
          0.91889818364959, 0.927710533401999, 0.936429340286575,
          0.945058684468165, 0.953602409881086, 0.96206414322304,
          0.970447311064224, 0.978755155294224, 0.986990747099062,
          0.99515699963509, 1.00325667954467, 1.01129241744, 1.01926671746548,
          1.02718196603564, 1.03504043983344, 1.04284431314415, 1.05059566459093,
          1.05829648333067, 1.06594867476212, 1.07355406579244, 1.0811144097034,
          1.08863139065398, 1.09610662785202, 1.10354167942464, 1.11093804601357,
          1.11829717411934, 1.12562045921553, 1.13290924865253, 1.14016484436815,
          1.14738850542085, 1.15458145035993, 1.16174485944561, 1.16887987673083,
          1.17598761201545, 1.18306914268269, 1.19012551542669, 1.19715774787944,
          1.20416683014438, 1.2111537262437, 1.21811937548548, 1.22506469375653,
          1.23199057474614, 1.23889789110569, 1.24578749554863, 1.2526602218949,
          1.25951688606371, 1.26635828701823, 1.27318520766536, 1.27999841571382,
          1.28679866449324, 1.29358669373695, 1.30036323033084, 1.30712898903073,
          1.31388467315022, 1.32063097522106, 1.32736857762793, 1.33409815321936,
          1.3408203658964, 1.34753587118059, 1.35424531676263, 1.36094934303328,
          1.36764858359748, 1.37434366577317, 1.38103521107586, 1.38772383568998,
          1.39441015092814, 1.40109476367925, 1.4077782768464, 1.41446128977547,
          1.42114439867531, 1.42782819703026, 1.43451327600589, 1.44120022484872,
          1.44788963128058, 1.45458208188841, 1.46127816251028, 1.46797845861808,
          1.47468355569786, 1.48139403962819, 1.48811049705745, 1.49483351578049,
          1.50156368511546, 1.50830159628131, 1.51504784277671, 1.521803020761,
          1.52856772943771, 1.53534257144151, 1.542128153229, 1.54892508547417,
          1.55573398346918, 1.56255546753104, 1.56939016341512, 1.57623870273591,
          1.58310172339603, 1.58997987002419, 1.59687379442279, 1.60378415602609,
          1.61071162236983, 1.61765686957301, 1.62462058283303, 1.63160345693487,
          1.63860619677555, 1.64562951790478, 1.65267414708306, 1.65974082285818,
          1.66683029616166, 1.67394333092612, 1.68108070472517, 1.68824320943719,
          1.69543165193456, 1.70264685479992, 1.7098896570713, 1.71716091501782,
          1.72446150294804, 1.73179231405296, 1.73915426128591, 1.74654827828172,
          1.75397532031767, 1.76143636531891, 1.76893241491127, 1.77646449552452,
          1.78403365954944, 1.79164098655216, 1.79928758454972, 1.80697459135082,
          1.81470317596628, 1.82247454009388, 1.83028991968276, 1.83815058658281,
          1.84605785028518, 1.8540130597602, 1.86201760539967, 1.87007292107127,
          1.878180486293, 1.88634182853678, 1.8945585256707, 1.90283220855043,
          1.91116456377125, 1.91955733659319, 1.92801233405266, 1.93653142827569,
          1.94511656000868, 1.95376974238465, 1.96249306494436, 1.97128869793366,
          1.98015889690048, 1.98910600761744, 1.99813247135842, 2.00724083056053,
          2.0164337349062, 2.02571394786385, 2.03508435372962, 2.04454796521753,
          2.05410793165065, 2.06376754781173, 2.07353026351874, 2.0833996939983,
          2.09337963113879, 2.10347405571488, 2.11368715068665, 2.12402331568952,
          2.13448718284602, 2.14508363404789, 2.15581781987674, 2.16669518035431,
          2.17772146774029, 2.18890277162636, 2.20024554661128, 2.21175664288416,
          2.22344334009251, 2.23531338492992, 2.24737503294739, 2.25963709517379,
          2.27210899022838, 2.28480080272449, 2.29772334890286, 2.31088825060137,
          2.32430801887113, 2.33799614879653, 2.35196722737914, 2.36623705671729,
          2.38082279517208, 2.39574311978193, 2.41101841390112, 2.42667098493715,
          2.44272531820036, 2.4592083743347, 2.47614993967052, 2.49358304127105,
          2.51154444162669, 2.53007523215985, 2.54922155032478, 2.56903545268184,
          2.58957598670829, 2.61091051848882, 2.63311639363158, 2.65628303757674,
          2.68051464328574, 2.70593365612306, 2.73268535904401, 2.76094400527999,
          2.79092117400193, 2.82287739682644, 2.85713873087322, 2.89412105361341,
          2.93436686720889, 2.97860327988184, 3.02783779176959, 3.08352613200214,
          3.147889289518, 3.2245750520478, 3.32024473383983, 3.44927829856143,
          3.65415288536101, 3.91075795952492 };

        static const double dv1[257]{ 1.0, 0.977101701267673, 0.959879091800108,
          0.9451989534423, 0.932060075959231, 0.919991505039348,
          0.908726440052131, 0.898095921898344, 0.887984660755834,
          0.878309655808918, 0.869008688036857, 0.860033621196332,
          0.851346258458678, 0.842915653112205, 0.834716292986884,
          0.826726833946222, 0.818929191603703, 0.811307874312656,
          0.803849483170964, 0.796542330422959, 0.789376143566025,
          0.782341832654803, 0.775431304981187, 0.768637315798486,
          0.761953346836795, 0.755373506507096, 0.748892447219157,
          0.742505296340151, 0.736207598126863, 0.729995264561476,
          0.72386453346863, 0.717811932630722, 0.711834248878248,
          0.705928501332754, 0.700091918136512, 0.694321916126117,
          0.688616083004672, 0.682972161644995, 0.677388036218774,
          0.671861719897082, 0.66639134390875, 0.660975147776663,
          0.655611470579697, 0.650298743110817, 0.645035480820822,
          0.639820277453057, 0.634651799287624, 0.629528779924837,
          0.624450015547027, 0.619414360605834, 0.614420723888914,
          0.609468064925773, 0.604555390697468, 0.599681752619125,
          0.594846243767987, 0.590047996332826, 0.585286179263371,
          0.580559996100791, 0.575868682972354, 0.571211506735253,
          0.566587763256165, 0.561996775814525, 0.557437893618766,
          0.552910490425833, 0.548413963255266, 0.543947731190026,
          0.539511234256952, 0.535103932380458, 0.530725304403662,
          0.526374847171684, 0.522052074672322, 0.517756517229756,
          0.513487720747327, 0.509245245995748, 0.505028667943468,
          0.500837575126149, 0.49667156905249, 0.492530263643869,
          0.488413284705458, 0.484320269426683, 0.480250865909047,
          0.476204732719506, 0.47218153846773, 0.468180961405694,
          0.464202689048174, 0.460246417812843, 0.456311852678716,
          0.452398706861849, 0.448506701507203, 0.444635565395739,
          0.440785034665804, 0.436954852547985, 0.433144769112652,
          0.429354541029442, 0.425583931338022, 0.421832709229496,
          0.418100649837848, 0.414387534040891, 0.410693148270188,
          0.407017284329473, 0.403359739221114, 0.399720314980197,
          0.396098818515832, 0.392495061459315, 0.388908860018789,
          0.385340034840077, 0.381788410873393, 0.378253817245619,
          0.374736087137891, 0.371235057668239, 0.367750569779032,
          0.364282468129004, 0.360830600989648, 0.357394820145781,
          0.353974980800077, 0.350570941481406, 0.347182563956794,
          0.343809713146851, 0.340452257044522, 0.337110066637006,
          0.333783015830718, 0.330470981379163, 0.327173842813601,
          0.323891482376391, 0.320623784956905, 0.317370638029914,
          0.314131931596337, 0.310907558126286, 0.307697412504292,
          0.30450139197665, 0.301319396100803, 0.298151326696685,
          0.294997087799962, 0.291856585617095, 0.288729728482183,
          0.285616426815502, 0.282516593083708, 0.279430141761638,
          0.276356989295668, 0.273297054068577, 0.270250256365875,
          0.267216518343561, 0.264195763997261, 0.261187919132721,
          0.258192911337619, 0.255210669954662, 0.252241126055942,
          0.249284212418529, 0.246339863501264, 0.24340801542275,
          0.240488605940501, 0.237581574431238, 0.23468686187233,
          0.231804410824339, 0.228934165414681, 0.226076071322381,
          0.223230075763918, 0.220396127480152, 0.217574176724331,
          0.214764175251174, 0.211966076307031, 0.209179834621125,
          0.206405406397881, 0.203642749310335, 0.200891822494657,
          0.198152586545776, 0.195425003514135, 0.192709036903589,
          0.190004651670465, 0.187311814223801, 0.1846304924268,
          0.181960655599523, 0.179302274522848, 0.176655321443735,
          0.174019770081839, 0.171395595637506, 0.168782774801212,
          0.166181285764482, 0.163591108232366, 0.161012223437511,
          0.158444614155925, 0.15588826472448, 0.153343161060263,
          0.150809290681846, 0.148286642732575, 0.145775208005994,
          0.143274978973514, 0.140785949814445, 0.138308116448551,
          0.135841476571254, 0.133386029691669, 0.130941777173644, 0.12850872228,
          0.126086870220186, 0.123676228201597, 0.12127680548479,
          0.11888861344291, 0.116511665625611, 0.114145977827839,
          0.111791568163838, 0.109448457146812, 0.107116667774684,
          0.104796225622487, 0.102487158941935, 0.10018949876881,
          0.0979032790388625, 0.095628536713009, 0.093365311912691,
          0.0911136480663738, 0.0888735920682759, 0.0866451944505581,
          0.0844285095703535, 0.082223595813203, 0.0800305158146631,
          0.0778493367020961, 0.0756801303589272, 0.0735229737139814,
          0.0713779490588905, 0.0692451443970068, 0.0671246538277886,
          0.065016577971243, 0.0629210244377582, 0.06083810834954,
          0.0587679529209339, 0.0567106901062031, 0.0546664613248891,
          0.0526354182767924, 0.0506177238609479, 0.0486135532158687,
          0.0466230949019305, 0.0446465522512946, 0.0426841449164746,
          0.0407361106559411, 0.0388027074045262, 0.0368842156885674,
          0.0349809414617162, 0.0330932194585786, 0.0312214171919203,
          0.0293659397581334, 0.0275272356696031, 0.0257058040085489,
          0.0239022033057959, 0.0221170627073089, 0.0203510962300445,
          0.0186051212757247, 0.0168800831525432, 0.0151770883079353,
          0.0134974506017399, 0.0118427578579079, 0.0102149714397015,
          0.00861658276939875, 0.00705087547137324, 0.00552240329925101,
          0.00403797259336304, 0.00260907274610216, 0.0012602859304986,
          0.000477467764609386 };

        double r;
        unsigned int u[2];
        int exitg1;
        int i;
        do {
          exitg1 = 0;
          genrand_uint32_vector(b_state, u);
          i = static_cast<int>((u[1] >> 24U) + 1U);
          r = ((static_cast<double>(u[0] >> 3U) * 1.6777216E+7 + static_cast<
                double>(u[1] & 16777215U)) * 2.2204460492503131E-16 - 1.0) *
            dv[i];
          if (std::abs(r) <= dv[i - 1]) {
            exitg1 = 1;
          } else if (i < 256) {
            // ========================= COPYRIGHT NOTICE ============================
            //  This is a uniform (0,1) pseudorandom number generator based on:
            //
            //  A C-program for MT19937, with initialization improved 2002/1/26.
            //  Coded by Takuji Nishimura and Makoto Matsumoto.
            //
            //  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
            //  All rights reserved.
            //
            //  Redistribution and use in source and binary forms, with or without
            //  modification, are permitted provided that the following conditions
            //  are met:
            //
            //    1. Redistributions of source code must retain the above copyright
            //       notice, this list of conditions and the following disclaimer.
            //
            //    2. Redistributions in binary form must reproduce the above copyright
            //       notice, this list of conditions and the following disclaimer
            //       in the documentation and/or other materials provided with the
            //       distribution.
            //
            //    3. The names of its contributors may not be used to endorse or
            //       promote products derived from this software without specific
            //       prior written permission.
            //
            //  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
            //  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
            //  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
            //  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
            //  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
            //  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
            //  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
            //  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
            //  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
            //  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
            //  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
            //
            // =============================   END   =================================
            do {
              genrand_uint32_vector(b_state, u);
              u[0] >>= 5U;
              u[1] >>= 6U;
            } while ((u[0] == 0U) && (u[1] == 0U));

            if (dv1[i] + 1.1102230246251565E-16 * (static_cast<double>(u[0]) *
                 6.7108864E+7 + static_cast<double>(u[1])) * (dv1[i - 1] - dv1[i])
                < std::exp(-0.5 * r * r)) {
              exitg1 = 1;
            }
          } else {
            double x;
            do {
              // ========================= COPYRIGHT NOTICE ============================
              //  This is a uniform (0,1) pseudorandom number generator based on:
              //
              //  A C-program for MT19937, with initialization improved 2002/1/26.
              //  Coded by Takuji Nishimura and Makoto Matsumoto.
              //
              //  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
              //  All rights reserved.
              //
              //  Redistribution and use in source and binary forms, with or without
              //  modification, are permitted provided that the following conditions
              //  are met:
              //
              //    1. Redistributions of source code must retain the above copyright
              //       notice, this list of conditions and the following disclaimer.
              //
              //    2. Redistributions in binary form must reproduce the above copyright
              //       notice, this list of conditions and the following disclaimer
              //       in the documentation and/or other materials provided with the
              //       distribution.
              //
              //    3. The names of its contributors may not be used to endorse or
              //       promote products derived from this software without specific
              //       prior written permission.
              //
              //  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
              //  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
              //  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
              //  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
              //  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
              //  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
              //  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
              //  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
              //  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
              //  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
              //  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
              //
              // =============================   END   =================================
              do {
                genrand_uint32_vector(b_state, u);
                u[0] >>= 5U;
                u[1] >>= 6U;
              } while ((u[0] == 0U) && (u[1] == 0U));

              x = std::log(1.1102230246251565E-16 * (static_cast<double>(u[0]) *
                6.7108864E+7 + static_cast<double>(u[1]))) * 0.273661237329758;

              // ========================= COPYRIGHT NOTICE ============================
              //  This is a uniform (0,1) pseudorandom number generator based on:
              //
              //  A C-program for MT19937, with initialization improved 2002/1/26.
              //  Coded by Takuji Nishimura and Makoto Matsumoto.
              //
              //  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
              //  All rights reserved.
              //
              //  Redistribution and use in source and binary forms, with or without
              //  modification, are permitted provided that the following conditions
              //  are met:
              //
              //    1. Redistributions of source code must retain the above copyright
              //       notice, this list of conditions and the following disclaimer.
              //
              //    2. Redistributions in binary form must reproduce the above copyright
              //       notice, this list of conditions and the following disclaimer
              //       in the documentation and/or other materials provided with the
              //       distribution.
              //
              //    3. The names of its contributors may not be used to endorse or
              //       promote products derived from this software without specific
              //       prior written permission.
              //
              //  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
              //  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
              //  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
              //  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
              //  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
              //  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
              //  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
              //  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
              //  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
              //  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
              //  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
              //
              // =============================   END   =================================
              do {
                genrand_uint32_vector(b_state, u);
                u[0] >>= 5U;
                u[1] >>= 6U;
              } while ((u[0] == 0U) && (u[1] == 0U));
            } while (!(-2.0 * std::log(1.1102230246251565E-16 * (static_cast<
                        double>(u[0]) * 6.7108864E+7 + static_cast<double>(u[1])))
                       > x * x));

            if (r < 0.0) {
              r = x - 3.65415288536101;
            } else {
              r = 3.65415288536101 - x;
            }

            exitg1 = 1;
          }
        } while (exitg1 == 0);

        return r;
      }

      //
      // Arguments    : unsigned int b_state[625]
      // Return Type  : void
      //
      static void eml_rand_mt19937ar(unsigned int b_state[625])
      {
        unsigned int r;
        r = 5489U;
        b_state[0] = 5489U;
        for (int mti{0}; mti < 623; mti++) {
          r = ((r ^ r >> 30U) * 1812433253U + static_cast<unsigned int>(mti)) +
            1U;
          b_state[mti + 1] = r;
        }

        b_state[624] = 624U;
      }

      //
      // Arguments    : unsigned int mt[625]
      //                unsigned int u[2]
      // Return Type  : void
      //
      static void genrand_uint32_vector(unsigned int mt[625], unsigned int u[2])
      {
        for (int j{0}; j < 2; j++) {
          unsigned int mti;
          unsigned int y;
          mti = mt[624] + 1U;
          if (mti >= 625U) {
            for (int kk{0}; kk < 227; kk++) {
              y = (mt[kk] & 2147483648U) | (mt[kk + 1] & 2147483647U);
              if ((y & 1U) == 0U) {
                y >>= 1U;
              } else {
                y = y >> 1U ^ 2567483615U;
              }

              mt[kk] = mt[kk + 397] ^ y;
            }

            for (int kk{0}; kk < 396; kk++) {
              y = (mt[kk + 227] & 2147483648U) | (mt[kk + 228] & 2147483647U);
              if ((y & 1U) == 0U) {
                y >>= 1U;
              } else {
                y = y >> 1U ^ 2567483615U;
              }

              mt[kk + 227] = mt[kk] ^ y;
            }

            y = (mt[623] & 2147483648U) | (mt[0] & 2147483647U);
            if ((y & 1U) == 0U) {
              y >>= 1U;
            } else {
              y = y >> 1U ^ 2567483615U;
            }

            mt[623] = mt[396] ^ y;
            mti = 1U;
          }

          y = mt[static_cast<int>(mti) - 1];
          mt[624] = mti;
          y ^= y >> 11U;
          y ^= y << 7U & 2636928640U;
          y ^= y << 15U & 4022730752U;
          u[j] = y ^ y >> 18U;
        }
      }

      //
      // Arguments    : int n
      //                double z[16]
      //                int iz0
      //                const double cs[6]
      //                int ic0
      //                int is0
      // Return Type  : void
      //
    }

    namespace reflapack
    {
      static void b_rotateRight(int n, double z[16], int iz0, const double cs[6],
        int ic0, int is0)
      {
        for (int j{0}; j <= n - 2; j++) {
          double ctemp;
          double stemp;
          int offsetj;
          int offsetjp1;
          ctemp = cs[(ic0 + j) - 1];
          stemp = cs[(is0 + j) - 1];
          offsetj = ((j << 2) + iz0) - 2;
          offsetjp1 = (((j + 1) << 2) + iz0) - 2;
          if ((ctemp != 1.0) || (stemp != 0.0)) {
            double d;
            double temp;
            temp = z[offsetjp1 + 1];
            d = z[offsetj + 1];
            z[offsetjp1 + 1] = ctemp * temp - stemp * d;
            d = stemp * temp + ctemp * d;
            z[offsetj + 1] = d;
            temp = z[offsetjp1 + 2];
            d = z[offsetj + 2];
            z[offsetjp1 + 2] = ctemp * temp - stemp * d;
            d = stemp * temp + ctemp * d;
            z[offsetj + 2] = d;
            temp = z[offsetjp1 + 3];
            d = z[offsetj + 3];
            z[offsetjp1 + 3] = ctemp * temp - stemp * d;
            d = stemp * temp + ctemp * d;
            z[offsetj + 3] = d;
            temp = z[offsetjp1 + 4];
            d = z[offsetj + 4];
            z[offsetjp1 + 4] = ctemp * temp - stemp * d;
            d = stemp * temp + ctemp * d;
            z[offsetj + 4] = d;
          }
        }
      }

      //
      // Arguments    : double cfrom
      //                double cto
      //                double A[9]
      // Return Type  : void
      //
      static void b_xzlascl(double cfrom, double cto, double A[9])
      {
        double cfromc;
        double ctoc;
        bool notdone;
        cfromc = cfrom;
        ctoc = cto;
        notdone = true;
        while (notdone) {
          double cfrom1;
          double cto1;
          double mul;
          cfrom1 = cfromc * 2.0041683600089728E-292;
          cto1 = ctoc / 4.9896007738368E+291;
          if ((std::abs(cfrom1) > std::abs(ctoc)) && (ctoc != 0.0)) {
            mul = 2.0041683600089728E-292;
            cfromc = cfrom1;
          } else if (std::abs(cto1) > std::abs(cfromc)) {
            mul = 4.9896007738368E+291;
            ctoc = cto1;
          } else {
            mul = ctoc / cfromc;
            notdone = false;
          }

          for (int j{0}; j < 3; j++) {
            int offset;
            offset = j * 3 - 1;
            A[offset + 1] *= mul;
            A[offset + 2] *= mul;
            A[offset + 3] *= mul;
          }
        }
      }

      //
      // Arguments    : double cfrom
      //                double cto
      //                int m
      //                double A[3]
      //                int iA0
      // Return Type  : void
      //
      static void b_xzlascl(double cfrom, double cto, int m, double A[3], int
                            iA0)
      {
        double cfromc;
        double ctoc;
        bool notdone;
        cfromc = cfrom;
        ctoc = cto;
        notdone = true;
        while (notdone) {
          double cfrom1;
          double cto1;
          double mul;
          cfrom1 = cfromc * 2.0041683600089728E-292;
          cto1 = ctoc / 4.9896007738368E+291;
          if ((std::abs(cfrom1) > std::abs(ctoc)) && (ctoc != 0.0)) {
            mul = 2.0041683600089728E-292;
            cfromc = cfrom1;
          } else if (std::abs(cto1) > std::abs(cfromc)) {
            mul = 4.9896007738368E+291;
            ctoc = cto1;
          } else {
            mul = ctoc / cfromc;
            notdone = false;
          }

          for (int i{0}; i < m; i++) {
            int b_i;
            b_i = (iA0 + i) - 1;
            A[b_i] *= mul;
          }
        }
      }

      //
      // Arguments    : int n
      //                double z[16]
      //                int iz0
      //                const double cs[6]
      //                int ic0
      //                int is0
      // Return Type  : void
      //
      static void rotateRight(int n, double z[16], int iz0, const double cs[6],
        int ic0, int is0)
      {
        int i;
        i = n - 1;
        for (int j{i}; j >= 1; j--) {
          double ctemp;
          double stemp;
          int offsetj;
          int offsetjp1;
          ctemp = cs[(ic0 + j) - 2];
          stemp = cs[(is0 + j) - 2];
          offsetj = (((j - 1) << 2) + iz0) - 2;
          offsetjp1 = ((j << 2) + iz0) - 2;
          if ((ctemp != 1.0) || (stemp != 0.0)) {
            double d;
            double temp;
            temp = z[offsetjp1 + 1];
            d = z[offsetj + 1];
            z[offsetjp1 + 1] = ctemp * temp - stemp * d;
            d = stemp * temp + ctemp * d;
            z[offsetj + 1] = d;
            temp = z[offsetjp1 + 2];
            d = z[offsetj + 2];
            z[offsetjp1 + 2] = ctemp * temp - stemp * d;
            d = stemp * temp + ctemp * d;
            z[offsetj + 2] = d;
            temp = z[offsetjp1 + 3];
            d = z[offsetj + 3];
            z[offsetjp1 + 3] = ctemp * temp - stemp * d;
            d = stemp * temp + ctemp * d;
            z[offsetj + 3] = d;
            temp = z[offsetjp1 + 4];
            d = z[offsetj + 4];
            z[offsetjp1 + 4] = ctemp * temp - stemp * d;
            d = stemp * temp + ctemp * d;
            z[offsetj + 4] = d;
          }
        }
      }

      //
      // Arguments    : double a
      //                double b
      //                double c
      //                double d
      //                double &q
      // Return Type  : double
      //
      static double xdladiv(double a, double b, double c, double d, double &q)
      {
        double aa;
        double ab;
        double bb;
        double cc;
        double cd;
        double cd_tmp;
        double dd;
        double p;
        double r;
        double s;
        aa = a;
        bb = b;
        cc = c;
        dd = d;
        ab = std::fmax(std::abs(a), std::abs(b));
        cd_tmp = std::abs(d);
        r = std::abs(c);
        cd = std::fmax(r, cd_tmp);
        s = 1.0;
        if (ab >= 8.9884656743115785E+307) {
          aa = 0.5 * a;
          bb = 0.5 * b;
          s = 2.0;
        }

        if (cd >= 8.9884656743115785E+307) {
          cc = 0.5 * c;
          dd = 0.5 * d;
          s *= 0.5;
        }

        if (ab <= 2.0041683600089728E-292) {
          aa *= 4.0564819207303341E+31;
          bb *= 4.0564819207303341E+31;
          s /= 4.0564819207303341E+31;
        }

        if (cd <= 2.0041683600089728E-292) {
          cc *= 4.0564819207303341E+31;
          dd *= 4.0564819207303341E+31;
          s *= 4.0564819207303341E+31;
        }

        if (cd_tmp <= r) {
          r = dd / cc;
          cd = 1.0 / (cc + dd * r);
          if (r != 0.0) {
            ab = bb * r;
            cd_tmp = bb * cd;
            if (ab != 0.0) {
              p = (aa + ab) * cd;
            } else {
              p = aa * cd + cd_tmp * r;
            }

            ab = -aa * r;
            if (ab != 0.0) {
              q = (bb + ab) * cd;
            } else {
              q = cd_tmp + -aa * cd * r;
            }
          } else {
            p = (aa + dd * (bb / cc)) * cd;
            q = (bb + dd * (-aa / cc)) * cd;
          }
        } else {
          r = cc / dd;
          cd = 1.0 / (dd + cc * r);
          if (r != 0.0) {
            ab = aa * r;
            cd_tmp = aa * cd;
            if (ab != 0.0) {
              p = (bb + ab) * cd;
            } else {
              p = bb * cd + cd_tmp * r;
            }

            ab = -bb * r;
            if (ab != 0.0) {
              q = (aa + ab) * cd;
            } else {
              q = cd_tmp + -bb * cd * r;
            }
          } else {
            p = (bb + cc * (aa / dd)) * cd;
            q = (aa + cc * (-bb / dd)) * cd;
          }

          q = -q;
        }

        p *= s;
        q *= s;
        return p;
      }

      //
      // Arguments    : double a
      //                double b
      //                double c
      //                double &rt2
      //                double &cs1
      //                double &sn1
      // Return Type  : double
      //
      static double xdlaev2(double a, double b, double c, double &rt2, double
                            &cs1, double &sn1)
      {
        double ab;
        double acmn;
        double acmx;
        double adf;
        double df;
        double rt1;
        double tb;
        int sgn1;
        int sgn2;
        rt1 = a + c;
        df = a - c;
        adf = std::abs(df);
        tb = b + b;
        ab = std::abs(tb);
        if (std::abs(a) > std::abs(c)) {
          acmx = a;
          acmn = c;
        } else {
          acmx = c;
          acmn = a;
        }

        if (adf > ab) {
          double b_a;
          b_a = ab / adf;
          adf *= std::sqrt(b_a * b_a + 1.0);
        } else if (adf < ab) {
          double b_a;
          b_a = adf / ab;
          adf = ab * std::sqrt(b_a * b_a + 1.0);
        } else {
          adf = ab * 1.4142135623730951;
        }

        if (rt1 < 0.0) {
          rt1 = 0.5 * (rt1 - adf);
          sgn1 = -1;
          rt2 = acmx / rt1 * acmn - b / rt1 * b;
        } else if (rt1 > 0.0) {
          rt1 = 0.5 * (rt1 + adf);
          sgn1 = 1;
          rt2 = acmx / rt1 * acmn - b / rt1 * b;
        } else {
          rt1 = 0.5 * adf;
          rt2 = -0.5 * adf;
          sgn1 = 1;
        }

        if (df >= 0.0) {
          adf += df;
          sgn2 = 1;
        } else {
          adf = df - adf;
          sgn2 = -1;
        }

        if (std::abs(adf) > ab) {
          adf = -tb / adf;
          sn1 = 1.0 / std::sqrt(adf * adf + 1.0);
          cs1 = adf * sn1;
        } else if (ab == 0.0) {
          cs1 = 1.0;
          sn1 = 0.0;
        } else {
          adf = -adf / tb;
          cs1 = 1.0 / std::sqrt(adf * adf + 1.0);
          sn1 = adf * cs1;
        }

        if (sgn1 == sgn2) {
          adf = cs1;
          cs1 = -sn1;
          sn1 = adf;
        }

        return rt1;
      }

      //
      // Arguments    : int ilo
      //                int ihi
      //                double h[16]
      //                int iloz
      //                int ihiz
      //                double z[16]
      //                double wr[4]
      //                double wi[4]
      // Return Type  : int
      //
      static int xdlahqr(int ilo, int ihi, double h[16], int iloz, int ihiz,
                         double z[16], double wr[4], double wi[4])
      {
        double d;
        double d1;
        double h12;
        double h22;
        double rt1r;
        double rt2r;
        double s;
        double tst;
        int b_i;
        int i;
        int info;
        info = 0;
        i = static_cast<unsigned char>(ilo - 1);
        for (b_i = 0; b_i < i; b_i++) {
          wr[b_i] = h[b_i + (b_i << 2)];
          wi[b_i] = 0.0;
        }

        i = ihi + 1;
        for (b_i = i; b_i < 5; b_i++) {
          wr[b_i - 1] = h[(b_i + ((b_i - 1) << 2)) - 1];
          wi[b_i - 1] = 0.0;
        }

        if (ilo == ihi) {
          wr[ilo - 1] = h[(ilo + ((ilo - 1) << 2)) - 1];
          wi[ilo - 1] = 0.0;
        } else {
          double smlnum;
          int j;
          int kdefl;
          int nz;
          bool exitg1;
          i = ihi - 3;
          for (j = ilo; j <= i; j++) {
            h[2] = 0.0;
            h[3] = 0.0;
          }

          if (ilo <= ihi - 2) {
            h[(ihi + ((ihi - 3) << 2)) - 1] = 0.0;
          }

          nz = (ihiz - iloz) + 1;
          smlnum = 2.2250738585072014E-308 * (static_cast<double>((ihi - ilo) +
            1) / 2.2204460492503131E-16);
          kdefl = 0;
          b_i = ihi - 1;
          exitg1 = false;
          while ((!exitg1) && (b_i + 1 >= ilo)) {
            double aa;
            int b_k;
            int i1;
            int i2;
            int its;
            int ix;
            int k;
            int l;
            int nr;
            bool converged;
            bool exitg2;
            l = ilo;
            converged = false;
            its = 0;
            exitg2 = false;
            while ((!exitg2) && (its < 301)) {
              double tr;
              bool exitg3;
              k = b_i;
              exitg3 = false;
              while ((!exitg3) && (k + 1 > l)) {
                i = k + ((k - 1) << 2);
                d = std::abs(h[i]);
                if (d <= smlnum) {
                  exitg3 = true;
                } else {
                  ix = k + (k << 2);
                  h12 = std::abs(h[ix]);
                  aa = h[i - 1];
                  tst = std::abs(aa) + h12;
                  if (tst == 0.0) {
                    if (k - 1 >= ilo) {
                      tst = std::abs(h[(k + ((k - 2) << 2)) - 1]);
                    }

                    if (k + 2 <= ihi) {
                      tst += std::abs(h[ix + 1]);
                    }
                  }

                  if (d <= 2.2204460492503131E-16 * tst) {
                    tr = std::abs(h[ix - 1]);
                    tst = std::abs(aa - h[ix]);
                    aa = std::fmax(h12, tst);
                    tst = std::fmin(h12, tst);
                    s = aa + tst;
                    if (std::fmin(d, tr) * (std::fmax(d, tr) / s) <= std::fmax
                        (smlnum, 2.2204460492503131E-16 * (tst * (aa / s)))) {
                      exitg3 = true;
                    } else {
                      k--;
                    }
                  } else {
                    k--;
                  }
                }
              }

              l = k + 1;
              if (k + 1 > ilo) {
                h[k + ((k - 1) << 2)] = 0.0;
              }

              if (k + 1 >= b_i) {
                converged = true;
                exitg2 = true;
              } else {
                double v[3];
                int m;
                kdefl++;
                if (kdefl - kdefl / 20 * 20 == 0) {
                  s = std::abs(h[b_i + ((b_i - 1) << 2)]) + std::abs(h[(b_i +
                    ((b_i - 2) << 2)) - 1]);
                  tst = 0.75 * s + h[b_i + (b_i << 2)];
                  h12 = -0.4375 * s;
                  aa = s;
                  h22 = tst;
                } else if (kdefl - kdefl / 10 * 10 == 0) {
                  ix = k + (k << 2);
                  s = std::abs(h[ix + 1]) + std::abs(h[(k + ((k + 1) << 2)) + 2]);
                  tst = 0.75 * s + h[ix];
                  h12 = -0.4375 * s;
                  aa = s;
                  h22 = tst;
                } else {
                  ix = b_i + ((b_i - 1) << 2);
                  tst = h[ix - 1];
                  aa = h[ix];
                  ix = b_i + (b_i << 2);
                  h12 = h[ix - 1];
                  h22 = h[ix];
                }

                s = ((std::abs(tst) + std::abs(h12)) + std::abs(aa)) + std::abs
                  (h22);
                if (s == 0.0) {
                  rt1r = 0.0;
                  tst = 0.0;
                  rt2r = 0.0;
                  h12 = 0.0;
                } else {
                  tst /= s;
                  aa /= s;
                  h12 /= s;
                  h22 /= s;
                  tr = (tst + h22) / 2.0;
                  tst = (tst - tr) * (h22 - tr) - h12 * aa;
                  h12 = std::sqrt(std::abs(tst));
                  if (tst >= 0.0) {
                    rt1r = tr * s;
                    rt2r = rt1r;
                    tst = h12 * s;
                    h12 = -tst;
                  } else {
                    rt1r = tr + h12;
                    rt2r = tr - h12;
                    if (std::abs(rt1r - h22) <= std::abs(rt2r - h22)) {
                      rt1r *= s;
                      rt2r = rt1r;
                    } else {
                      rt2r *= s;
                      rt1r = rt2r;
                    }

                    tst = 0.0;
                    h12 = 0.0;
                  }
                }

                m = b_i - 1;
                exitg3 = false;
                while ((!exitg3) && (m >= k + 1)) {
                  ix = m + ((m - 1) << 2);
                  aa = h[ix - 1];
                  tr = aa - rt2r;
                  s = (std::abs(tr) + std::abs(h12)) + std::abs(h[ix]);
                  h22 = h[ix] / s;
                  nr = m + (m << 2);
                  v[0] = (h22 * h[nr - 1] + tr * (tr / s)) - tst * (h12 / s);
                  v[1] = h22 * (((aa + h[nr]) - rt1r) - rt2r);
                  v[2] = h22 * h[nr + 1];
                  s = (std::abs(v[0]) + std::abs(v[1])) + std::abs(v[2]);
                  v[0] /= s;
                  v[1] /= s;
                  v[2] /= s;
                  if ((m == k + 1) || (std::abs(h[m - 1]) * (std::abs(v[1]) +
                        std::abs(v[2])) <= 2.2204460492503131E-16 * std::abs(v[0])
                                       * ((std::abs(h[0]) + std::abs(h[ix - 1]))
                        + std::abs(h[nr])))) {
                    exitg3 = true;
                  } else {
                    m--;
                  }
                }

                for (int c_k{m}; c_k <= b_i; c_k++) {
                  ix = (b_i - c_k) + 2;
                  if (ix >= 3) {
                    nr = 3;
                  } else {
                    nr = ix;
                  }

                  if (c_k > m) {
                    ix = (((c_k - 2) << 2) + c_k) - 1;
                    for (b_k = 0; b_k < nr; b_k++) {
                      v[b_k] = h[ix + b_k];
                    }
                  }

                  tst = v[0];
                  tr = xzlarfg(nr, tst, v);
                  if (c_k > m) {
                    i = c_k + ((c_k - 2) << 2);
                    h[i - 1] = tst;
                    h[i] = 0.0;
                    if (c_k < b_i) {
                      h[c_k + 1] = 0.0;
                    }
                  } else if (m > k + 1) {
                    h[c_k - 1] *= 1.0 - tr;
                  }

                  d = v[1];
                  tst = tr * v[1];
                  if (nr == 3) {
                    rt2r = v[2];
                    aa = tr * v[2];
                    for (j = c_k; j < 5; j++) {
                      i = c_k + ((j - 1) << 2);
                      rt1r = h[i - 1];
                      s = h[i];
                      d1 = h[i + 1];
                      h12 = (rt1r + d * s) + rt2r * d1;
                      rt1r -= h12 * tr;
                      h[i - 1] = rt1r;
                      s -= h12 * tst;
                      h[i] = s;
                      d1 -= h12 * aa;
                      h[i + 1] = d1;
                    }

                    if (c_k + 3 <= b_i + 1) {
                      i = c_k;
                    } else {
                      i = b_i - 2;
                    }

                    i = static_cast<unsigned char>(i + 3);
                    for (j = 0; j < i; j++) {
                      i1 = j + ((c_k - 1) << 2);
                      rt1r = h[i1];
                      i2 = j + (c_k << 2);
                      s = h[i2];
                      ix = j + ((c_k + 1) << 2);
                      d1 = h[ix];
                      h12 = (rt1r + d * s) + rt2r * d1;
                      rt1r -= h12 * tr;
                      h[i1] = rt1r;
                      s -= h12 * tst;
                      h[i2] = s;
                      d1 -= h12 * aa;
                      h[ix] = d1;
                    }

                    for (j = iloz; j <= ihiz; j++) {
                      i = (j + ((c_k - 1) << 2)) - 1;
                      rt1r = z[i];
                      i1 = (j + (c_k << 2)) - 1;
                      s = z[i1];
                      i2 = (j + ((c_k + 1) << 2)) - 1;
                      d1 = z[i2];
                      h12 = (rt1r + d * s) + rt2r * d1;
                      rt1r -= h12 * tr;
                      z[i] = rt1r;
                      s -= h12 * tst;
                      z[i1] = s;
                      d1 -= h12 * aa;
                      z[i2] = d1;
                    }
                  } else if (nr == 2) {
                    for (j = c_k; j < 5; j++) {
                      i = c_k + ((j - 1) << 2);
                      rt2r = h[i - 1];
                      rt1r = h[i];
                      h12 = rt2r + d * rt1r;
                      rt2r -= h12 * tr;
                      h[i - 1] = rt2r;
                      rt1r -= h12 * tst;
                      h[i] = rt1r;
                    }

                    i = static_cast<unsigned char>(b_i + 1);
                    for (j = 0; j < i; j++) {
                      i1 = j + ((c_k - 1) << 2);
                      rt2r = h[i1];
                      i2 = j + (c_k << 2);
                      rt1r = h[i2];
                      h12 = rt2r + d * rt1r;
                      rt2r -= h12 * tr;
                      h[i1] = rt2r;
                      rt1r -= h12 * tst;
                      h[i2] = rt1r;
                    }

                    for (j = iloz; j <= ihiz; j++) {
                      i = (j + ((c_k - 1) << 2)) - 1;
                      rt2r = z[i];
                      i1 = (j + (c_k << 2)) - 1;
                      rt1r = z[i1];
                      h12 = rt2r + d * rt1r;
                      rt2r -= h12 * tr;
                      z[i] = rt2r;
                      rt1r -= h12 * tst;
                      z[i1] = rt1r;
                    }
                  }
                }

                its++;
              }
            }

            if (!converged) {
              info = b_i + 1;
              exitg1 = true;
            } else {
              if (l == b_i + 1) {
                wr[b_i] = h[b_i + (b_i << 2)];
                wi[b_i] = 0.0;
              } else if (l == b_i) {
                i = b_i << 2;
                i1 = b_i + i;
                d = h[i1 - 1];
                i2 = (b_i - 1) << 2;
                ix = b_i + i2;
                rt2r = h[ix];
                rt1r = h[i1];
                wr[b_i - 1] = xdlanv2(h[ix - 1], d, rt2r, rt1r, wi[b_i - 1], s,
                                      d1, h12, h22);
                wr[b_i] = s;
                wi[b_i] = d1;
                h[i1 - 1] = d;
                h[ix] = rt2r;
                h[i1] = rt1r;
                if (b_i + 1 < 4) {
                  ix = ((b_i + 1) << 2) + b_i;
                  i1 = static_cast<unsigned char>(3 - b_i);
                  for (k = 0; k < i1; k++) {
                    nr = ix + (k << 2);
                    tst = h[nr];
                    aa = h[nr - 1];
                    h[nr] = h12 * tst - h22 * aa;
                    h[nr - 1] = h12 * aa + h22 * tst;
                  }
                }

                if (b_i - 1 >= 1) {
                  i1 = static_cast<unsigned char>(b_i - 1);
                  for (k = 0; k < i1; k++) {
                    b_k = i + k;
                    tst = h[b_k];
                    j = i2 + k;
                    aa = h[j];
                    h[b_k] = h12 * tst - h22 * aa;
                    h[j] = h12 * aa + h22 * tst;
                  }
                }

                if (nz >= 1) {
                  ix = (i2 + iloz) - 1;
                  nr = (i + iloz) - 1;
                  i = static_cast<unsigned char>(nz);
                  for (k = 0; k < i; k++) {
                    b_k = nr + k;
                    tst = z[b_k];
                    j = ix + k;
                    aa = z[j];
                    z[b_k] = h12 * tst - h22 * aa;
                    z[j] = h12 * aa + h22 * tst;
                  }
                }
              }

              kdefl = 0;
              b_i = l - 2;
            }
          }

          for (j = 0; j < 2; j++) {
            for (b_i = j + 3; b_i < 5; b_i++) {
              h[(b_i + (j << 2)) - 1] = 0.0;
            }
          }
        }

        return info;
      }

      //
      // Arguments    : int na
      //                int nw
      //                double smin
      //                const double A[16]
      //                int ia0
      //                const double B[12]
      //                int ib0
      //                double wr
      //                double wi
      //                double X[4]
      //                double &xnorm
      // Return Type  : double
      //
      static double xdlaln2(int na, int nw, double smin, const double A[16], int
                            ia0, const double B[12], int ib0, double wr, double
                            wi, double X[4], double &xnorm)
      {
        static const signed char ipivot[16]{ 1, 2, 3, 4, 2, 1, 4, 3, 3, 4, 1, 2,
          4, 3, 2, 1 };

        double scale;
        scale = 1.0;
        if (na == 1) {
          if (nw == 1) {
            double cr21;
            double cr22;
            double lr21;
            double ui12;
            cr21 = A[ia0 - 1] - wr;
            ui12 = std::abs(cr21);
            if (ui12 < smin) {
              cr21 = smin;
              ui12 = smin;
            }

            cr22 = B[ib0 - 1];
            lr21 = std::abs(cr22);
            if ((ui12 < 1.0) && (lr21 > 1.0) && (lr21 > 2.2471164185778949E+307 *
                 ui12)) {
              scale = 1.0 / lr21;
            }

            X[0] = cr22 * scale / cr21;
            xnorm = std::abs(X[0]);
          } else {
            double cr21;
            double cr22;
            double lr21;
            double temp;
            double ui12;
            double ur12;
            cr21 = A[ia0 - 1] - wr;
            temp = -wi;
            ui12 = std::abs(cr21) + std::abs(-wi);
            if (ui12 < smin) {
              cr21 = smin;
              temp = 0.0;
              ui12 = smin;
            }

            cr22 = B[ib0 - 1];
            ur12 = B[ib0 + 3];
            lr21 = std::abs(cr22) + std::abs(ur12);
            if ((ui12 < 1.0) && (lr21 > 1.0) && (lr21 > 2.2471164185778949E+307 *
                 ui12)) {
              scale = 1.0 / lr21;
            }

            X[0] = xdladiv(scale * cr22, scale * ur12, cr21, temp, X[2]);
            xnorm = std::abs(X[0]) + std::abs(X[2]);
          }
        } else {
          double cr[4];
          cr[0] = A[ia0 - 1] - wr;
          cr[3] = A[ia0 + 4] - wr;
          cr[1] = A[ia0];
          cr[2] = A[ia0 + 3];
          if (nw == 1) {
            double cmax;
            double cr21;
            int icmax;
            cmax = 0.0;
            icmax = -1;
            cr21 = std::abs(cr[0]);
            if (cr21 > 0.0) {
              cmax = cr21;
              icmax = 0;
            }

            cr21 = std::abs(cr[1]);
            if (cr21 > cmax) {
              cmax = cr21;
              icmax = 1;
            }

            cr21 = std::abs(cr[2]);
            if (cr21 > cmax) {
              cmax = cr21;
              icmax = 2;
            }

            cr21 = std::abs(cr[3]);
            if (cr21 > cmax) {
              cmax = cr21;
              icmax = 3;
            }

            if (cmax < smin) {
              double cr22;
              double lr21;
              double temp;
              cr22 = B[ib0 - 1];
              lr21 = std::fmax(std::abs(cr22), std::abs(B[ib0]));
              if ((smin < 1.0) && (lr21 > 1.0) && (lr21 >
                   2.2471164185778949E+307 * smin)) {
                scale = 1.0 / lr21;
              }

              temp = scale / smin;
              X[0] = temp * cr22;
              X[1] = temp * B[ib0];
              xnorm = temp * lr21;
            } else {
              double br1;
              double cr22;
              double lr21;
              double temp;
              double ur11r;
              double ur12;
              double ur22;
              int ur12_tmp;
              ur12_tmp = icmax << 2;
              ur12 = cr[ipivot[ur12_tmp + 2] - 1];
              ur11r = 1.0 / cr[icmax];
              lr21 = ur11r * cr[ipivot[ur12_tmp + 1] - 1];
              ur22 = cr[ipivot[ur12_tmp + 3] - 1] - ur12 * lr21;
              if (std::abs(ur22) < smin) {
                ur22 = smin;
              }

              if ((icmax + 1 == 2) || (icmax + 1 == 4)) {
                br1 = B[ib0];
                cr22 = B[ib0 - 1];
              } else {
                br1 = B[ib0 - 1];
                cr22 = B[ib0];
              }

              cr22 -= lr21 * br1;
              lr21 = std::fmax(std::abs(br1 * (ur22 * ur11r)), std::abs(cr22));
              if (lr21 > 1.0) {
                cr21 = std::abs(ur22);
                if ((cr21 < 1.0) && (lr21 >= 2.2471164185778949E+307 * cr21)) {
                  scale = 1.0 / lr21;
                }
              }

              cr22 = cr22 * scale / ur22;
              temp = scale * br1 * ur11r - cr22 * (ur11r * ur12);
              if ((icmax + 1 == 3) || (icmax + 1 == 4)) {
                X[0] = cr22;
                X[1] = temp;
              } else {
                X[0] = temp;
                X[1] = cr22;
              }

              xnorm = std::fmax(std::abs(temp), std::abs(cr22));
              if ((xnorm > 1.0) && (cmax > 1.0) && (xnorm >
                   2.2471164185778949E+307 / cmax)) {
                temp = cmax / 2.2471164185778949E+307;
                X[0] *= temp;
                X[1] *= temp;
                xnorm *= temp;
                scale *= temp;
              }
            }
          } else {
            double ci[4];
            double cmax;
            double cr21;
            double temp;
            int icmax;
            ci[0] = -wi;
            ci[1] = 0.0;
            ci[2] = 0.0;
            ci[3] = -wi;
            cmax = 0.0;
            icmax = -1;
            cr21 = std::abs(-wi);
            temp = std::abs(cr[0]) + cr21;
            if (temp > 0.0) {
              cmax = temp;
              icmax = 0;
            }

            temp = std::abs(cr[1]);
            if (temp > cmax) {
              cmax = temp;
              icmax = 1;
            }

            temp = std::abs(cr[2]);
            if (temp > cmax) {
              cmax = temp;
              icmax = 2;
            }

            temp = std::abs(cr[3]) + cr21;
            if (temp > cmax) {
              cmax = temp;
              icmax = 3;
            }

            if (cmax < smin) {
              double cr22;
              double lr21;
              double ur12;
              cr22 = B[ib0 - 1];
              ur12 = B[ib0 + 3];
              cr21 = B[ib0 + 4];
              lr21 = std::fmax(std::abs(cr22) + std::abs(ur12), std::abs(B[ib0])
                               + std::abs(cr21));
              if ((smin < 1.0) && (lr21 > 1.0) && (lr21 >
                   2.2471164185778949E+307 * smin)) {
                scale = 1.0 / lr21;
              }

              temp = scale / smin;
              X[0] = temp * cr22;
              X[1] = temp * B[ib0];
              X[2] = temp * ur12;
              X[3] = temp * cr21;
              xnorm = temp * lr21;
            } else {
              double bi1;
              double br1;
              double cr22;
              double lr21;
              double ui11r;
              double ui12;
              double ui12s;
              double ur11r;
              double ur12;
              double ur12s;
              double ur22;
              int b_cr21_tmp;
              int cr21_tmp;
              int ur12_tmp;
              cr21_tmp = icmax << 2;
              b_cr21_tmp = ipivot[cr21_tmp + 1] - 1;
              cr21 = cr[b_cr21_tmp];
              ur12_tmp = ipivot[cr21_tmp + 2] - 1;
              ur12 = cr[ur12_tmp];
              ui12 = ci[ur12_tmp];
              cr21_tmp = ipivot[cr21_tmp + 3] - 1;
              cr22 = cr[cr21_tmp];
              if ((icmax + 1 == 1) || (icmax + 1 == 4)) {
                if (std::abs(cr[icmax]) > std::abs(ci[icmax])) {
                  temp = ci[icmax] / cr[icmax];
                  ur11r = 1.0 / (cr[icmax] * (temp * temp + 1.0));
                  ui11r = -temp * ur11r;
                } else {
                  temp = cr[icmax] / ci[icmax];
                  ui11r = -1.0 / (ci[icmax] * (temp * temp + 1.0));
                  ur11r = -temp * ui11r;
                }

                lr21 = cr21 * ur11r;
                cr21 *= ui11r;
                ur12s = ur12 * ur11r;
                ui12s = ur12 * ui11r;
                ur22 = cr22 - ur12 * lr21;
                temp = ci[cr21_tmp] - ur12 * cr21;
              } else {
                ur11r = 1.0 / cr[icmax];
                ui11r = 0.0;
                lr21 = cr21 * ur11r;
                cr21 = ci[b_cr21_tmp] * ur11r;
                ur12s = ur12 * ur11r;
                ui12s = ui12 * ur11r;
                ur22 = (cr22 - ur12 * lr21) + ui12 * cr21;
                temp = -ur12 * cr21 - ui12 * lr21;
              }

              ur12 = std::abs(ur22) + std::abs(temp);
              if (ur12 < smin) {
                ur22 = smin;
                temp = 0.0;
              }

              if ((icmax + 1 == 2) || (icmax + 1 == 4)) {
                cr22 = B[ib0 - 1];
                br1 = B[ib0];
                ui12 = B[ib0 + 3];
                bi1 = B[ib0 + 4];
              } else {
                br1 = B[ib0 - 1];
                cr22 = B[ib0];
                bi1 = B[ib0 + 3];
                ui12 = B[ib0 + 4];
              }

              cr22 = (cr22 - lr21 * br1) + cr21 * bi1;
              ui12 = (ui12 - cr21 * br1) - lr21 * bi1;
              lr21 = std::fmax((std::abs(br1) + std::abs(bi1)) * (ur12 * (std::
                abs(ur11r) + std::abs(ui11r))), std::abs(cr22) + std::abs(ui12));
              if ((lr21 > 1.0) && (ur12 < 1.0) && (lr21 >=
                   2.2471164185778949E+307 * ur12)) {
                scale = 1.0 / lr21;
                br1 *= scale;
                bi1 *= scale;
                cr22 *= scale;
                ui12 *= scale;
              }

              cr22 = xdladiv(cr22, ui12, ur22, temp, ui12);
              temp = ((ur11r * br1 - ui11r * bi1) - ur12s * cr22) + ui12s * ui12;
              cr21 = ((ui11r * br1 + ur11r * bi1) - ui12s * cr22) - ur12s * ui12;
              if ((icmax + 1 == 3) || (icmax + 1 == 4)) {
                X[0] = cr22;
                X[1] = temp;
                X[2] = ui12;
                X[3] = cr21;
              } else {
                X[0] = temp;
                X[1] = cr22;
                X[2] = cr21;
                X[3] = ui12;
              }

              xnorm = std::fmax(std::abs(temp) + std::abs(cr21), std::abs(cr22)
                                + std::abs(ui12));
              if ((xnorm > 1.0) && (cmax > 1.0) && (xnorm >
                   2.2471164185778949E+307 / cmax)) {
                temp = cmax / 2.2471164185778949E+307;
                X[0] *= temp;
                X[1] *= temp;
                X[2] *= temp;
                X[3] *= temp;
                xnorm *= temp;
                scale *= temp;
              }
            }
          }
        }

        return scale;
      }

      //
      // Arguments    : double &a
      //                double &b
      //                double &c
      //                double &d
      //                double &rt1i
      //                double &rt2r
      //                double &rt2i
      //                double &cs
      //                double &sn
      // Return Type  : double
      //
      static double xdlanv2(double &a, double &b, double &c, double &d, double
                            &rt1i, double &rt2r, double &rt2i, double &cs,
                            double &sn)
      {
        double rt1r;
        if (c == 0.0) {
          cs = 1.0;
          sn = 0.0;
        } else if (b == 0.0) {
          cs = 0.0;
          sn = 1.0;
          rt1r = d;
          d = a;
          a = rt1r;
          b = -c;
          c = 0.0;
        } else {
          rt1r = a - d;
          if ((rt1r == 0.0) && ((b < 0.0) != (c < 0.0))) {
            cs = 1.0;
            sn = 0.0;
          } else {
            double bcmax;
            double bcmis;
            double p;
            double scale;
            double sigma;
            double z;
            int count;
            int i;
            p = 0.5 * rt1r;
            bcmis = std::abs(b);
            sigma = std::abs(c);
            bcmax = std::fmax(bcmis, sigma);
            if (!(b < 0.0)) {
              count = 1;
            } else {
              count = -1;
            }

            if (!(c < 0.0)) {
              i = 1;
            } else {
              i = -1;
            }

            bcmis = std::fmin(bcmis, sigma) * static_cast<double>(count) *
              static_cast<double>(i);
            scale = std::fmax(std::abs(p), bcmax);
            z = p / scale * p + bcmax / scale * bcmis;
            if (z >= 8.8817841970012523E-16) {
              a = std::sqrt(scale) * std::sqrt(z);
              if (!(p < 0.0)) {
                rt1r = a;
              } else {
                rt1r = -a;
              }

              z = p + rt1r;
              a = d + z;
              d -= bcmax / z * bcmis;
              scale = std::abs(z);
              if (sigma < scale) {
                bcmax = sigma / scale;
                scale *= std::sqrt(bcmax * bcmax + 1.0);
              } else if (sigma > scale) {
                scale /= sigma;
                scale = sigma * std::sqrt(scale * scale + 1.0);
              } else if (std::isnan(scale)) {
                scale = rtNaN;
              } else {
                scale = sigma * 1.4142135623730951;
              }

              cs = z / scale;
              sn = c / scale;
              b -= c;
              c = 0.0;
            } else {
              sigma = b + c;
              scale = std::fmax(std::abs(rt1r), std::abs(sigma));
              count = 0;
              while ((scale >= 7.4428285367870146E+137) && (count <= 20)) {
                sigma *= 1.3435752215134178E-138;
                rt1r *= 1.3435752215134178E-138;
                scale = std::fmax(std::abs(rt1r), std::abs(sigma));
                count++;
              }

              while ((scale <= 1.3435752215134178E-138) && (count <= 20)) {
                sigma *= 7.4428285367870146E+137;
                rt1r *= 7.4428285367870146E+137;
                scale = std::fmax(std::abs(rt1r), std::abs(sigma));
                count++;
              }

              bcmis = std::abs(sigma);
              scale = std::abs(rt1r);
              if (bcmis < scale) {
                bcmax = bcmis / scale;
                scale *= std::sqrt(bcmax * bcmax + 1.0);
              } else if (bcmis > scale) {
                scale /= bcmis;
                scale = bcmis * std::sqrt(scale * scale + 1.0);
              } else if (std::isnan(scale)) {
                scale = rtNaN;
              } else {
                scale = bcmis * 1.4142135623730951;
              }

              cs = std::sqrt(0.5 * (bcmis / scale + 1.0));
              if (!(sigma < 0.0)) {
                count = 1;
              } else {
                count = -1;
              }

              sn = -(0.5 * rt1r / (scale * cs)) * static_cast<double>(count);
              sigma = a * cs + b * sn;
              bcmax = -a * sn + b * cs;
              scale = c * cs + d * sn;
              bcmis = -c * sn + d * cs;
              b = bcmax * cs + bcmis * sn;
              c = -sigma * sn + scale * cs;
              rt1r = 0.5 * ((sigma * cs + scale * sn) + (-bcmax * sn + bcmis *
                cs));
              a = rt1r;
              d = rt1r;
              if (c != 0.0) {
                if (b != 0.0) {
                  if ((b < 0.0) == (c < 0.0)) {
                    bcmax = std::sqrt(std::abs(b));
                    bcmis = std::sqrt(std::abs(c));
                    a = bcmax * bcmis;
                    if (!(c < 0.0)) {
                      p = a;
                    } else {
                      p = -a;
                    }

                    scale = 1.0 / std::sqrt(std::abs(b + c));
                    a = rt1r + p;
                    d = rt1r - p;
                    b -= c;
                    c = 0.0;
                    bcmax *= scale;
                    bcmis *= scale;
                    rt1r = cs * bcmax - sn * bcmis;
                    sn = cs * bcmis + sn * bcmax;
                    cs = rt1r;
                  }
                } else {
                  b = -c;
                  c = 0.0;
                  rt1r = cs;
                  cs = -sn;
                  sn = rt1r;
                }
              }
            }
          }
        }

        rt1r = a;
        rt2r = d;
        if (c == 0.0) {
          rt1i = 0.0;
          rt2i = 0.0;
        } else {
          rt1i = std::sqrt(std::abs(b)) * std::sqrt(std::abs(c));
          rt2i = -rt1i;
        }

        return rt1r;
      }

      //
      // Arguments    : const double T[16]
      //                double vr[16]
      // Return Type  : void
      //
      static void xdtrevc3(const double T[16], double vr[16])
      {
        double work[12];
        double x[4];
        double remax;
        int ip;
        int iyend;
        int j;
        std::memset(&work[0], 0, 12U * sizeof(double));
        x[0] = 0.0;
        x[1] = 0.0;
        x[2] = 0.0;
        x[3] = 0.0;
        work[0] = 0.0;
        for (j = 0; j < 3; j++) {
          work[j + 1] = 0.0;
          for (iyend = 0; iyend <= j; iyend++) {
            work[j + 1] += std::abs(T[iyend + ((j + 1) << 2)]);
          }
        }

        ip = 0;
        for (int ki{3}; ki >= 0; ki--) {
          if (ip == -1) {
            ip = 1;
          } else {
            double smin;
            double wi;
            double wr_tmp;
            int wr_tmp_tmp;
            if ((ki + 1 == 1) || (T[ki + ((ki - 1) << 2)] == 0.0)) {
              ip = 0;
            } else {
              ip = -1;
            }

            wr_tmp_tmp = ki << 2;
            iyend = ki + wr_tmp_tmp;
            wr_tmp = T[iyend];
            wi = 0.0;
            if (ip != 0) {
              wi = std::sqrt(std::abs(T[ki + ((ki - 1) << 2)])) * std::sqrt(std::
                abs(T[iyend - 1]));
            }

            smin = std::fmax(2.2204460492503131E-16 * (std::abs(wr_tmp) + wi),
                             4.0083367200179456E-292);
            if (ip == 0) {
              double scale;
              int i;
              work[ki + 8] = 1.0;
              for (iyend = 0; iyend < ki; iyend++) {
                work[iyend + 8] = -T[iyend + wr_tmp_tmp];
              }

              j = ki - 1;
              int exitg1;
              do {
                exitg1 = 0;
                if (j + 1 >= 1) {
                  int i1;
                  bool guard1;
                  guard1 = false;
                  if (j + 1 == 1) {
                    guard1 = true;
                  } else {
                    i = (j - 1) << 2;
                    i1 = j + i;
                    if (T[i1] == 0.0) {
                      guard1 = true;
                    } else {
                      scale = xdlaln2(2, 1, smin, T, i1, work, j + 8, wr_tmp,
                                      0.0, x, remax);
                      if ((remax > 1.0) && (std::fmax(work[j - 1], work[j]) >
                                            2.4948003869183992E+291 / remax)) {
                        x[0] /= remax;
                        x[1] /= remax;
                        scale /= remax;
                      }

                      if (scale != 1.0) {
                        i1 = ki + 9;
                        for (iyend = 9; iyend <= i1; iyend++) {
                          work[iyend - 1] *= scale;
                        }
                      }

                      work[j + 7] = x[0];
                      work[j + 8] = x[1];
                      blas::xaxpy(j - 1, -x[0], T, i + 1, work);
                      blas::xaxpy(j - 1, -x[1], T, (j << 2) + 1, work);
                      j -= 2;
                    }
                  }

                  if (guard1) {
                    i = j << 2;
                    scale = xdlaln2(1, 1, smin, T, (i + j) + 1, work, j + 9,
                                    wr_tmp, 0.0, x, remax);
                    if ((remax > 1.0) && (work[j] > 2.4948003869183992E+291 /
                                          remax)) {
                      x[0] /= remax;
                      scale /= remax;
                    }

                    if (scale != 1.0) {
                      i1 = ki + 9;
                      for (iyend = 9; iyend <= i1; iyend++) {
                        work[iyend - 1] *= scale;
                      }
                    }

                    work[j + 8] = x[0];
                    blas::xaxpy(j, -x[0], T, i + 1, work);
                    j--;
                  }
                } else {
                  exitg1 = 1;
                }
              } while (exitg1 == 0);

              if (ki + 1 > 1) {
                blas::xgemv(ki, work, work[ki + 8], vr, wr_tmp_tmp + 1);
              }

              iyend = -1;
              remax = std::abs(vr[wr_tmp_tmp]);
              scale = std::abs(vr[wr_tmp_tmp + 1]);
              if (scale > remax) {
                iyend = 0;
                remax = scale;
              }

              scale = std::abs(vr[wr_tmp_tmp + 2]);
              if (scale > remax) {
                iyend = 1;
                remax = scale;
              }

              if (std::abs(vr[wr_tmp_tmp + 3]) > remax) {
                iyend = 2;
              }

              remax = 1.0 / std::abs(vr[(iyend + wr_tmp_tmp) + 1]);
              i = wr_tmp_tmp + 4;
              for (iyend = wr_tmp_tmp + 1; iyend <= i; iyend++) {
                vr[iyend - 1] *= remax;
              }
            } else {
              double scale;
              int i;
              int i1;
              int ix0;
              ix0 = (ki - 1) << 2;
              remax = T[ki + ix0];
              scale = T[iyend - 1];
              if (std::abs(scale) >= std::abs(remax)) {
                work[ki + 3] = 1.0;
                work[ki + 8] = wi / scale;
              } else {
                work[ki + 3] = -wi / remax;
                work[ki + 8] = 1.0;
              }

              work[ki + 4] = 0.0;
              work[ki + 7] = 0.0;
              for (iyend = 0; iyend <= ki - 2; iyend++) {
                work[iyend + 4] = -work[ki + 3] * T[iyend + ix0];
                work[iyend + 8] = -work[ki + 8] * T[iyend + wr_tmp_tmp];
              }

              j = ki - 2;
              while (j + 1 >= 1) {
                if ((j + 1 == 1) || (T[1] == 0.0)) {
                  i = j << 2;
                  scale = xdlaln2(1, 2, smin, T, (i + j) + 1, work, j + 5,
                                  wr_tmp, wi, x, remax);
                  if ((remax > 1.0) && (work[j] > 2.4948003869183992E+291 /
                                        remax)) {
                    x[0] /= remax;
                    x[2] /= remax;
                    scale /= remax;
                  }

                  if (scale != 1.0) {
                    i1 = ki + 5;
                    for (iyend = 5; iyend <= i1; iyend++) {
                      work[iyend - 1] *= scale;
                    }

                    i1 = ki + 9;
                    for (iyend = 9; iyend <= i1; iyend++) {
                      work[iyend - 1] *= scale;
                    }
                  }

                  work[j + 4] = x[0];
                  work[j + 8] = x[2];
                  if ((j >= 1) && (!(-x[0] == 0.0))) {
                    work[4] += -x[0] * T[i];
                  }

                  blas::xaxpy(j, -x[2], T, i + 1, work);
                  j--;
                } else {
                  scale = xdlaln2(2, 2, smin, T, 1, work, 5, wr_tmp, wi, x,
                                  remax);
                  if ((remax > 1.0) && (std::fmax(work[0], work[1]) >
                                        2.4948003869183992E+291 / remax)) {
                    remax = 1.0 / remax;
                    x[0] *= remax;
                    x[2] *= remax;
                    x[1] *= remax;
                    x[3] *= remax;
                    scale *= remax;
                  }

                  if (scale != 1.0) {
                    i = ki + 5;
                    for (iyend = 5; iyend <= i; iyend++) {
                      work[iyend - 1] *= scale;
                    }

                    i = ki + 9;
                    for (iyend = 9; iyend <= i; iyend++) {
                      work[iyend - 1] *= scale;
                    }
                  }

                  work[4] = x[0];
                  work[5] = x[1];
                  work[8] = x[2];
                  work[9] = x[3];
                  blas::xaxpy(0, -x[2], T, 1, work);
                  blas::xaxpy(0, -x[3], T, 5, work);
                  j = -1;
                }
              }

              if (ki + 1 > 2) {
                iyend = ix0 + 4;
                remax = work[ki + 3];
                if (remax != 1.0) {
                  if (remax == 0.0) {
                    if (ix0 + 1 <= iyend) {
                      std::memset(&vr[ix0], 0, static_cast<unsigned int>(iyend -
                        ix0) * sizeof(double));
                    }
                  } else {
                    for (j = ix0 + 1; j <= iyend; j++) {
                      vr[j - 1] *= remax;
                    }
                  }
                }

                iyend = 4;
                i = ((ki - 2) << 2) + 1;
                for (int iac{1}; iac <= i; iac += 4) {
                  i1 = iac + 3;
                  for (int ia{iac}; ia <= i1; ia++) {
                    j = (ix0 + ia) - iac;
                    vr[j] += vr[ia - 1] * work[iyend];
                  }

                  iyend++;
                }

                blas::xgemv(ki - 1, work, work[ki + 8], vr, wr_tmp_tmp + 1);
              } else {
                i = ix0 + 4;
                for (iyend = ix0 + 1; iyend <= i; iyend++) {
                  vr[iyend - 1] *= work[4];
                }

                i = wr_tmp_tmp + 4;
                for (iyend = wr_tmp_tmp + 1; iyend <= i; iyend++) {
                  vr[iyend - 1] *= work[ki + 8];
                }
              }

              remax = 1.0 / std::fmax(std::fmax(std::fmax(std::fmax(0.0, std::
                abs(vr[ix0]) + std::abs(vr[wr_tmp_tmp])), std::abs(vr[ix0 + 1])
                + std::abs(vr[wr_tmp_tmp + 1])), std::abs(vr[ix0 + 2]) + std::
                abs(vr[wr_tmp_tmp + 2])), std::abs(vr[ix0 + 3]) + std::abs
                (vr[wr_tmp_tmp + 3]));
              i = ix0 + 4;
              for (iyend = ix0 + 1; iyend <= i; iyend++) {
                vr[iyend - 1] *= remax;
              }

              i = wr_tmp_tmp + 4;
              for (iyend = wr_tmp_tmp + 1; iyend <= i; iyend++) {
                vr[iyend - 1] *= remax;
              }
            }
          }
        }
      }

      //
      // Arguments    : double A[16]
      //                int &ihi
      //                double scale[4]
      // Return Type  : int
      //
      static int xzgebal(double A[16], int &ihi, double scale[4])
      {
        double b_scale;
        int b_i;
        int exitg5;
        int i;
        int ilo;
        int ira;
        int ix;
        int ix0_tmp;
        int kend;
        bool converged;
        bool notdone;
        scale[0] = 1.0;
        scale[1] = 1.0;
        scale[2] = 1.0;
        scale[3] = 1.0;
        ilo = 1;
        ihi = 4;
        notdone = true;
        do {
          exitg5 = 0;
          if (notdone) {
            int exitg4;
            notdone = false;
            ix0_tmp = ihi;
            do {
              exitg4 = 0;
              if (ix0_tmp > 0) {
                bool exitg6;
                converged = false;
                i = 0;
                exitg6 = false;
                while ((!exitg6) && (i <= static_cast<unsigned char>(ihi) - 1))
                {
                  if ((i + 1 == ix0_tmp) || (!(A[(ix0_tmp + (i << 2)) - 1] !=
                        0.0))) {
                    i++;
                  } else {
                    converged = true;
                    exitg6 = true;
                  }
                }

                if (converged) {
                  ix0_tmp--;
                } else {
                  scale[ihi - 1] = ix0_tmp;
                  if (ix0_tmp != ihi) {
                    ix = (ix0_tmp - 1) << 2;
                    ira = (ihi - 1) << 2;
                    b_i = static_cast<unsigned char>(ihi);
                    for (int k{0}; k < b_i; k++) {
                      int i1;
                      i = ix + k;
                      b_scale = A[i];
                      i1 = ira + k;
                      A[i] = A[i1];
                      A[i1] = b_scale;
                    }

                    b_scale = A[ix0_tmp - 1];
                    A[ix0_tmp - 1] = A[ihi - 1];
                    A[ihi - 1] = b_scale;
                    b_scale = A[ix0_tmp + 3];
                    A[ix0_tmp + 3] = A[ihi + 3];
                    A[ihi + 3] = b_scale;
                    b_scale = A[ix0_tmp + 7];
                    A[ix0_tmp + 7] = A[ihi + 7];
                    A[ihi + 7] = b_scale;
                    b_scale = A[ix0_tmp + 11];
                    A[ix0_tmp + 11] = A[ihi + 11];
                    A[ihi + 11] = b_scale;
                  }

                  exitg4 = 1;
                }
              } else {
                exitg4 = 2;
              }
            } while (exitg4 == 0);

            if (exitg4 == 1) {
              if (ihi == 1) {
                ilo = 1;
                ihi = 1;
                exitg5 = 1;
              } else {
                ihi--;
                notdone = true;
              }
            }
          } else {
            notdone = true;
            while (notdone) {
              bool exitg6;
              notdone = false;
              ix0_tmp = ilo;
              exitg6 = false;
              while ((!exitg6) && (ix0_tmp <= ihi)) {
                bool exitg7;
                converged = false;
                i = ilo;
                exitg7 = false;
                while ((!exitg7) && (i <= ihi)) {
                  if ((i == ix0_tmp) || (!(A[(i + ((ix0_tmp - 1) << 2)) - 1] !=
                        0.0))) {
                    i++;
                  } else {
                    converged = true;
                    exitg7 = true;
                  }
                }

                if (converged) {
                  ix0_tmp++;
                } else {
                  scale[ilo - 1] = ix0_tmp;
                  if (ix0_tmp != ilo) {
                    int i1;
                    ix = (ix0_tmp - 1) << 2;
                    kend = (ilo - 1) << 2;
                    b_i = static_cast<unsigned char>(ihi);
                    for (int k{0}; k < b_i; k++) {
                      i = ix + k;
                      b_scale = A[i];
                      i1 = kend + k;
                      A[i] = A[i1];
                      A[i1] = b_scale;
                    }

                    ix = (kend + ix0_tmp) - 1;
                    ira = (kend + ilo) - 1;
                    b_i = static_cast<unsigned char>(5 - ilo);
                    for (int k{0}; k < b_i; k++) {
                      i = k << 2;
                      kend = ix + i;
                      b_scale = A[kend];
                      i1 = ira + i;
                      A[kend] = A[i1];
                      A[i1] = b_scale;
                    }
                  }

                  ilo++;
                  notdone = true;
                  exitg6 = true;
                }
              }
            }

            converged = false;
            exitg5 = 2;
          }
        } while (exitg5 == 0);

        if (exitg5 != 1) {
          bool exitg3;
          exitg3 = false;
          while ((!exitg3) && (!converged)) {
            int exitg2;
            converged = true;
            i = ilo - 1;
            do {
              exitg2 = 0;
              if (i + 1 <= ihi) {
                double absxk;
                double c;
                double ca;
                double r;
                double t;
                kend = (ihi - ilo) + 1;
                ix = i << 2;
                c = blas::xnrm2(kend, A, ix + ilo);
                ix0_tmp = ((ilo - 1) << 2) + i;
                r = 0.0;
                if (kend >= 1) {
                  if (kend == 1) {
                    r = std::abs(A[ix0_tmp]);
                  } else {
                    b_scale = 3.3121686421112381E-170;
                    kend = (ix0_tmp + ((kend - 1) << 2)) + 1;
                    for (int k{ix0_tmp + 1}; k <= kend; k += 4) {
                      absxk = std::abs(A[k - 1]);
                      if (absxk > b_scale) {
                        t = b_scale / absxk;
                        r = r * t * t + 1.0;
                        b_scale = absxk;
                      } else {
                        t = absxk / b_scale;
                        r += t * t;
                      }
                    }

                    r = b_scale * std::sqrt(r);
                  }
                }

                kend = 1;
                if (ihi > 1) {
                  b_scale = std::abs(A[ix]);
                  for (int k{2}; k <= ihi; k++) {
                    t = std::abs(A[(ix + k) - 1]);
                    if (t > b_scale) {
                      kend = k;
                      b_scale = t;
                    }
                  }
                }

                ca = std::abs(A[(kend + ix) - 1]);
                kend = 5 - ilo;
                if (5 - ilo < 1) {
                  ira = 0;
                } else {
                  ira = 1;
                  if (5 - ilo > 1) {
                    b_scale = std::abs(A[ix0_tmp]);
                    for (int k{2}; k <= kend; k++) {
                      t = std::abs(A[ix0_tmp + ((k - 1) << 2)]);
                      if (t > b_scale) {
                        ira = k;
                        b_scale = t;
                      }
                    }
                  }
                }

                b_scale = std::abs(A[i + (((ira + ilo) - 2) << 2)]);
                if ((c == 0.0) || (r == 0.0)) {
                  i++;
                } else {
                  double f;
                  int exitg1;
                  absxk = r / 2.0;
                  f = 1.0;
                  t = c + r;
                  do {
                    exitg1 = 0;
                    if ((c < absxk) && (std::fmax(f, std::fmax(c, ca)) <
                                        4.9896007738368E+291) && (std::fmin(r,
                          std::fmin(absxk, b_scale)) > 2.0041683600089728E-292))
                    {
                      if (std::isnan(((((c + f) + ca) + r) + absxk) + b_scale))
                      {
                        exitg1 = 1;
                      } else {
                        f *= 2.0;
                        c *= 2.0;
                        ca *= 2.0;
                        r /= 2.0;
                        absxk /= 2.0;
                        b_scale /= 2.0;
                      }
                    } else {
                      absxk = c / 2.0;
                      while ((absxk >= r) && (std::fmax(r, b_scale) <
                                              4.9896007738368E+291) && (std::
                              fmin(std::fmin(f, c), std::fmin(absxk, ca)) >
                              2.0041683600089728E-292)) {
                        f /= 2.0;
                        c /= 2.0;
                        absxk /= 2.0;
                        ca /= 2.0;
                        r *= 2.0;
                        b_scale *= 2.0;
                      }

                      if ((!(c + r >= 0.95 * t)) && ((!(f < 1.0)) || (!(scale[i]
                             < 1.0)) || (!(f * scale[i] <=
                                           1.0020841800044864E-292))) && ((!(f >
                             1.0)) || (!(scale[i] > 1.0)) || (!(scale[i] >=
                             9.9792015476736E+291 / f)))) {
                        b_scale = 1.0 / f;
                        scale[i] *= f;
                        kend = ix0_tmp + 1;
                        b_i = (ix0_tmp + ((4 - ilo) << 2)) + 1;
                        for (int k{kend}; k <= b_i; k += 4) {
                          A[k - 1] *= b_scale;
                        }

                        b_i = ix + ihi;
                        for (int k{ix + 1}; k <= b_i; k++) {
                          A[k - 1] *= f;
                        }

                        converged = false;
                      }

                      exitg1 = 2;
                    }
                  } while (exitg1 == 0);

                  if (exitg1 == 1) {
                    exitg2 = 2;
                  } else {
                    i++;
                  }
                }
              } else {
                exitg2 = 1;
              }
            } while (exitg2 == 0);

            if (exitg2 != 1) {
              exitg3 = true;
            }
          }
        }

        return ilo;
      }

      //
      // Arguments    : double a[16]
      //                int ilo
      //                int ihi
      //                double tau[3]
      // Return Type  : void
      //
      static void xzgehrd(double a[16], int ilo, int ihi, double tau[3])
      {
        double work[4];
        double alpha1;
        if ((ihi - ilo) + 1 > 1) {
          int i;
          i = static_cast<unsigned char>(ilo - 1);
          if (i - 1 >= 0) {
            std::memset(&tau[0], 0, static_cast<unsigned int>(i) * sizeof(double));
          }

          for (int b_i{ihi}; b_i < 4; b_i++) {
            tau[b_i - 1] = 0.0;
          }

          work[0] = 0.0;
          work[1] = 0.0;
          work[2] = 0.0;
          work[3] = 0.0;
          for (int b_i{ilo}; b_i < ihi; b_i++) {
            double d;
            int alpha1_tmp_tmp;
            int c_i;
            int ia;
            int ic0;
            int in;
            int lastc;
            int lastv;
            int n;
            c_i = (b_i - 1) << 2;
            in = b_i << 2;
            n = ihi - b_i;
            alpha1_tmp_tmp = b_i + c_i;
            alpha1 = a[alpha1_tmp_tmp];
            if (b_i + 2 <= 4) {
              i = b_i + 1;
            } else {
              i = 3;
            }

            d = xzlarfg(n, alpha1, a, (i + c_i) + 1);
            tau[b_i - 1] = d;
            a[alpha1_tmp_tmp] = 1.0;
            ic0 = in + 1;
            if (d != 0.0) {
              bool exitg2;
              lastv = n;
              c_i = alpha1_tmp_tmp + n;
              while ((lastv > 0) && (a[c_i - 1] == 0.0)) {
                lastv--;
                c_i--;
              }

              lastc = ihi;
              exitg2 = false;
              while ((!exitg2) && (lastc > 0)) {
                int exitg1;
                c_i = in + lastc;
                ia = c_i;
                do {
                  exitg1 = 0;
                  if (ia <= c_i + ((lastv - 1) << 2)) {
                    if (a[ia - 1] != 0.0) {
                      exitg1 = 1;
                    } else {
                      ia += 4;
                    }
                  } else {
                    lastc--;
                    exitg1 = 2;
                  }
                } while (exitg1 == 0);

                if (exitg1 == 1) {
                  exitg2 = true;
                }
              }
            } else {
              lastv = 0;
              lastc = 0;
            }

            if (lastv > 0) {
              int i1;
              int jA;
              if (lastc != 0) {
                i = static_cast<unsigned char>(lastc);
                std::memset(&work[0], 0, static_cast<unsigned int>(i) * sizeof
                            (double));
                c_i = alpha1_tmp_tmp;
                i = (in + ((lastv - 1) << 2)) + 1;
                for (int iac{ic0}; iac <= i; iac += 4) {
                  i1 = iac + lastc;
                  for (ia = iac; ia < i1; ia++) {
                    jA = ia - iac;
                    work[jA] += a[ia - 1] * a[c_i];
                  }

                  c_i++;
                }
              }

              d = -tau[b_i - 1];
              if (!(d == 0.0)) {
                jA = in;
                i = static_cast<unsigned char>(lastv);
                for (int iac{0}; iac < i; iac++) {
                  double temp;
                  temp = a[alpha1_tmp_tmp + iac];
                  if (temp != 0.0) {
                    temp *= d;
                    i1 = jA + 1;
                    c_i = lastc + jA;
                    for (ic0 = i1; ic0 <= c_i; ic0++) {
                      a[ic0 - 1] += work[(ic0 - jA) - 1] * temp;
                    }
                  }

                  jA += 4;
                }
              }
            }

            xzlarf(n, 4 - b_i, alpha1_tmp_tmp + 1, tau[b_i - 1], a, (b_i + in) +
                   1, work);
            a[alpha1_tmp_tmp] = alpha1;
          }
        }
      }

      //
      // Arguments    : int m
      //                int n
      //                array<double, 2U> &A
      //                int lda
      //                array<int, 2U> &ipiv
      // Return Type  : int
      //
      static int xzgetrf(int m, int n, array<double, 2U> &A, int lda, array<int,
                         2U> &ipiv)
      {
        int b_n;
        int info;
        int yk;
        if (m <= n) {
          yk = m;
        } else {
          yk = n;
        }

        if (yk < 1) {
          b_n = 0;
        } else {
          b_n = yk;
        }

        ipiv.set_size(1, b_n);
        if (b_n > 0) {
          ipiv[0] = 1;
          yk = 1;
          for (int k{2}; k <= b_n; k++) {
            yk++;
            ipiv[k - 1] = yk;
          }
        }

        info = 0;
        if ((m >= 1) && (n >= 1)) {
          int u0;
          u0 = m - 1;
          if (u0 > n) {
            u0 = n;
          }

          for (int j{0}; j < u0; j++) {
            double smax;
            int b_tmp;
            int i;
            int jA;
            int mmj;
            int temp_tmp;
            mmj = m - j;
            b_tmp = j * (lda + 1);
            b_n = b_tmp + 2;
            if (mmj < 1) {
              yk = -1;
            } else {
              yk = 0;
              if (mmj > 1) {
                smax = std::abs(A[b_tmp]);
                for (int k{2}; k <= mmj; k++) {
                  double s;
                  s = std::abs(A[(b_tmp + k) - 1]);
                  if (s > smax) {
                    yk = k - 1;
                    smax = s;
                  }
                }
              }
            }

            if (A[b_tmp + yk] != 0.0) {
              if (yk != 0) {
                jA = j + yk;
                ipiv[j] = jA + 1;
                for (int k{0}; k < n; k++) {
                  yk = k * lda;
                  temp_tmp = j + yk;
                  smax = A[temp_tmp];
                  i = jA + yk;
                  A[temp_tmp] = A[i];
                  A[i] = smax;
                }
              }

              i = b_tmp + mmj;
              for (yk = b_n; yk <= i; yk++) {
                A[yk - 1] = A[yk - 1] / A[b_tmp];
              }
            } else {
              info = j + 1;
            }

            b_n = n - j;
            yk = b_tmp + lda;
            jA = yk + 1;
            for (int k{0}; k <= b_n - 2; k++) {
              smax = A[yk + k * lda];
              if (smax != 0.0) {
                i = jA + 1;
                temp_tmp = mmj + jA;
                for (int ijA{i}; ijA < temp_tmp; ijA++) {
                  A[ijA - 1] = A[ijA - 1] + A[(b_tmp + ijA) - jA] * -smax;
                }
              }

              jA += lda;
            }
          }

          if ((info == 0) && (m <= n) && (!(A[(m + A.size(0) * (m - 1)) - 1] !=
                0.0))) {
            info = m;
          }
        }

        return info;
      }

      //
      // Arguments    : const double x[9]
      // Return Type  : double
      //
      static double xzlangeM(const double x[9])
      {
        double y;
        int k;
        bool exitg1;
        y = 0.0;
        k = 0;
        exitg1 = false;
        while ((!exitg1) && (k < 9)) {
          double absxk;
          absxk = std::abs(x[k]);
          if (std::isnan(absxk)) {
            y = rtNaN;
            exitg1 = true;
          } else {
            if (absxk > y) {
              y = absxk;
            }

            k++;
          }
        }

        return y;
      }

      //
      // Arguments    : const array<double, 2U> &x
      // Return Type  : double
      //
      static double xzlangeM(const array<double, 2U> &x)
      {
        double y;
        bool b;
        bool b1;
        y = 0.0;
        b = (x.size(0) == 0);
        b1 = (x.size(1) == 0);
        if ((!b) && (!b1)) {
          int k;
          k = 0;
          int exitg1;
          int i;
          do {
            exitg1 = 0;
            i = x.size(0) * x.size(1);
            if (k <= i - 1) {
              double absxk;
              absxk = std::abs(x[k]);
              if (std::isnan(absxk)) {
                y = rtNaN;
                exitg1 = 1;
              } else {
                if (absxk > y) {
                  y = absxk;
                }

                k++;
              }
            } else {
              exitg1 = 1;
            }
          } while (exitg1 == 0);
        }

        return y;
      }

      //
      // Arguments    : int m
      //                int n
      //                int iv0
      //                double tau
      //                double C[16]
      //                int ic0
      //                double work[4]
      // Return Type  : void
      //
      static void xzlarf(int m, int n, int iv0, double tau, double C[16], int
                         ic0, double work[4])
      {
        int i;
        int ia;
        int lastc;
        int lastv;
        if (tau != 0.0) {
          bool exitg2;
          lastv = m;
          i = iv0 + m;
          while ((lastv > 0) && (C[i - 2] == 0.0)) {
            lastv--;
            i--;
          }

          lastc = n;
          exitg2 = false;
          while ((!exitg2) && (lastc > 0)) {
            int exitg1;
            i = ic0 + ((lastc - 1) << 2);
            ia = i;
            do {
              exitg1 = 0;
              if (ia <= (i + lastv) - 1) {
                if (C[ia - 1] != 0.0) {
                  exitg1 = 1;
                } else {
                  ia++;
                }
              } else {
                lastc--;
                exitg1 = 2;
              }
            } while (exitg1 == 0);

            if (exitg1 == 1) {
              exitg2 = true;
            }
          }
        } else {
          lastv = 0;
          lastc = 0;
        }

        if (lastv > 0) {
          double c;
          int b_i;
          int i1;
          if (lastc != 0) {
            b_i = static_cast<unsigned char>(lastc);
            std::memset(&work[0], 0, static_cast<unsigned int>(b_i) * sizeof
                        (double));
            b_i = ic0 + ((lastc - 1) << 2);
            for (i = ic0; i <= b_i; i += 4) {
              c = 0.0;
              i1 = i + lastv;
              for (ia = i; ia < i1; ia++) {
                c += C[ia - 1] * C[((iv0 + ia) - i) - 1];
              }

              i1 = (i - ic0) >> 2;
              work[i1] += c;
            }
          }

          if (!(-tau == 0.0)) {
            i = ic0;
            b_i = static_cast<unsigned char>(lastc);
            for (lastc = 0; lastc < b_i; lastc++) {
              c = work[lastc];
              if (c != 0.0) {
                c *= -tau;
                i1 = lastv + i;
                for (ia = i; ia < i1; ia++) {
                  C[ia - 1] += C[((iv0 + ia) - i) - 1] * c;
                }
              }

              i += 4;
            }
          }
        }
      }

      //
      // Arguments    : int n
      //                double &alpha1
      //                double x[3]
      // Return Type  : double
      //
      static double xzlarfg(int n, double &alpha1, double x[3])
      {
        double tau;
        tau = 0.0;
        if (n > 0) {
          double xnorm;
          xnorm = blas::xnrm2(n - 1, x);
          if (xnorm != 0.0) {
            double a_tmp;
            a_tmp = std::abs(alpha1);
            xnorm = std::abs(xnorm);
            if (a_tmp < xnorm) {
              a_tmp /= xnorm;
              xnorm *= std::sqrt(a_tmp * a_tmp + 1.0);
            } else if (a_tmp > xnorm) {
              xnorm /= a_tmp;
              xnorm = a_tmp * std::sqrt(xnorm * xnorm + 1.0);
            } else if (std::isnan(xnorm)) {
              xnorm = rtNaN;
            } else {
              xnorm = a_tmp * 1.4142135623730951;
            }

            if (alpha1 >= 0.0) {
              xnorm = -xnorm;
            }

            if (std::abs(xnorm) < 1.0020841800044864E-292) {
              int knt;
              knt = 0;
              do {
                knt++;
                for (int k{2}; k <= n; k++) {
                  x[k - 1] *= 9.9792015476736E+291;
                }

                xnorm *= 9.9792015476736E+291;
                alpha1 *= 9.9792015476736E+291;
              } while ((std::abs(xnorm) < 1.0020841800044864E-292) && (knt < 20));

              a_tmp = std::abs(alpha1);
              xnorm = std::abs(blas::xnrm2(n - 1, x));
              if (a_tmp < xnorm) {
                a_tmp /= xnorm;
                xnorm *= std::sqrt(a_tmp * a_tmp + 1.0);
              } else if (a_tmp > xnorm) {
                xnorm /= a_tmp;
                xnorm = a_tmp * std::sqrt(xnorm * xnorm + 1.0);
              } else if (std::isnan(xnorm)) {
                xnorm = rtNaN;
              } else {
                xnorm = a_tmp * 1.4142135623730951;
              }

              if (alpha1 >= 0.0) {
                xnorm = -xnorm;
              }

              tau = (xnorm - alpha1) / xnorm;
              a_tmp = 1.0 / (alpha1 - xnorm);
              for (int k{2}; k <= n; k++) {
                x[k - 1] *= a_tmp;
              }

              for (int k{0}; k < knt; k++) {
                xnorm *= 1.0020841800044864E-292;
              }

              alpha1 = xnorm;
            } else {
              tau = (xnorm - alpha1) / xnorm;
              a_tmp = 1.0 / (alpha1 - xnorm);
              for (int k{2}; k <= n; k++) {
                x[k - 1] *= a_tmp;
              }

              alpha1 = xnorm;
            }
          }
        }

        return tau;
      }

      //
      // Arguments    : int n
      //                double &alpha1
      //                double x[16]
      //                int ix0
      // Return Type  : double
      //
      static double xzlarfg(int n, double &alpha1, double x[16], int ix0)
      {
        double tau;
        tau = 0.0;
        if (n > 0) {
          double xnorm;
          xnorm = blas::xnrm2(n - 1, x, ix0);
          if (xnorm != 0.0) {
            double a_tmp;
            a_tmp = std::abs(alpha1);
            xnorm = std::abs(xnorm);
            if (a_tmp < xnorm) {
              a_tmp /= xnorm;
              xnorm *= std::sqrt(a_tmp * a_tmp + 1.0);
            } else if (a_tmp > xnorm) {
              xnorm /= a_tmp;
              xnorm = a_tmp * std::sqrt(xnorm * xnorm + 1.0);
            } else if (std::isnan(xnorm)) {
              xnorm = rtNaN;
            } else {
              xnorm = a_tmp * 1.4142135623730951;
            }

            if (alpha1 >= 0.0) {
              xnorm = -xnorm;
            }

            if (std::abs(xnorm) < 1.0020841800044864E-292) {
              int i;
              int knt;
              knt = 0;
              i = (ix0 + n) - 2;
              do {
                knt++;
                for (int k{ix0}; k <= i; k++) {
                  x[k - 1] *= 9.9792015476736E+291;
                }

                xnorm *= 9.9792015476736E+291;
                alpha1 *= 9.9792015476736E+291;
              } while ((std::abs(xnorm) < 1.0020841800044864E-292) && (knt < 20));

              a_tmp = std::abs(alpha1);
              xnorm = std::abs(blas::xnrm2(n - 1, x, ix0));
              if (a_tmp < xnorm) {
                a_tmp /= xnorm;
                xnorm *= std::sqrt(a_tmp * a_tmp + 1.0);
              } else if (a_tmp > xnorm) {
                xnorm /= a_tmp;
                xnorm = a_tmp * std::sqrt(xnorm * xnorm + 1.0);
              } else if (std::isnan(xnorm)) {
                xnorm = rtNaN;
              } else {
                xnorm = a_tmp * 1.4142135623730951;
              }

              if (alpha1 >= 0.0) {
                xnorm = -xnorm;
              }

              tau = (xnorm - alpha1) / xnorm;
              a_tmp = 1.0 / (alpha1 - xnorm);
              for (int k{ix0}; k <= i; k++) {
                x[k - 1] *= a_tmp;
              }

              for (int k{0}; k < knt; k++) {
                xnorm *= 1.0020841800044864E-292;
              }

              alpha1 = xnorm;
            } else {
              int i;
              tau = (xnorm - alpha1) / xnorm;
              a_tmp = 1.0 / (alpha1 - xnorm);
              i = (ix0 + n) - 2;
              for (int k{ix0}; k <= i; k++) {
                x[k - 1] *= a_tmp;
              }

              alpha1 = xnorm;
            }
          }
        }

        return tau;
      }

      //
      // Arguments    : double f
      //                double g
      //                double &sn
      //                double &r
      // Return Type  : double
      //
      static double xzlartg(double f, double g, double &sn, double &r)
      {
        double cs;
        cs = std::abs(f);
        r = std::abs(g);
        if (g == 0.0) {
          cs = 1.0;
          sn = 0.0;
          r = f;
        } else if (f == 0.0) {
          cs = 0.0;
          if (g >= 0.0) {
            sn = 1.0;
          } else {
            sn = -1.0;
          }
        } else if ((cs > 1.4916681462400413E-154) && (cs <
                    4.7403759540545887E+153) && (r > 1.4916681462400413E-154) &&
                   (r < 4.7403759540545887E+153)) {
          r = std::sqrt(f * f + g * g);
          cs /= r;
          if (!(f >= 0.0)) {
            r = -r;
          }

          sn = g / r;
        } else {
          double gs;
          double u;
          u = std::fmin(4.49423283715579E+307, std::fmax(2.2250738585072014E-308,
            std::fmax(cs, r)));
          cs = f / u;
          gs = g / u;
          r = std::sqrt(cs * cs + gs * gs);
          cs = std::abs(cs) / r;
          if (!(f >= 0.0)) {
            r = -r;
          }

          sn = gs / r;
          r *= u;
        }

        return cs;
      }

      //
      // Arguments    : double cfrom
      //                double cto
      //                int m
      //                int n
      //                array<double, 2U> &A
      //                int lda
      // Return Type  : void
      //
      static void xzlascl(double cfrom, double cto, int m, int n, array<double,
                          2U> &A, int lda)
      {
        double cfromc;
        double ctoc;
        bool notdone;
        cfromc = cfrom;
        ctoc = cto;
        notdone = true;
        while (notdone) {
          double cfrom1;
          double cto1;
          double mul;
          cfrom1 = cfromc * 2.0041683600089728E-292;
          cto1 = ctoc / 4.9896007738368E+291;
          if ((std::abs(cfrom1) > std::abs(ctoc)) && (ctoc != 0.0)) {
            mul = 2.0041683600089728E-292;
            cfromc = cfrom1;
          } else if (std::abs(cto1) > std::abs(cfromc)) {
            mul = 4.9896007738368E+291;
            ctoc = cto1;
          } else {
            mul = ctoc / cfromc;
            notdone = false;
          }

          for (int j{0}; j < n; j++) {
            int offset;
            offset = j * lda - 1;
            for (int i{0}; i < m; i++) {
              int b_i;
              b_i = (offset + i) + 1;
              A[b_i] = A[b_i] * mul;
            }
          }
        }
      }

      //
      // Arguments    : double cfrom
      //                double cto
      //                int m
      //                double A[4]
      //                int iA0
      // Return Type  : void
      //
      static void xzlascl(double cfrom, double cto, int m, double A[4], int iA0)
      {
        double cfromc;
        double ctoc;
        bool notdone;
        cfromc = cfrom;
        ctoc = cto;
        notdone = true;
        while (notdone) {
          double cfrom1;
          double cto1;
          double mul;
          cfrom1 = cfromc * 2.0041683600089728E-292;
          cto1 = ctoc / 4.9896007738368E+291;
          if ((std::abs(cfrom1) > std::abs(ctoc)) && (ctoc != 0.0)) {
            mul = 2.0041683600089728E-292;
            cfromc = cfrom1;
          } else if (std::abs(cto1) > std::abs(cfromc)) {
            mul = 4.9896007738368E+291;
            ctoc = cto1;
          } else {
            mul = ctoc / cfromc;
            notdone = false;
          }

          for (int i{0}; i < m; i++) {
            int b_i;
            b_i = (iA0 + i) - 1;
            A[b_i] *= mul;
          }
        }
      }

      //
      // Arguments    : double cfrom
      //                double cto
      //                double A[16]
      // Return Type  : void
      //
      static void xzlascl(double cfrom, double cto, double A[16])
      {
        double cfromc;
        double ctoc;
        bool notdone;
        cfromc = cfrom;
        ctoc = cto;
        notdone = true;
        while (notdone) {
          double cfrom1;
          double cto1;
          double mul;
          cfrom1 = cfromc * 2.0041683600089728E-292;
          cto1 = ctoc / 4.9896007738368E+291;
          if ((std::abs(cfrom1) > std::abs(ctoc)) && (ctoc != 0.0)) {
            mul = 2.0041683600089728E-292;
            cfromc = cfrom1;
          } else if (std::abs(cto1) > std::abs(cfromc)) {
            mul = 4.9896007738368E+291;
            ctoc = cto1;
          } else {
            mul = ctoc / cfromc;
            notdone = false;
          }

          for (int j{0}; j < 4; j++) {
            int offset;
            offset = (j << 2) - 1;
            A[offset + 1] *= mul;
            A[offset + 2] *= mul;
            A[offset + 3] *= mul;
            A[offset + 4] *= mul;
          }
        }
      }

      //
      // Arguments    : double cfrom
      //                double cto
      //                int m
      //                array<double, 1U> &A
      // Return Type  : void
      //
      static void xzlascl(double cfrom, double cto, int m, array<double, 1U> &A)
      {
        double cfromc;
        double ctoc;
        bool notdone;
        cfromc = cfrom;
        ctoc = cto;
        notdone = true;
        while (notdone) {
          double cfrom1;
          double cto1;
          double mul;
          cfrom1 = cfromc * 2.0041683600089728E-292;
          cto1 = ctoc / 4.9896007738368E+291;
          if ((std::abs(cfrom1) > std::abs(ctoc)) && (ctoc != 0.0)) {
            mul = 2.0041683600089728E-292;
            cfromc = cfrom1;
          } else if (std::abs(cto1) > std::abs(cfromc)) {
            mul = 4.9896007738368E+291;
            ctoc = cto1;
          } else {
            mul = ctoc / cfromc;
            notdone = false;
          }

          for (int i{0}; i < m; i++) {
            A[i] = A[i] * mul;
          }
        }
      }

      //
      // Arguments    : double d[4]
      //                double e[3]
      //                double z[16]
      // Return Type  : int
      //
      static int xzsteqr(double d[4], double e[3], double z[16])
      {
        double work[6];
        double c;
        double s;
        double tst;
        int i;
        int info;
        int jtot;
        int l1;
        info = 0;
        for (i = 0; i < 6; i++) {
          work[i] = 0.0;
        }

        jtot = 0;
        l1 = 1;
        int exitg1;
        do {
          exitg1 = 0;
          if (l1 > 4) {
            for (jtot = 0; jtot < 3; jtot++) {
              double p;
              int iscale;
              int ix;
              iscale = jtot;
              p = d[jtot];
              for (ix = jtot + 2; ix < 5; ix++) {
                c = d[ix - 1];
                if (c < p) {
                  iscale = ix - 1;
                  p = c;
                }
              }

              if (iscale != jtot) {
                d[iscale] = d[jtot];
                d[jtot] = p;
                ix = jtot << 2;
                iscale <<= 2;
                tst = z[ix];
                z[ix] = z[iscale];
                z[iscale] = tst;
                tst = z[ix + 1];
                z[ix + 1] = z[iscale + 1];
                z[iscale + 1] = tst;
                tst = z[ix + 2];
                z[ix + 2] = z[iscale + 2];
                z[iscale + 2] = tst;
                tst = z[ix + 3];
                z[ix + 3] = z[iscale + 3];
                z[iscale + 3] = tst;
              }
            }

            exitg1 = 1;
          } else {
            int l;
            int lend;
            int lendsv;
            int lsv;
            int m;
            bool exitg2;
            if (l1 > 1) {
              e[l1 - 2] = 0.0;
            }

            m = l1;
            exitg2 = false;
            while ((!exitg2) && (m < 4)) {
              tst = std::abs(e[m - 1]);
              if (tst == 0.0) {
                exitg2 = true;
              } else if (tst <= std::sqrt(std::abs(d[m - 1])) * std::sqrt(std::
                          abs(d[m])) * 2.2204460492503131E-16) {
                e[m - 1] = 0.0;
                exitg2 = true;
              } else {
                m++;
              }
            }

            l = l1 - 1;
            lsv = l1;
            lend = m;
            lendsv = m;
            l1 = m + 1;
            if (m != l + 1) {
              double anorm;
              int iscale;
              int ix;
              ix = m - l;
              if (ix <= 0) {
                anorm = 0.0;
              } else {
                anorm = std::abs(d[(l + ix) - 1]);
                i = 0;
                exitg2 = false;
                while ((!exitg2) && (i <= ix - 2)) {
                  iscale = l + i;
                  tst = std::abs(d[iscale]);
                  if (std::isnan(tst)) {
                    anorm = rtNaN;
                    exitg2 = true;
                  } else {
                    if (tst > anorm) {
                      anorm = tst;
                    }

                    tst = std::abs(e[iscale]);
                    if (std::isnan(tst)) {
                      anorm = rtNaN;
                      exitg2 = true;
                    } else {
                      if (tst > anorm) {
                        anorm = tst;
                      }

                      i++;
                    }
                  }
                }
              }

              iscale = 0;
              if (!(anorm == 0.0)) {
                if (std::isinf(anorm) || std::isnan(anorm)) {
                  d[0] = rtNaN;
                  d[1] = rtNaN;
                  d[2] = rtNaN;
                  d[3] = rtNaN;
                  for (ix = 0; ix < 16; ix++) {
                    z[ix] = rtNaN;
                  }

                  exitg1 = 1;
                } else {
                  if (anorm > 2.2346346549904327E+153) {
                    iscale = 1;
                    xzlascl(anorm, 2.2346346549904327E+153, ix, d, l + 1);
                    b_xzlascl(anorm, 2.2346346549904327E+153, ix - 1, e, l + 1);
                  } else if (anorm < 3.02546243347603E-123) {
                    iscale = 2;
                    xzlascl(anorm, 3.02546243347603E-123, ix, d, l + 1);
                    b_xzlascl(anorm, 3.02546243347603E-123, ix - 1, e, l + 1);
                  }

                  if (std::abs(d[m - 1]) < std::abs(d[l])) {
                    lend = lsv;
                    l = m - 1;
                  }

                  if (lend > l + 1) {
                    int exitg4;
                    do {
                      exitg4 = 0;
                      if (l + 1 != lend) {
                        m = l + 1;
                        exitg2 = false;
                        while ((!exitg2) && (m < lend)) {
                          tst = std::abs(e[m - 1]);
                          if (tst * tst <= 4.9303806576313238E-32 * std::abs(d[m
                               - 1]) * std::abs(d[m]) + 2.2250738585072014E-308)
                          {
                            exitg2 = true;
                          } else {
                            m++;
                          }
                        }
                      } else {
                        m = lend;
                      }

                      if (m < lend) {
                        e[m - 1] = 0.0;
                      }

                      if (m == l + 1) {
                        l++;
                        if (l + 1 > lend) {
                          exitg4 = 1;
                        }
                      } else if (m == l + 2) {
                        d[l] = xdlaev2(d[l], e[l], d[l + 1], c, work[l], tst);
                        d[l + 1] = c;
                        work[l + 3] = tst;
                        rotateRight(2, z, (l << 2) + 1, work, l + 1, l + 4);
                        e[l] = 0.0;
                        l += 2;
                        if (l + 1 > lend) {
                          exitg4 = 1;
                        }
                      } else if (jtot == 120) {
                        exitg4 = 1;
                      } else {
                        double b;
                        double g;
                        double p;
                        jtot++;
                        g = (d[l + 1] - d[l]) / (2.0 * e[l]);
                        tst = std::abs(g);
                        if (tst < 1.0) {
                          tst = std::sqrt(tst * tst + 1.0);
                        } else if (tst > 1.0) {
                          b = 1.0 / tst;
                          tst *= std::sqrt(b * b + 1.0);
                        } else {
                          tst *= 1.4142135623730951;
                        }

                        if (!(g >= 0.0)) {
                          tst = -tst;
                        }

                        g = (d[m - 1] - d[l]) + e[l] / (g + tst);
                        tst = 1.0;
                        c = 1.0;
                        p = 0.0;
                        ix = m - 1;
                        for (i = ix; i >= l + 1; i--) {
                          double r;
                          r = e[i - 1];
                          b = c * r;
                          c = xzlartg(g, tst * r, s, r);
                          tst = s;
                          if (i != m - 1) {
                            e[i] = r;
                          }

                          g = d[i] - p;
                          r = (d[i - 1] - g) * s + 2.0 * c * b;
                          p = s * r;
                          d[i] = g + p;
                          g = c * r - b;
                          work[i - 1] = c;
                          work[i + 2] = -s;
                        }

                        rotateRight(m - l, z, (l << 2) + 1, work, l + 1, l + 4);
                        d[l] -= p;
                        e[l] = g;
                      }
                    } while (exitg4 == 0);
                  } else {
                    int exitg3;
                    do {
                      exitg3 = 0;
                      if (l + 1 != lend) {
                        m = l + 1;
                        exitg2 = false;
                        while ((!exitg2) && (m > lend)) {
                          tst = std::abs(e[m - 2]);
                          if (tst * tst <= 4.9303806576313238E-32 * std::abs(d[m
                               - 1]) * std::abs(d[m - 2]) +
                              2.2250738585072014E-308) {
                            exitg2 = true;
                          } else {
                            m--;
                          }
                        }
                      } else {
                        m = lend;
                      }

                      if (m > lend) {
                        e[m - 2] = 0.0;
                      }

                      if (m == l + 1) {
                        l--;
                        if (l + 1 < lend) {
                          exitg3 = 1;
                        }
                      } else if (m == l) {
                        d[l - 1] = xdlaev2(d[l - 1], e[l - 1], d[l], c, work[m -
                                           1], tst);
                        d[l] = c;
                        work[m + 2] = tst;
                        b_rotateRight(2, z, ((l - 1) << 2) + 1, work, m, m + 3);
                        e[l - 1] = 0.0;
                        l -= 2;
                        if (l + 1 < lend) {
                          exitg3 = 1;
                        }
                      } else if (jtot == 120) {
                        exitg3 = 1;
                      } else {
                        double b;
                        double g;
                        double p;
                        jtot++;
                        c = e[l - 1];
                        g = (d[l - 1] - d[l]) / (2.0 * c);
                        tst = std::abs(g);
                        if (tst < 1.0) {
                          tst = std::sqrt(tst * tst + 1.0);
                        } else if (tst > 1.0) {
                          b = 1.0 / tst;
                          tst *= std::sqrt(b * b + 1.0);
                        } else {
                          tst *= 1.4142135623730951;
                        }

                        if (!(g >= 0.0)) {
                          tst = -tst;
                        }

                        g = (d[m - 1] - d[l]) + c / (g + tst);
                        tst = 1.0;
                        c = 1.0;
                        p = 0.0;
                        for (i = m; i <= l; i++) {
                          double r;
                          r = e[i - 1];
                          b = c * r;
                          c = xzlartg(g, tst * r, s, r);
                          tst = s;
                          if (i != m) {
                            e[i - 2] = r;
                          }

                          g = d[i - 1] - p;
                          r = (d[i] - g) * s + 2.0 * c * b;
                          p = s * r;
                          d[i - 1] = g + p;
                          g = c * r - b;
                          work[i - 1] = c;
                          work[i + 2] = s;
                        }

                        b_rotateRight((l - m) + 2, z, ((m - 1) << 2) + 1, work,
                                      m, m + 3);
                        d[l] -= p;
                        e[l - 1] = g;
                      }
                    } while (exitg3 == 0);
                  }

                  if (iscale == 1) {
                    ix = lendsv - lsv;
                    xzlascl(2.2346346549904327E+153, anorm, ix + 1, d, lsv);
                    b_xzlascl(2.2346346549904327E+153, anorm, ix, e, lsv);
                  } else if (iscale == 2) {
                    ix = lendsv - lsv;
                    xzlascl(3.02546243347603E-123, anorm, ix + 1, d, lsv);
                    b_xzlascl(3.02546243347603E-123, anorm, ix, e, lsv);
                  }

                  if (jtot >= 120) {
                    if (e[0] != 0.0) {
                      info = 1;
                    }

                    if (e[1] != 0.0) {
                      info++;
                    }

                    if (e[2] != 0.0) {
                      info++;
                    }

                    exitg1 = 1;
                  }
                }
              }
            }
          }
        } while (exitg1 == 0);

        return info;
      }

      //
      // Arguments    : array<double, 2U> &A
      //                array<double, 1U> &S
      // Return Type  : void
      //
      static void xzsvdc(array<double, 2U> &A, array<double, 1U> &S)
      {
        array<double, 1U> e;
        array<double, 1U> s;
        array<double, 1U> work;
        double anrm;
        double cscale;
        double rt;
        double sm;
        int i;
        int m;
        int minnp;
        int mm;
        int ns;
        int qq;
        bool doscale;
        mm = A.size(0);
        m = A.size(1);
        if (A.size(0) + 1 <= A.size(1)) {
          ns = A.size(0);
        } else {
          ns = A.size(1) - 1;
        }

        qq = A.size(0);
        minnp = A.size(1);
        if (qq <= minnp) {
          minnp = qq;
        }

        s.set_size(ns + 1);
        for (i = 0; i <= ns; i++) {
          s[i] = 0.0;
        }

        e.set_size(A.size(1));
        for (i = 0; i < m; i++) {
          e[i] = 0.0;
        }

        work.set_size(A.size(0));
        for (i = 0; i < mm; i++) {
          work[i] = 0.0;
        }

        doscale = false;
        cscale = 0.0;
        anrm = xzlangeM(A);
        if ((A.size(0) != 0) && (A.size(1) != 0)) {
          double nrm;
          double r;
          double snorm;
          int ii;
          int jj;
          int nct;
          int nmq;
          int nrt;
          int qp1;
          cscale = anrm;
          if ((anrm > 0.0) && (anrm < 6.7178761075670888E-139)) {
            doscale = true;
            cscale = 6.7178761075670888E-139;
            xzlascl(anrm, cscale, A.size(0), A.size(1), A, A.size(0));
          } else if (anrm > 1.4885657073574029E+138) {
            doscale = true;
            cscale = 1.4885657073574029E+138;
            xzlascl(anrm, cscale, A.size(0), A.size(1), A, A.size(0));
          }

          if (A.size(1) >= 2) {
            qq = A.size(1) - 2;
          } else {
            qq = 0;
          }

          nrt = A.size(0);
          if (qq <= nrt) {
            nrt = qq;
          }

          if (A.size(0) >= 1) {
            qq = A.size(0) - 1;
          } else {
            qq = 0;
          }

          nct = A.size(1);
          if (qq <= nct) {
            nct = qq;
          }

          if (nct >= nrt) {
            i = nct;
          } else {
            i = nrt;
          }

          for (int q{0}; q < i; q++) {
            bool apply_transform;
            qp1 = q + 2;
            qq = (q + mm * q) + 1;
            nmq = (mm - q) - 1;
            apply_transform = false;
            if (q + 1 <= nct) {
              nrm = blas::xnrm2(nmq + 1, A, qq);
              if (nrm > 0.0) {
                apply_transform = true;
                if (A[qq - 1] < 0.0) {
                  nrm = -nrm;
                }

                s[q] = nrm;
                if (std::abs(nrm) >= 1.0020841800044864E-292) {
                  nrm = 1.0 / nrm;
                  ns = qq + nmq;
                  for (int k{qq}; k <= ns; k++) {
                    A[k - 1] = nrm * A[k - 1];
                  }
                } else {
                  ns = qq + nmq;
                  for (int k{qq}; k <= ns; k++) {
                    A[k - 1] = A[k - 1] / s[q];
                  }
                }

                A[qq - 1] = A[qq - 1] + 1.0;
                s[q] = -s[q];
              } else {
                s[q] = 0.0;
              }
            }

            for (jj = qp1; jj <= m; jj++) {
              ns = q + mm * (jj - 1);
              if (apply_transform) {
                nrm = 0.0;
                if (nmq + 1 >= 1) {
                  for (int k{0}; k <= nmq; k++) {
                    nrm += A[(qq + k) - 1] * A[ns + k];
                  }
                }

                nrm = -(nrm / A[q + A.size(0) * q]);
                blas::xaxpy(nmq + 1, nrm, qq, A, ns + 1);
              }

              e[jj - 1] = A[ns];
            }

            if (q + 1 <= nrt) {
              ns = m - q;
              nrm = blas::xnrm2(ns - 1, e, q + 2);
              if (nrm == 0.0) {
                e[q] = 0.0;
              } else {
                if (e[q + 1] < 0.0) {
                  e[q] = -nrm;
                } else {
                  e[q] = nrm;
                }

                nrm = e[q];
                if (std::abs(e[q]) >= 1.0020841800044864E-292) {
                  nrm = 1.0 / e[q];
                  ns += q;
                  for (int k{qp1}; k <= ns; k++) {
                    e[k - 1] = nrm * e[k - 1];
                  }
                } else {
                  ns += q;
                  for (int k{qp1}; k <= ns; k++) {
                    e[k - 1] = e[k - 1] / nrm;
                  }
                }

                e[q + 1] = e[q + 1] + 1.0;
                e[q] = -e[q];
                if (q + 2 <= mm) {
                  for (ii = qp1; ii <= mm; ii++) {
                    work[ii - 1] = 0.0;
                  }

                  for (jj = qp1; jj <= m; jj++) {
                    blas::xaxpy(nmq, e[jj - 1], A, (q + mm * (jj - 1)) + 2, work,
                                q + 2);
                  }

                  for (jj = qp1; jj <= m; jj++) {
                    blas::xaxpy(nmq, -e[jj - 1] / e[q + 1], work, q + 2, A, (q +
                      mm * (jj - 1)) + 2);
                  }
                }
              }
            }
          }

          qq = A.size(1);
          m = A.size(0) + 1;
          if (qq <= m) {
            m = qq;
          }

          if (nct < A.size(1)) {
            s[nct] = A[nct + A.size(0) * nct];
          }

          if (A.size(0) < m) {
            s[m - 1] = 0.0;
          }

          if (nrt + 1 < m) {
            e[nrt] = A[nrt + A.size(0) * (m - 1)];
          }

          e[m - 1] = 0.0;
          mm = m;
          nmq = 0;
          snorm = 0.0;
          for (int q{0}; q < m; q++) {
            nrm = s[q];
            if (s[q] != 0.0) {
              rt = std::abs(s[q]);
              r = s[q] / rt;
              nrm = rt;
              s[q] = rt;
              if (q + 1 < m) {
                e[q] = e[q] / r;
              }
            }

            if ((q + 1 < m) && (e[q] != 0.0)) {
              rt = std::abs(e[q]);
              r = rt / e[q];
              e[q] = rt;
              s[q + 1] = s[q + 1] * r;
            }

            snorm = std::fmax(snorm, std::fmax(std::abs(nrm), std::abs(e[q])));
          }

          while ((m > 0) && (nmq < 75)) {
            bool exitg1;
            jj = m - 1;
            ii = m - 1;
            exitg1 = false;
            while (!(exitg1 || (ii == 0))) {
              nrm = std::abs(e[ii - 1]);
              if ((nrm <= 2.2204460492503131E-16 * (std::abs(s[ii - 1]) + std::
                    abs(s[ii]))) || (nrm <= 1.0020841800044864E-292) || ((nmq >
                    20) && (nrm <= 2.2204460492503131E-16 * snorm))) {
                e[ii - 1] = 0.0;
                exitg1 = true;
              } else {
                ii--;
              }
            }

            if (ii == m - 1) {
              ns = 4;
            } else {
              qq = m;
              ns = m;
              exitg1 = false;
              while ((!exitg1) && (ns >= ii)) {
                qq = ns;
                if (ns == ii) {
                  exitg1 = true;
                } else {
                  nrm = 0.0;
                  if (ns < m) {
                    nrm = std::abs(e[ns - 1]);
                  }

                  if (ns > ii + 1) {
                    nrm += std::abs(e[ns - 2]);
                  }

                  rt = std::abs(s[ns - 1]);
                  if ((rt <= 2.2204460492503131E-16 * nrm) || (rt <=
                       1.0020841800044864E-292)) {
                    s[ns - 1] = 0.0;
                    exitg1 = true;
                  } else {
                    ns--;
                  }
                }
              }

              if (qq == ii) {
                ns = 3;
              } else if (qq == m) {
                ns = 1;
              } else {
                ns = 2;
                ii = qq;
              }
            }

            switch (ns) {
             case 1:
              {
                rt = e[m - 2];
                e[m - 2] = 0.0;
                for (int k{jj}; k >= ii + 1; k--) {
                  double sqds;
                  sqds = blas::xrotg(&s[k - 1], rt, sm);
                  if (k > ii + 1) {
                    r = e[k - 2];
                    rt = -sm * r;
                    e[k - 2] = r * sqds;
                  }
                }
              }
              break;

             case 2:
              {
                rt = e[ii - 1];
                e[ii - 1] = 0.0;
                for (int k{ii + 1}; k <= m; k++) {
                  double sqds;
                  sqds = blas::xrotg(&s[k - 1], rt, sm);
                  r = e[k - 1];
                  rt = -sm * r;
                  e[k - 1] = r * sqds;
                }
              }
              break;

             case 3:
              {
                double scale;
                double sqds;
                nrm = s[m - 1];
                rt = s[m - 2];
                r = e[m - 2];
                scale = std::fmax(std::fmax(std::fmax(std::fmax(std::abs(nrm),
                  std::abs(rt)), std::abs(r)), std::abs(s[ii])), std::abs(e[ii]));
                sm = nrm / scale;
                nrm = rt / scale;
                rt = r / scale;
                sqds = s[ii] / scale;
                r = ((nrm + sm) * (nrm - sm) + rt * rt) / 2.0;
                nrm = sm * rt;
                nrm *= nrm;
                if ((r != 0.0) || (nrm != 0.0)) {
                  rt = std::sqrt(r * r + nrm);
                  if (r < 0.0) {
                    rt = -rt;
                  }

                  rt = nrm / (r + rt);
                } else {
                  rt = 0.0;
                }

                rt += (sqds + sm) * (sqds - sm);
                nrm = sqds * (e[ii] / scale);
                for (int k{ii + 1}; k < m; k++) {
                  sqds = blas::xrotg(&rt, nrm, sm);
                  if (k > ii + 1) {
                    e[k - 2] = rt;
                  }

                  r = e[k - 1];
                  nrm = s[k - 1];
                  e[k - 1] = sqds * r - sm * nrm;
                  rt = sm * s[k];
                  s[k] = s[k] * sqds;
                  s[k - 1] = sqds * nrm + sm * r;
                  sqds = blas::xrotg(&s[k - 1], rt, sm);
                  r = e[k - 1];
                  rt = sqds * r + sm * s[k];
                  s[k] = -sm * r + sqds * s[k];
                  nrm = sm * e[k];
                  e[k] = e[k] * sqds;
                }

                e[m - 2] = rt;
                nmq++;
              }
              break;

             default:
              if (s[ii] < 0.0) {
                s[ii] = -s[ii];
              }

              qp1 = ii + 1;
              while ((ii + 1 < mm) && (s[ii] < s[qp1])) {
                rt = s[ii];
                s[ii] = s[qp1];
                s[qp1] = rt;
                ii = qp1;
                qp1++;
              }

              nmq = 0;
              m--;
              break;
            }
          }
        }

        S.set_size(minnp);
        for (int k{0}; k < minnp; k++) {
          S[k] = s[k];
        }

        if (doscale) {
          xzlascl(cscale, anrm, minnp, S);
        }
      }

      //
      // Arguments    : int ilo
      //                int ihi
      //                double A[16]
      //                const double tau[3]
      // Return Type  : void
      //
      static void xzunghr(int ilo, int ihi, double A[16], const double tau[3])
      {
        int a;
        int i;
        int ia;
        int ia0;
        int itau;
        int nh;
        nh = ihi - ilo;
        a = ilo + 1;
        for (int j{ihi}; j >= a; j--) {
          ia = (j - 1) << 2;
          i = static_cast<unsigned char>(j - 1);
          std::memset(&A[ia], 0, static_cast<unsigned int>(i) * sizeof(double));
          i = j + 1;
          for (int b_i{i}; b_i <= ihi; b_i++) {
            itau = ia + b_i;
            A[itau - 1] = A[itau - 5];
          }

          i = ihi + 1;
          if (i <= 4) {
            std::memset(&A[(i + ia) + -1], 0, static_cast<unsigned int>(((ia - i)
              - ia) + 5) * sizeof(double));
          }
        }

        i = static_cast<unsigned char>(ilo);
        for (int j{0}; j < i; j++) {
          ia = j << 2;
          A[ia] = 0.0;
          A[ia + 1] = 0.0;
          A[ia + 2] = 0.0;
          A[ia + 3] = 0.0;
          A[ia + j] = 1.0;
        }

        i = ihi + 1;
        for (int j{i}; j < 5; j++) {
          ia = (j - 1) << 2;
          A[ia] = 0.0;
          A[ia + 1] = 0.0;
          A[ia + 2] = 0.0;
          A[ia + 3] = 0.0;
          A[(ia + j) - 1] = 1.0;
        }

        ia0 = ilo + (ilo << 2);
        if (nh >= 1) {
          double work[4];
          for (int j{nh}; j < nh; j++) {
            ia = ia0 + (j << 2);
            std::memset(&A[ia], 0, static_cast<unsigned int>(nh) * sizeof(double));
            A[ia + j] = 1.0;
          }

          itau = (ilo + nh) - 2;
          work[0] = 0.0;
          work[1] = 0.0;
          work[2] = 0.0;
          work[3] = 0.0;
          for (int b_i{nh}; b_i >= 1; b_i--) {
            ia = (ia0 + b_i) + ((b_i - 1) << 2);
            if (b_i < nh) {
              A[ia - 1] = 1.0;
              i = nh - b_i;
              xzlarf(i + 1, i, ia, tau[itau], A, ia + 4, work);
              a = ia + 1;
              i = (ia + nh) - b_i;
              for (int j{a}; j <= i; j++) {
                A[j - 1] *= -tau[itau];
              }
            }

            A[ia - 1] = 1.0 - tau[itau];
            i = static_cast<unsigned char>(b_i - 1);
            for (int j{0}; j < i; j++) {
              A[(ia - j) - 2] = 0.0;
            }

            itau--;
          }
        }
      }

      //
      // Arguments    : double y
      //                double x
      // Return Type  : double
      //
    }

    namespace scalar
    {
      static double b_atan2(double y, double x)
      {
        double r;
        if (std::isnan(y) || std::isnan(x)) {
          r = rtNaN;
        } else if (std::isinf(y) && std::isinf(x)) {
          int i;
          int i1;
          if (y > 0.0) {
            i = 1;
          } else {
            i = -1;
          }

          if (x > 0.0) {
            i1 = 1;
          } else {
            i1 = -1;
          }

          r = std::atan2(static_cast<double>(i), static_cast<double>(i1));
        } else if (x == 0.0) {
          if (y > 0.0) {
            r = RT_PI / 2.0;
          } else if (y < 0.0) {
            r = -(RT_PI / 2.0);
          } else {
            r = 0.0;
          }
        } else {
          r = std::atan2(y, x);
        }

        return r;
      }

      //
      // Arguments    : creal_T &x
      // Return Type  : void
      //
      static void b_sqrt(creal_T &x)
      {
        double absxd2;
        double absxi;
        double xi;
        double xr;
        xr = x.re;
        xi = x.im;
        if (xi == 0.0) {
          if (xr < 0.0) {
            absxi = 0.0;
            absxd2 = std::sqrt(-xr);
          } else {
            absxi = std::sqrt(xr);
            absxd2 = 0.0;
          }
        } else if (xr == 0.0) {
          if (xi < 0.0) {
            absxi = std::sqrt(-xi / 2.0);
            absxd2 = -absxi;
          } else {
            absxi = std::sqrt(xi / 2.0);
            absxd2 = absxi;
          }
        } else if (std::isnan(xr)) {
          absxi = rtNaN;
          absxd2 = rtNaN;
        } else if (std::isnan(xi)) {
          absxi = rtNaN;
          absxd2 = rtNaN;
        } else if (std::isinf(xi)) {
          absxi = std::abs(xi);
          absxd2 = xi;
        } else if (std::isinf(xr)) {
          if (xr < 0.0) {
            absxi = 0.0;
            absxd2 = xi * -xr;
          } else {
            absxi = xr;
            absxd2 = 0.0;
          }
        } else {
          double absxr;
          absxr = std::abs(xr);
          absxi = std::abs(xi);
          if ((absxr > 4.4942328371557893E+307) || (absxi >
               4.4942328371557893E+307)) {
            absxr *= 0.5;
            absxd2 = absxi * 0.5;
            if (absxr < absxd2) {
              double a;
              a = absxr / absxd2;
              absxd2 *= std::sqrt(a * a + 1.0);
            } else if (absxr > absxd2) {
              absxd2 /= absxr;
              absxd2 = absxr * std::sqrt(absxd2 * absxd2 + 1.0);
            } else {
              absxd2 = absxr * 1.4142135623730951;
            }

            if (absxd2 > absxr) {
              absxi = std::sqrt(absxd2) * std::sqrt(absxr / absxd2 + 1.0);
            } else {
              absxi = std::sqrt(absxd2) * 1.4142135623730951;
            }
          } else {
            if (absxr < absxi) {
              double a;
              a = absxr / absxi;
              absxd2 = absxi * std::sqrt(a * a + 1.0);
            } else if (absxr > absxi) {
              absxd2 = absxi / absxr;
              absxd2 = absxr * std::sqrt(absxd2 * absxd2 + 1.0);
            } else {
              absxd2 = absxr * 1.4142135623730951;
            }

            absxi = std::sqrt((absxd2 + absxr) * 0.5);
          }

          if (xr > 0.0) {
            absxd2 = 0.5 * (xi / absxi);
          } else {
            if (xi < 0.0) {
              absxd2 = -absxi;
            } else {
              absxd2 = absxi;
            }

            absxi = 0.5 * (xi / absxd2);
          }
        }

        x.re = absxi;
        x.im = absxd2;
      }

      //
      // Arguments    : double x_data[]
      //                const int x_size[2]
      // Return Type  : void
      //
    }

    static void sort(double x_data[], const int x_size[2])
    {
      int idx_data[26];
      int loop_ub;
      loop_ub = x_size[1];
      if (loop_ub - 1 >= 0) {
        std::memset(&idx_data[0], 0, static_cast<unsigned int>(loop_ub) * sizeof
                    (int));
      }

      if (x_size[1] != 0) {
        double xwork_data[26];
        double x4[4];
        int iwork_data[26];
        int i;
        int i1;
        int i2;
        int i3;
        int i4;
        int ib;
        int nNaNs;
        int quartetOffset;
        int wOffset_tmp;
        signed char idx4[4];
        x4[0] = 0.0;
        idx4[0] = 0;
        x4[1] = 0.0;
        idx4[1] = 0;
        x4[2] = 0.0;
        idx4[2] = 0;
        x4[3] = 0.0;
        idx4[3] = 0;
        nNaNs = 0;
        ib = 0;
        for (int k{0}; k < loop_ub; k++) {
          iwork_data[k] = 0;
          if (std::isnan(x_data[k])) {
            i4 = (loop_ub - nNaNs) - 1;
            idx_data[i4] = k + 1;
            xwork_data[i4] = x_data[k];
            nNaNs++;
          } else {
            ib++;
            idx4[ib - 1] = static_cast<signed char>(k + 1);
            x4[ib - 1] = x_data[k];
            if (ib == 4) {
              double d;
              double d1;
              quartetOffset = k - nNaNs;
              if (x4[0] <= x4[1]) {
                ib = 1;
                i2 = 2;
              } else {
                ib = 2;
                i2 = 1;
              }

              if (x4[2] <= x4[3]) {
                i3 = 3;
                i4 = 4;
              } else {
                i3 = 4;
                i4 = 3;
              }

              d = x4[ib - 1];
              d1 = x4[i3 - 1];
              if (d <= d1) {
                d = x4[i2 - 1];
                if (d <= d1) {
                  i = ib;
                  i1 = i2;
                  ib = i3;
                  i2 = i4;
                } else if (d <= x4[i4 - 1]) {
                  i = ib;
                  i1 = i3;
                  ib = i2;
                  i2 = i4;
                } else {
                  i = ib;
                  i1 = i3;
                  ib = i4;
                }
              } else {
                d1 = x4[i4 - 1];
                if (d <= d1) {
                  if (x4[i2 - 1] <= d1) {
                    i = i3;
                    i1 = ib;
                    ib = i2;
                    i2 = i4;
                  } else {
                    i = i3;
                    i1 = ib;
                    ib = i4;
                  }
                } else {
                  i = i3;
                  i1 = i4;
                }
              }

              idx_data[quartetOffset - 3] = idx4[i - 1];
              idx_data[quartetOffset - 2] = idx4[i1 - 1];
              idx_data[quartetOffset - 1] = idx4[ib - 1];
              idx_data[quartetOffset] = idx4[i2 - 1];
              x_data[quartetOffset - 3] = x4[i - 1];
              x_data[quartetOffset - 2] = x4[i1 - 1];
              x_data[quartetOffset - 1] = x4[ib - 1];
              x_data[quartetOffset] = x4[i2 - 1];
              ib = 0;
            }
          }
        }

        wOffset_tmp = x_size[1] - nNaNs;
        if (ib > 0) {
          signed char perm[4];
          perm[1] = 0;
          perm[2] = 0;
          perm[3] = 0;
          if (ib == 1) {
            perm[0] = 1;
          } else if (ib == 2) {
            if (x4[0] <= x4[1]) {
              perm[0] = 1;
              perm[1] = 2;
            } else {
              perm[0] = 2;
              perm[1] = 1;
            }
          } else if (x4[0] <= x4[1]) {
            if (x4[1] <= x4[2]) {
              perm[0] = 1;
              perm[1] = 2;
              perm[2] = 3;
            } else if (x4[0] <= x4[2]) {
              perm[0] = 1;
              perm[1] = 3;
              perm[2] = 2;
            } else {
              perm[0] = 3;
              perm[1] = 1;
              perm[2] = 2;
            }
          } else if (x4[0] <= x4[2]) {
            perm[0] = 2;
            perm[1] = 1;
            perm[2] = 3;
          } else if (x4[1] <= x4[2]) {
            perm[0] = 2;
            perm[1] = 3;
            perm[2] = 1;
          } else {
            perm[0] = 3;
            perm[1] = 2;
            perm[2] = 1;
          }

          i = static_cast<unsigned char>(ib);
          for (int k{0}; k < i; k++) {
            i4 = (wOffset_tmp - ib) + k;
            i1 = perm[k];
            idx_data[i4] = idx4[i1 - 1];
            x_data[i4] = x4[i1 - 1];
          }
        }

        i2 = nNaNs >> 1;
        for (int k{0}; k < i2; k++) {
          quartetOffset = wOffset_tmp + k;
          i3 = idx_data[quartetOffset];
          i4 = (loop_ub - k) - 1;
          idx_data[quartetOffset] = idx_data[i4];
          idx_data[i4] = i3;
          x_data[quartetOffset] = xwork_data[i4];
          x_data[i4] = xwork_data[quartetOffset];
        }

        if ((static_cast<unsigned int>(nNaNs) & 1U) != 0U) {
          i = wOffset_tmp + i2;
          x_data[i] = xwork_data[i];
        }

        if (wOffset_tmp > 1) {
          i3 = wOffset_tmp >> 2;
          quartetOffset = 4;
          while (i3 > 1) {
            if ((static_cast<unsigned int>(i3) & 1U) != 0U) {
              i3--;
              ib = quartetOffset * i3;
              i2 = wOffset_tmp - ib;
              if (i2 > quartetOffset) {
                merge(idx_data, x_data, ib, quartetOffset, i2 - quartetOffset,
                      iwork_data, xwork_data);
              }
            }

            ib = quartetOffset << 1;
            i3 >>= 1;
            for (int k{0}; k < i3; k++) {
              merge(idx_data, x_data, k * ib, quartetOffset, quartetOffset,
                    iwork_data, xwork_data);
            }

            quartetOffset = ib;
          }

          if (wOffset_tmp > quartetOffset) {
            merge(idx_data, x_data, 0, quartetOffset, wOffset_tmp -
                  quartetOffset, iwork_data, xwork_data);
          }
        }
      }
    }

    //
    // Arguments    : double x[24]
    // Return Type  : void
    //
    static void sort(double x[24])
    {
      for (int j{0}; j < 12; j++) {
        double vwork_idx_0;
        double vwork_idx_1;
        vwork_idx_0 = x[j];
        vwork_idx_1 = x[j + 12];
        if ((!(vwork_idx_0 <= vwork_idx_1)) && (!std::isnan(vwork_idx_1))) {
          double tmp;
          tmp = vwork_idx_0;
          vwork_idx_0 = vwork_idx_1;
          vwork_idx_1 = tmp;
        }

        x[j] = vwork_idx_0;
        x[j + 12] = vwork_idx_1;
      }
    }

    //
    // Arguments    : array<double, 1U> &x
    //                array<int, 1U> &idx
    // Return Type  : void
    //
    static void sort(array<double, 1U> &x, array<int, 1U> &idx)
    {
      array<double, 1U> vwork;
      array<double, 1U> xwork;
      array<int, 1U> iidx;
      array<int, 1U> iwork;
      int dim;
      int i;
      int i1;
      int vstride;
      dim = 2;
      if (x.size(0) != 1) {
        dim = 1;
      }

      if (dim <= 1) {
        i = x.size(0);
      } else {
        i = 1;
      }

      vwork.set_size(i);
      idx.set_size(x.size(0));
      vstride = 1;
      i1 = dim - 2;
      for (int k{0}; k <= i1; k++) {
        vstride *= x.size(0);
      }

      for (int b_i{0}; b_i < 1; b_i++) {
        for (int j{0}; j < vstride; j++) {
          int bLen2;
          for (int k{0}; k < i; k++) {
            vwork[k] = x[j + k * vstride];
          }

          bLen2 = vwork.size(0);
          iidx.set_size(vwork.size(0));
          for (i1 = 0; i1 < bLen2; i1++) {
            iidx[i1] = 0;
          }

          if (vwork.size(0) != 0) {
            double x4[4];
            int idx4[4];
            int bLen;
            int b_i1;
            int i2;
            int i3;
            int i4;
            int iidx_tmp;
            int nBlocks;
            int wOffset_tmp;
            iwork.set_size(vwork.size(0));
            for (i1 = 0; i1 < bLen2; i1++) {
              iwork[i1] = 0;
            }

            xwork.set_size(vwork.size(0));
            x4[0] = 0.0;
            idx4[0] = 0;
            x4[1] = 0.0;
            idx4[1] = 0;
            x4[2] = 0.0;
            idx4[2] = 0;
            x4[3] = 0.0;
            idx4[3] = 0;
            nBlocks = 0;
            dim = 0;
            for (int k{0}; k < bLen2; k++) {
              if (std::isnan(vwork[k])) {
                iidx_tmp = (bLen2 - nBlocks) - 1;
                iidx[iidx_tmp] = k + 1;
                xwork[iidx_tmp] = vwork[k];
                nBlocks++;
              } else {
                dim++;
                idx4[dim - 1] = k + 1;
                x4[dim - 1] = vwork[k];
                if (dim == 4) {
                  double d;
                  double d1;
                  dim = k - nBlocks;
                  if (x4[0] <= x4[1]) {
                    b_i1 = 1;
                    i2 = 2;
                  } else {
                    b_i1 = 2;
                    i2 = 1;
                  }

                  if (x4[2] <= x4[3]) {
                    i3 = 3;
                    i4 = 4;
                  } else {
                    i3 = 4;
                    i4 = 3;
                  }

                  d = x4[b_i1 - 1];
                  d1 = x4[i3 - 1];
                  if (d <= d1) {
                    d = x4[i2 - 1];
                    if (d <= d1) {
                      i1 = b_i1;
                      bLen = i2;
                      b_i1 = i3;
                      i2 = i4;
                    } else if (d <= x4[i4 - 1]) {
                      i1 = b_i1;
                      bLen = i3;
                      b_i1 = i2;
                      i2 = i4;
                    } else {
                      i1 = b_i1;
                      bLen = i3;
                      b_i1 = i4;
                    }
                  } else {
                    d1 = x4[i4 - 1];
                    if (d <= d1) {
                      if (x4[i2 - 1] <= d1) {
                        i1 = i3;
                        bLen = b_i1;
                        b_i1 = i2;
                        i2 = i4;
                      } else {
                        i1 = i3;
                        bLen = b_i1;
                        b_i1 = i4;
                      }
                    } else {
                      i1 = i3;
                      bLen = i4;
                    }
                  }

                  iidx[dim - 3] = idx4[i1 - 1];
                  iidx[dim - 2] = idx4[bLen - 1];
                  iidx[dim - 1] = idx4[b_i1 - 1];
                  iidx[dim] = idx4[i2 - 1];
                  vwork[dim - 3] = x4[i1 - 1];
                  vwork[dim - 2] = x4[bLen - 1];
                  vwork[dim - 1] = x4[b_i1 - 1];
                  vwork[dim] = x4[i2 - 1];
                  dim = 0;
                }
              }
            }

            wOffset_tmp = vwork.size(0) - nBlocks;
            if (dim > 0) {
              signed char perm[4];
              perm[1] = 0;
              perm[2] = 0;
              perm[3] = 0;
              if (dim == 1) {
                perm[0] = 1;
              } else if (dim == 2) {
                if (x4[0] <= x4[1]) {
                  perm[0] = 1;
                  perm[1] = 2;
                } else {
                  perm[0] = 2;
                  perm[1] = 1;
                }
              } else if (x4[0] <= x4[1]) {
                if (x4[1] <= x4[2]) {
                  perm[0] = 1;
                  perm[1] = 2;
                  perm[2] = 3;
                } else if (x4[0] <= x4[2]) {
                  perm[0] = 1;
                  perm[1] = 3;
                  perm[2] = 2;
                } else {
                  perm[0] = 3;
                  perm[1] = 1;
                  perm[2] = 2;
                }
              } else if (x4[0] <= x4[2]) {
                perm[0] = 2;
                perm[1] = 1;
                perm[2] = 3;
              } else if (x4[1] <= x4[2]) {
                perm[0] = 2;
                perm[1] = 3;
                perm[2] = 1;
              } else {
                perm[0] = 3;
                perm[1] = 2;
                perm[2] = 1;
              }

              i1 = static_cast<unsigned char>(dim);
              for (int k{0}; k < i1; k++) {
                iidx_tmp = (wOffset_tmp - dim) + k;
                bLen = perm[k];
                iidx[iidx_tmp] = idx4[bLen - 1];
                vwork[iidx_tmp] = x4[bLen - 1];
              }
            }

            dim = nBlocks >> 1;
            for (int k{0}; k < dim; k++) {
              b_i1 = wOffset_tmp + k;
              i2 = iidx[b_i1];
              iidx_tmp = (bLen2 - k) - 1;
              iidx[b_i1] = iidx[iidx_tmp];
              iidx[iidx_tmp] = i2;
              vwork[b_i1] = xwork[iidx_tmp];
              vwork[iidx_tmp] = xwork[b_i1];
            }

            if ((static_cast<unsigned int>(nBlocks) & 1U) != 0U) {
              dim += wOffset_tmp;
              vwork[dim] = xwork[dim];
            }

            dim = 2;
            if (wOffset_tmp > 1) {
              if (vwork.size(0) >= 256) {
                nBlocks = wOffset_tmp >> 8;
                if (nBlocks > 0) {
                  for (int b{0}; b < nBlocks; b++) {
                    double b_xwork[256];
                    int b_iwork[256];
                    i4 = (b << 8) - 1;
                    for (int b_b{0}; b_b < 6; b_b++) {
                      bLen = 1 << (b_b + 2);
                      bLen2 = bLen << 1;
                      i1 = 256 >> (b_b + 3);
                      for (int k{0}; k < i1; k++) {
                        i2 = (i4 + k * bLen2) + 1;
                        for (b_i1 = 0; b_i1 < bLen2; b_i1++) {
                          dim = i2 + b_i1;
                          b_iwork[b_i1] = iidx[dim];
                          b_xwork[b_i1] = vwork[dim];
                        }

                        i3 = 0;
                        b_i1 = bLen;
                        dim = i2 - 1;
                        int exitg1;
                        do {
                          exitg1 = 0;
                          dim++;
                          if (b_xwork[i3] <= b_xwork[b_i1]) {
                            iidx[dim] = b_iwork[i3];
                            vwork[dim] = b_xwork[i3];
                            if (i3 + 1 < bLen) {
                              i3++;
                            } else {
                              exitg1 = 1;
                            }
                          } else {
                            iidx[dim] = b_iwork[b_i1];
                            vwork[dim] = b_xwork[b_i1];
                            if (b_i1 + 1 < bLen2) {
                              b_i1++;
                            } else {
                              dim -= i3;
                              for (b_i1 = i3 + 1; b_i1 <= bLen; b_i1++) {
                                iidx_tmp = dim + b_i1;
                                iidx[iidx_tmp] = b_iwork[b_i1 - 1];
                                vwork[iidx_tmp] = b_xwork[b_i1 - 1];
                              }

                              exitg1 = 1;
                            }
                          }
                        } while (exitg1 == 0);
                      }
                    }
                  }

                  dim = nBlocks << 8;
                  b_i1 = wOffset_tmp - dim;
                  if (b_i1 > 0) {
                    merge_block(iidx, vwork, dim, b_i1, 2, iwork, xwork);
                  }

                  dim = 8;
                }
              }

              merge_block(iidx, vwork, 0, wOffset_tmp, dim, iwork, xwork);
            }
          }

          for (int k{0}; k < i; k++) {
            i1 = j + k * vstride;
            x[i1] = vwork[k];
            idx[i1] = iidx[k];
          }
        }
      }
    }

    //
    // Arguments    : const double A[9]
    //                double U[9]
    //                double s[3]
    //                double V[9]
    // Return Type  : void
    //
    static void svd(const double A[9], double U[9], double s[3], double V[9])
    {
      double b_A[9];
      double e[3];
      double work[3];
      double anrm;
      double cscale;
      double nrm;
      double rt;
      double snorm;
      double sqds;
      int ii;
      int kase;
      int m;
      int qjj;
      int qp1;
      int qq;
      int qq_tmp;
      bool doscale;
      s[0] = 0.0;
      e[0] = 0.0;
      work[0] = 0.0;
      s[1] = 0.0;
      e[1] = 0.0;
      work[1] = 0.0;
      s[2] = 0.0;
      e[2] = 0.0;
      work[2] = 0.0;
      for (qjj = 0; qjj < 9; qjj++) {
        b_A[qjj] = A[qjj];
        U[qjj] = 0.0;
        V[qjj] = 0.0;
      }

      doscale = false;
      anrm = reflapack::xzlangeM(A);
      cscale = anrm;
      if ((anrm > 0.0) && (anrm < 6.7178761075670888E-139)) {
        doscale = true;
        cscale = 6.7178761075670888E-139;
        reflapack::b_xzlascl(anrm, cscale, b_A);
      } else if (anrm > 1.4885657073574029E+138) {
        doscale = true;
        cscale = 1.4885657073574029E+138;
        reflapack::b_xzlascl(anrm, cscale, b_A);
      }

      for (int q{0}; q < 2; q++) {
        bool apply_transform;
        qp1 = q + 2;
        qq_tmp = q + 3 * q;
        qq = qq_tmp + 1;
        apply_transform = false;
        nrm = blas::b_xnrm2(3 - q, b_A, qq_tmp + 1);
        if (nrm > 0.0) {
          apply_transform = true;
          if (b_A[qq_tmp] < 0.0) {
            nrm = -nrm;
          }

          s[q] = nrm;
          if (std::abs(nrm) >= 1.0020841800044864E-292) {
            nrm = 1.0 / nrm;
            qjj = (qq_tmp - q) + 3;
            for (int k{qq}; k <= qjj; k++) {
              b_A[k - 1] *= nrm;
            }
          } else {
            qjj = (qq_tmp - q) + 3;
            for (int k{qq}; k <= qjj; k++) {
              b_A[k - 1] /= s[q];
            }
          }

          b_A[qq_tmp]++;
          s[q] = -s[q];
        } else {
          s[q] = 0.0;
        }

        for (kase = qp1; kase < 4; kase++) {
          qjj = q + 3 * (kase - 1);
          if (apply_transform) {
            blas::xaxpy(3 - q, -(blas::xdotc(3 - q, b_A, qq_tmp + 1, b_A, qjj +
              1) / b_A[qq_tmp]), qq_tmp + 1, b_A, qjj + 1);
          }

          e[kase - 1] = b_A[qjj];
        }

        for (ii = q + 1; ii < 4; ii++) {
          kase = (ii + 3 * q) - 1;
          U[kase] = b_A[kase];
        }

        if (q + 1 <= 1) {
          nrm = blas::xnrm2(e);
          if (nrm == 0.0) {
            e[0] = 0.0;
          } else {
            if (e[1] < 0.0) {
              e[0] = -nrm;
            } else {
              e[0] = nrm;
            }

            nrm = e[0];
            if (std::abs(e[0]) >= 1.0020841800044864E-292) {
              nrm = 1.0 / e[0];
              for (int k{qp1}; k < 4; k++) {
                e[k - 1] *= nrm;
              }
            } else {
              for (int k{qp1}; k < 4; k++) {
                e[k - 1] /= nrm;
              }
            }

            e[1]++;
            e[0] = -e[0];
            for (ii = qp1; ii < 4; ii++) {
              work[ii - 1] = 0.0;
            }

            for (kase = qp1; kase < 4; kase++) {
              blas::xaxpy(e[kase - 1], b_A, 3 * (kase - 1) + 2, work);
            }

            for (kase = qp1; kase < 4; kase++) {
              blas::xaxpy(-e[kase - 1] / e[1], work, b_A, 3 * (kase - 1) + 2);
            }
          }

          for (ii = qp1; ii < 4; ii++) {
            V[ii - 1] = e[ii - 1];
          }
        }
      }

      m = 1;
      s[2] = b_A[8];
      e[1] = b_A[7];
      e[2] = 0.0;
      U[6] = 0.0;
      U[7] = 0.0;
      U[8] = 1.0;
      for (int q{1}; q >= 0; q--) {
        qp1 = q + 2;
        qq = q + 3 * q;
        if (s[q] != 0.0) {
          for (kase = qp1; kase < 4; kase++) {
            qjj = (q + 3 * (kase - 1)) + 1;
            blas::xaxpy(3 - q, -(blas::xdotc(3 - q, U, qq + 1, U, qjj) / U[qq]),
                        qq + 1, U, qjj);
          }

          for (ii = q + 1; ii < 4; ii++) {
            kase = (ii + 3 * q) - 1;
            U[kase] = -U[kase];
          }

          U[qq]++;
          if (q - 1 >= 0) {
            U[3 * q] = 0.0;
          }
        } else {
          U[3 * q] = 0.0;
          U[3 * q + 1] = 0.0;
          U[3 * q + 2] = 0.0;
          U[qq] = 1.0;
        }
      }

      for (int q{2}; q >= 0; q--) {
        if ((q + 1 <= 1) && (e[0] != 0.0)) {
          blas::xaxpy(2, -(blas::xdotc(2, V, 2, V, 5) / V[1]), 2, V, 5);
          blas::xaxpy(2, -(blas::xdotc(2, V, 2, V, 8) / V[1]), 2, V, 8);
        }

        V[3 * q] = 0.0;
        V[3 * q + 1] = 0.0;
        V[3 * q + 2] = 0.0;
        V[q + 3 * q] = 1.0;
      }

      qq = 0;
      snorm = 0.0;
      for (int q{0}; q < 3; q++) {
        nrm = s[q];
        if (nrm != 0.0) {
          rt = std::abs(nrm);
          nrm /= rt;
          s[q] = rt;
          if (q + 1 < 3) {
            e[q] /= nrm;
          }

          kase = 3 * q;
          qjj = kase + 3;
          for (int k{kase + 1}; k <= qjj; k++) {
            U[k - 1] *= nrm;
          }
        }

        if (q + 1 < 3) {
          nrm = e[q];
          if (nrm != 0.0) {
            rt = std::abs(nrm);
            nrm = rt / nrm;
            e[q] = rt;
            s[q + 1] *= nrm;
            kase = 3 * (q + 1);
            qjj = kase + 3;
            for (int k{kase + 1}; k <= qjj; k++) {
              V[k - 1] *= nrm;
            }
          }
        }

        snorm = std::fmax(snorm, std::fmax(std::abs(s[q]), std::abs(e[q])));
      }

      while ((m + 2 > 0) && (qq < 75)) {
        bool exitg1;
        qq_tmp = m + 1;
        ii = m + 1;
        exitg1 = false;
        while (!(exitg1 || (ii == 0))) {
          nrm = std::abs(e[ii - 1]);
          if ((nrm <= 2.2204460492503131E-16 * (std::abs(s[ii - 1]) + std::abs
                (s[ii]))) || (nrm <= 1.0020841800044864E-292) || ((qq > 20) &&
               (nrm <= 2.2204460492503131E-16 * snorm))) {
            e[ii - 1] = 0.0;
            exitg1 = true;
          } else {
            ii--;
          }
        }

        if (ii == m + 1) {
          kase = 4;
        } else {
          qjj = m + 2;
          kase = m + 2;
          exitg1 = false;
          while ((!exitg1) && (kase >= ii)) {
            qjj = kase;
            if (kase == ii) {
              exitg1 = true;
            } else {
              nrm = 0.0;
              if (kase < m + 2) {
                nrm = std::abs(e[kase - 1]);
              }

              if (kase > ii + 1) {
                nrm += std::abs(e[kase - 2]);
              }

              rt = std::abs(s[kase - 1]);
              if ((rt <= 2.2204460492503131E-16 * nrm) || (rt <=
                   1.0020841800044864E-292)) {
                s[kase - 1] = 0.0;
                exitg1 = true;
              } else {
                kase--;
              }
            }
          }

          if (qjj == ii) {
            kase = 3;
          } else if (qjj == m + 2) {
            kase = 1;
          } else {
            kase = 2;
            ii = qjj;
          }
        }

        switch (kase) {
         case 1:
          {
            rt = e[m];
            e[m] = 0.0;
            for (int k{qq_tmp}; k >= ii + 1; k--) {
              double sm;
              sm = blas::xrotg(&s[k - 1], rt, sqds);
              if (k > ii + 1) {
                rt = -sqds * e[0];
                e[0] *= sm;
              }

              blas::xrot(V, 3 * (k - 1) + 1, 3 * (m + 1) + 1, sm, sqds);
            }
          }
          break;

         case 2:
          {
            rt = e[ii - 1];
            e[ii - 1] = 0.0;
            for (int k{ii + 1}; k <= m + 2; k++) {
              double b;
              double sm;
              sm = blas::xrotg(&s[k - 1], rt, sqds);
              b = e[k - 1];
              rt = -sqds * b;
              e[k - 1] = b * sm;
              blas::xrot(U, 3 * (k - 1) + 1, 3 * (ii - 1) + 1, sm, sqds);
            }
          }
          break;

         case 3:
          {
            double b;
            double scale;
            double sm;
            nrm = s[m + 1];
            scale = std::fmax(std::fmax(std::fmax(std::fmax(std::abs(nrm), std::
              abs(s[m])), std::abs(e[m])), std::abs(s[ii])), std::abs(e[ii]));
            sm = nrm / scale;
            nrm = s[m] / scale;
            rt = e[m] / scale;
            sqds = s[ii] / scale;
            b = ((nrm + sm) * (nrm - sm) + rt * rt) / 2.0;
            nrm = sm * rt;
            nrm *= nrm;
            if ((b != 0.0) || (nrm != 0.0)) {
              rt = std::sqrt(b * b + nrm);
              if (b < 0.0) {
                rt = -rt;
              }

              rt = nrm / (b + rt);
            } else {
              rt = 0.0;
            }

            rt += (sqds + sm) * (sqds - sm);
            nrm = sqds * (e[ii] / scale);
            for (int k{ii + 1}; k <= qq_tmp; k++) {
              sm = blas::xrotg(&rt, nrm, sqds);
              if (k > ii + 1) {
                e[0] = rt;
              }

              nrm = e[k - 1];
              b = s[k - 1];
              e[k - 1] = sm * nrm - sqds * b;
              rt = sqds * s[k];
              s[k] *= sm;
              qjj = 3 * (k - 1) + 1;
              kase = 3 * k + 1;
              blas::xrot(V, qjj, kase, sm, sqds);
              s[k - 1] = sm * b + sqds * nrm;
              sm = blas::xrotg(&s[k - 1], rt, sqds);
              b = e[k - 1];
              rt = sm * b + sqds * s[k];
              s[k] = -sqds * b + sm * s[k];
              nrm = sqds * e[k];
              e[k] *= sm;
              blas::xrot(U, qjj, kase, sm, sqds);
            }

            e[m] = rt;
            qq++;
          }
          break;

         default:
          if (s[ii] < 0.0) {
            s[ii] = -s[ii];
            kase = 3 * ii;
            qjj = kase + 3;
            for (int k{kase + 1}; k <= qjj; k++) {
              V[k - 1] = -V[k - 1];
            }
          }

          qp1 = ii + 1;
          while ((ii + 1 < 3) && (s[ii] < s[qp1])) {
            rt = s[ii];
            s[ii] = s[qp1];
            s[qp1] = rt;
            qjj = 3 * ii + 1;
            kase = 3 * (ii + 1) + 1;
            blas::xswap(V, qjj, kase);
            blas::xswap(U, qjj, kase);
            ii = qp1;
            qp1++;
          }

          qq = 0;
          m--;
          break;
        }
      }

      if (doscale) {
        reflapack::b_xzlascl(cscale, anrm, 3, s, 1);
      }
    }

    //
    // Arguments    : const array<double, 2U> &x
    //                array<double, 2U> &y
    // Return Type  : void
    //
  }

  static void inv(const array<double, 2U> &x, array<double, 2U> &y)
  {
    array<double, 2U> b_x;
    array<int, 2U> ipiv;
    array<int, 2U> p;
    if ((x.size(0) == 0) || (x.size(1) == 0)) {
      int yk;
      y.set_size(x.size(0), x.size(1));
      yk = x.size(0) * x.size(1);
      for (int i{0}; i < yk; i++) {
        y[i] = x[i];
      }
    } else {
      int i;
      int i1;
      int n_tmp;
      int yk;
      n_tmp = x.size(0);
      y.set_size(x.size(0), x.size(1));
      yk = x.size(0) * x.size(1);
      for (i = 0; i < yk; i++) {
        y[i] = 0.0;
      }

      b_x.set_size(x.size(0), x.size(1));
      for (i = 0; i < yk; i++) {
        b_x[i] = x[i];
      }

      internal::reflapack::xzgetrf(x.size(0), x.size(0), b_x, x.size(0), ipiv);
      p.set_size(1, x.size(0));
      p[0] = 1;
      yk = 1;
      for (int k{2}; k <= n_tmp; k++) {
        yk++;
        p[k - 1] = yk;
      }

      i = ipiv.size(1);
      for (int k{0}; k < i; k++) {
        i1 = ipiv[k];
        if (i1 > k + 1) {
          yk = p[i1 - 1];
          p[i1 - 1] = p[k];
          p[k] = yk;
        }
      }

      for (int k{0}; k < n_tmp; k++) {
        i = p[k];
        y[k + y.size(0) * (i - 1)] = 1.0;
        for (int j{k + 1}; j <= n_tmp; j++) {
          if (y[(j + y.size(0) * (i - 1)) - 1] != 0.0) {
            i1 = j + 1;
            for (int b_i{i1}; b_i <= n_tmp; b_i++) {
              y[(b_i + y.size(0) * (i - 1)) - 1] = y[(b_i + y.size(0) * (i - 1))
                - 1] - y[(j + y.size(0) * (i - 1)) - 1] * b_x[(b_i + b_x.size(0)
                * (j - 1)) - 1];
            }
          }
        }
      }

      for (int j{0}; j < n_tmp; j++) {
        yk = x.size(0) * j - 1;
        for (int k{n_tmp}; k >= 1; k--) {
          double d;
          int kAcol;
          kAcol = x.size(0) * (k - 1) - 1;
          i = k + yk;
          d = y[i];
          if (d != 0.0) {
            y[i] = d / b_x[k + kAcol];
            for (int b_i{0}; b_i <= k - 2; b_i++) {
              i1 = (b_i + yk) + 1;
              y[i1] = y[i1] - y[i] * b_x[(b_i + kAcol) + 1];
            }
          }
        }
      }
    }
  }

  //
  // Arguments    : const array<double, 2U> &A
  //                const array<double, 2U> &B
  //                array<double, 2U> &Y
  // Return Type  : void
  //
  static void mldivide(const array<double, 2U> &A, const array<double, 2U> &B,
                       array<double, 2U> &Y)
  {
    array<double, 2U> b_A;
    array<double, 2U> b_B;
    array<double, 1U> tau;
    array<int, 2U> jpvt;
    if ((A.size(0) == 0) || (A.size(1) == 0) || ((B.size(0) == 0) || (B.size(1) ==
          0))) {
      int minmn;
      Y.set_size(A.size(1), B.size(1));
      minmn = A.size(1) * B.size(1);
      for (int i{0}; i < minmn; i++) {
        Y[i] = 0.0;
      }
    } else if (A.size(0) == A.size(1)) {
      double tol;
      int i;
      int i1;
      int maxmn;
      int minmn;
      int n;
      int nrhs;
      nrhs = B.size(1);
      Y.set_size(B.size(0), B.size(1));
      minmn = B.size(0) * B.size(1);
      for (i = 0; i < minmn; i++) {
        Y[i] = B[i];
      }

      minmn = A.size(0);
      n = A.size(1);
      if (minmn <= n) {
        n = minmn;
      }

      minmn = B.size(0);
      if (minmn <= n) {
        n = minmn;
      }

      b_A.set_size(A.size(0), A.size(1));
      minmn = A.size(0) * A.size(1);
      for (i = 0; i < minmn; i++) {
        b_A[i] = A[i];
      }

      internal::reflapack::xzgetrf(n, n, b_A, A.size(0), jpvt);
      for (int b_i{0}; b_i <= n - 2; b_i++) {
        i = jpvt[b_i];
        if (i != b_i + 1) {
          for (int j{0}; j < nrhs; j++) {
            tol = Y[b_i + Y.size(0) * j];
            Y[b_i + Y.size(0) * j] = Y[(i + Y.size(0) * j) - 1];
            Y[(i + Y.size(0) * j) - 1] = tol;
          }
        }
      }

      for (int j{0}; j < nrhs; j++) {
        minmn = B.size(0) * j;
        for (int k{0}; k < n; k++) {
          maxmn = b_A.size(0) * k;
          i = k + minmn;
          if (Y[i] != 0.0) {
            i1 = k + 2;
            for (int b_i{i1}; b_i <= n; b_i++) {
              int rankA;
              rankA = (b_i + minmn) - 1;
              Y[rankA] = Y[rankA] - Y[i] * b_A[(b_i + maxmn) - 1];
            }
          }
        }
      }

      for (int j{0}; j < nrhs; j++) {
        minmn = B.size(0) * j - 1;
        for (int k{n}; k >= 1; k--) {
          maxmn = b_A.size(0) * (k - 1) - 1;
          i = k + minmn;
          tol = Y[i];
          if (tol != 0.0) {
            Y[i] = tol / b_A[k + maxmn];
            for (int b_i{0}; b_i <= k - 2; b_i++) {
              i1 = (b_i + minmn) + 1;
              Y[i1] = Y[i1] - Y[i] * b_A[(b_i + maxmn) + 1];
            }
          }
        }
      }
    } else {
      double tol;
      int i;
      int i1;
      int maxmn;
      int minmn;
      int rankA;
      b_A.set_size(A.size(0), A.size(1));
      minmn = A.size(0) * A.size(1);
      for (i = 0; i < minmn; i++) {
        b_A[i] = A[i];
      }

      internal::lapack::xgeqp3(b_A, tau, jpvt);
      rankA = 0;
      if (b_A.size(0) < b_A.size(1)) {
        minmn = b_A.size(0);
        maxmn = b_A.size(1);
      } else {
        minmn = b_A.size(1);
        maxmn = b_A.size(0);
      }

      if (minmn > 0) {
        tol = std::fmin(1.4901161193847656E-8, 2.2204460492503131E-15 *
                        static_cast<double>(maxmn)) * std::abs(b_A[0]);
        while ((rankA < minmn) && (!(std::abs(b_A[rankA + b_A.size(0) * rankA]) <=
                 tol))) {
          rankA++;
        }
      }

      i = B.size(1);
      b_B.set_size(B.size(0), B.size(1));
      minmn = B.size(0) * B.size(1);
      for (i1 = 0; i1 < minmn; i1++) {
        b_B[i1] = B[i1];
      }

      Y.set_size(b_A.size(1), B.size(1));
      minmn = b_A.size(1) * B.size(1);
      for (i1 = 0; i1 < minmn; i1++) {
        Y[i1] = 0.0;
      }

      minmn = b_A.size(0);
      maxmn = b_A.size(1);
      if (minmn <= maxmn) {
        maxmn = minmn;
      }

      for (int j{0}; j < maxmn; j++) {
        minmn = b_A.size(0);
        if (tau[j] != 0.0) {
          i1 = j + 2;
          for (int k{0}; k < i; k++) {
            tol = b_B[j + b_B.size(0) * k];
            for (int b_i{i1}; b_i <= minmn; b_i++) {
              tol += b_A[(b_i + b_A.size(0) * j) - 1] * b_B[(b_i + b_B.size(0) *
                k) - 1];
            }

            tol *= tau[j];
            if (tol != 0.0) {
              b_B[j + b_B.size(0) * k] = b_B[j + b_B.size(0) * k] - tol;
              for (int b_i{i1}; b_i <= minmn; b_i++) {
                b_B[(b_i + b_B.size(0) * k) - 1] = b_B[(b_i + b_B.size(0) * k) -
                  1] - b_A[(b_i + b_A.size(0) * j) - 1] * tol;
              }
            }
          }
        }
      }

      for (int k{0}; k < i; k++) {
        for (int b_i{0}; b_i < rankA; b_i++) {
          Y[(jpvt[b_i] + Y.size(0) * k) - 1] = b_B[b_i + b_B.size(0) * k];
        }

        for (int j{rankA}; j >= 1; j--) {
          i1 = jpvt[j - 1];
          Y[(i1 + Y.size(0) * k) - 1] = Y[(i1 + Y.size(0) * k) - 1] / b_A[(j +
            b_A.size(0) * (j - 1)) - 1];
          for (int b_i{0}; b_i <= j - 2; b_i++) {
            Y[(jpvt[b_i] + Y.size(0) * k) - 1] = Y[(jpvt[b_i] + Y.size(0) * k) -
              1] - Y[(i1 + Y.size(0) * k) - 1] * b_A[b_i + b_A.size(0) * (j - 1)];
          }
        }
      }
    }
  }

  //
  // Arguments    : double r[4]
  // Return Type  : void
  //
  static void randn(double r[4])
  {
    r[0] = internal::randfun::b_eml_rand_mt19937ar(state);
    r[1] = internal::randfun::b_eml_rand_mt19937ar(state);
    r[2] = internal::randfun::b_eml_rand_mt19937ar(state);
    r[3] = internal::randfun::b_eml_rand_mt19937ar(state);
  }

  //
  // Arguments    : const double varargin_1[2]
  //                double r_data[]
  // Return Type  : int
  //
  static int randn(const double varargin_1[2], double r_data[])
  {
    int i;
    int r_size;
    i = static_cast<int>(varargin_1[0]);
    r_size = static_cast<int>(varargin_1[0]);
    for (int k{0}; k < i; k++) {
      r_data[k] = internal::randfun::b_eml_rand_mt19937ar(state);
    }

    return r_size;
  }

  //
  // Arguments    : double varargin_2
  //                cell_wrap_41 b_data[]
  //                int b_size[2]
  // Return Type  : void
  //
  static void repmat(double varargin_2, cell_wrap_41 b_data[], int b_size[2])
  {
    int i;
    b_size[0] = 1;
    i = static_cast<int>(varargin_2);
    b_size[1] = static_cast<int>(varargin_2);
    if (static_cast<int>(varargin_2) != 0) {
      for (int jtilecol{0}; jtilecol < i; jtilecol++) {
        for (int i1{0}; i1 < 16; i1++) {
          b_data[jtilecol].f1[i1] = iv[i1];
        }
      }
    }
  }

  //
  // Arguments    : const double a[6]
  //                double b[18]
  // Return Type  : void
  //
  static void repmat(const double a[6], double b[18])
  {
    for (int jcol{0}; jcol < 6; jcol++) {
      double d;
      int ibmat;
      ibmat = jcol * 3;
      d = a[jcol];
      b[ibmat] = d;
      b[ibmat + 1] = d;
      b[ibmat + 2] = d;
    }
  }

  //
  // Arguments    : const double R[9]
  //                double q[4]
  // Return Type  : void
  //
  namespace robotics
  {
    namespace core
    {
      namespace internal
      {
        static void b_rotm2quat(const double R[9], double q[4])
        {
          double Rarr[9];
          double a;
          double b;
          double c;
          double d;
          double pd;
          int iindx;
          for (iindx = 0; iindx < 3; iindx++) {
            Rarr[3 * iindx] = R[iindx];
            Rarr[3 * iindx + 1] = R[iindx + 3];
            Rarr[3 * iindx + 2] = R[iindx + 6];
          }

          double dv[4];
          pd = (Rarr[0] + Rarr[4]) + Rarr[8];
          dv[0] = (2.0 * pd + 1.0) - pd;
          dv[1] = (2.0 * Rarr[0] + 1.0) - pd;
          dv[2] = (2.0 * Rarr[4] + 1.0) - pd;
          dv[3] = (2.0 * Rarr[8] + 1.0) - pd;
          pd = ::coder::internal::maximum(dv, iindx);
          switch (iindx) {
           case 1:
            pd = std::sqrt(pd);
            a = 0.5 * pd;
            pd = 0.5 / pd;
            b = pd * (Rarr[7] - Rarr[5]);
            c = pd * (Rarr[2] - Rarr[6]);
            d = pd * (Rarr[3] - Rarr[1]);
            break;

           case 2:
            pd = std::sqrt(pd);
            b = 0.5 * pd;
            pd = 0.5 / pd;
            a = pd * (Rarr[7] - Rarr[5]);
            c = pd * (Rarr[1] + Rarr[3]);
            d = pd * (Rarr[2] + Rarr[6]);
            break;

           case 3:
            pd = std::sqrt(pd);
            c = 0.5 * pd;
            pd = 0.5 / pd;
            a = pd * (Rarr[2] - Rarr[6]);
            b = pd * (Rarr[1] + Rarr[3]);
            d = pd * (Rarr[5] + Rarr[7]);
            break;

           default:
            pd = std::sqrt(pd);
            d = 0.5 * pd;
            pd = 0.5 / pd;
            a = pd * (Rarr[3] - Rarr[1]);
            b = pd * (Rarr[2] + Rarr[6]);
            c = pd * (Rarr[5] + Rarr[7]);
            break;
          }

          if (a < 0.0) {
            a = -a;
            b = -b;
            c = -c;
            d = -d;
          }

          q[0] = a;
          q[1] = b;
          q[2] = c;
          q[3] = d;
        }

        //
        // Arguments    : const array<double, 2U> &B
        // Return Type  : bool
        //
        static bool isPositiveDefinite(const array<double, 2U> &B)
        {
          array<double, 2U> A;
          int i;
          int i1;
          int info;
          int n;
          int nmj;
          i = B.size(0);
          A.set_size(B.size(0), B.size(1));
          nmj = B.size(0) * B.size(1);
          for (i1 = 0; i1 < nmj; i1++) {
            A[i1] = B[i1];
          }

          nmj = B.size(0);
          n = B.size(1);
          if (nmj <= n) {
            n = nmj;
          }

          info = 0;
          if (n != 0) {
            int j;
            bool exitg1;
            j = 0;
            exitg1 = false;
            while ((!exitg1) && (j <= n - 1)) {
              double c;
              double ssq;
              int idxAjj;
              idxAjj = j + j * i;
              ssq = 0.0;
              if (j >= 1) {
                for (nmj = 0; nmj < j; nmj++) {
                  c = A[j + nmj * i];
                  ssq += c * c;
                }
              }

              ssq = A[idxAjj] - ssq;
              if (ssq > 0.0) {
                ssq = std::sqrt(ssq);
                A[idxAjj] = ssq;
                if (j + 1 < n) {
                  int ia0;
                  int idxAjp1j;
                  nmj = (n - j) - 1;
                  ia0 = j + 2;
                  idxAjp1j = idxAjj + 2;
                  if ((nmj != 0) && (j != 0)) {
                    int ix;
                    ix = j;
                    i1 = (j + i * (j - 1)) + 2;
                    for (int iac{ia0}; i < 0 ? iac >= i1 : iac <= i1; iac += i)
                    {
                      int i2;
                      c = -A[ix];
                      i2 = iac + nmj;
                      for (int ia{iac}; ia < i2; ia++) {
                        int i3;
                        i3 = ((idxAjj + ia) - iac) + 1;
                        A[i3] = A[i3] + A[ia - 1] * c;
                      }

                      ix += i;
                    }
                  }

                  ssq = 1.0 / ssq;
                  i1 = idxAjj + nmj;
                  for (nmj = idxAjp1j; nmj <= i1 + 1; nmj++) {
                    A[nmj - 1] = ssq * A[nmj - 1];
                  }
                }

                j++;
              } else {
                info = j + 1;
                exitg1 = true;
              }
            }
          }

          return info == 0;
        }

        //
        // Arguments    : const double q[4]
        //                double R[9]
        // Return Type  : void
        //
      }
    }

    namespace internal
    {
      static void quat2rotm(const double q[4], double R[9])
      {
        double tempR[9];
        double b;
        double b_tempR_tmp;
        double c_tempR_tmp;
        double d_tempR_tmp;
        double e_tempR_tmp;
        double f_tempR_tmp;
        double g_tempR_tmp;
        double h_tempR_tmp;
        double i_tempR_tmp;
        double j_tempR_tmp;
        double normRowMatrix_idx_0;
        double normRowMatrix_idx_1;
        double normRowMatrix_idx_2;
        double tempR_tmp;
        b = 1.0 / std::sqrt(((q[0] * q[0] + q[1] * q[1]) + q[2] * q[2]) + q[3] *
                            q[3]);
        normRowMatrix_idx_0 = q[0] * b;
        normRowMatrix_idx_1 = q[1] * b;
        normRowMatrix_idx_2 = q[2] * b;
        b *= q[3];
        tempR_tmp = b * b;
        b_tempR_tmp = normRowMatrix_idx_2 * normRowMatrix_idx_2;
        c_tempR_tmp = 1.0 - 2.0 * (b_tempR_tmp + tempR_tmp);
        tempR[0] = c_tempR_tmp;
        d_tempR_tmp = normRowMatrix_idx_1 * normRowMatrix_idx_2;
        e_tempR_tmp = normRowMatrix_idx_0 * b;
        f_tempR_tmp = 2.0 * (d_tempR_tmp - e_tempR_tmp);
        tempR[1] = f_tempR_tmp;
        g_tempR_tmp = normRowMatrix_idx_1 * b;
        h_tempR_tmp = normRowMatrix_idx_0 * normRowMatrix_idx_2;
        i_tempR_tmp = 2.0 * (g_tempR_tmp + h_tempR_tmp);
        tempR[2] = i_tempR_tmp;
        d_tempR_tmp = 2.0 * (d_tempR_tmp + e_tempR_tmp);
        tempR[3] = d_tempR_tmp;
        e_tempR_tmp = normRowMatrix_idx_1 * normRowMatrix_idx_1;
        tempR_tmp = 1.0 - 2.0 * (e_tempR_tmp + tempR_tmp);
        tempR[4] = tempR_tmp;
        j_tempR_tmp = normRowMatrix_idx_2 * b;
        b = normRowMatrix_idx_0 * normRowMatrix_idx_1;
        normRowMatrix_idx_2 = 2.0 * (j_tempR_tmp - b);
        tempR[5] = normRowMatrix_idx_2;
        g_tempR_tmp = 2.0 * (g_tempR_tmp - h_tempR_tmp);
        tempR[6] = g_tempR_tmp;
        h_tempR_tmp = 2.0 * (j_tempR_tmp + b);
        tempR[7] = h_tempR_tmp;
        b_tempR_tmp = 1.0 - 2.0 * (e_tempR_tmp + b_tempR_tmp);
        tempR[8] = b_tempR_tmp;
        R[0] = c_tempR_tmp;
        R[1] = f_tempR_tmp;
        R[2] = i_tempR_tmp;
        R[3] = d_tempR_tmp;
        R[4] = tempR_tmp;
        R[5] = normRowMatrix_idx_2;
        R[6] = g_tempR_tmp;
        R[7] = h_tempR_tmp;
        R[8] = b_tempR_tmp;
        for (int k{0}; k < 3; k++) {
          R[k] = tempR[3 * k];
          R[k + 3] = tempR[3 * k + 1];
          R[k + 6] = tempR[3 * k + 2];
        }
      }

      //
      // Arguments    : const double R[9]
      //                double eul[3]
      // Return Type  : void
      //
    }
  }

  static void rotm2eul(const double R[9], double eul[3])
  {
    double cy;
    double cySq;
    cySq = R[0] * R[0] + R[1] * R[1];
    cy = std::sqrt(cySq);
    eul[0] = internal::scalar::b_atan2(R[5], R[8]);
    eul[1] = internal::scalar::b_atan2(-R[2], cy);
    eul[2] = internal::scalar::b_atan2(R[1], R[0]);
    if (cySq < 2.2204460492503131E-15) {
      eul[0] = internal::scalar::b_atan2(-R[7], R[4]);
      eul[1] = internal::scalar::b_atan2(-R[2], cy);
      eul[2] = 0.0;
    }

    cySq = eul[0];
    eul[0] = eul[2];
    eul[2] = cySq;
  }

  //
  // Arguments    : const double R[9]
  //                double quat[4]
  // Return Type  : void
  //
  static void rotm2quat(const double R[9], double quat[4])
  {
    creal_T eigVec[16];
    creal_T eigVal[4];
    double A[16];
    double Q[16];
    double a__4[4];
    double K12;
    double K13;
    double K14;
    double K23;
    double K24;
    double K34;
    int k;
    int sgn;
    bool iscale;
    K12 = R[1] + R[3];
    K13 = R[2] + R[6];
    K14 = R[5] - R[7];
    K23 = R[5] + R[7];
    K24 = R[6] - R[2];
    K34 = R[1] - R[3];
    A[0] = ((R[0] - R[4]) - R[8]) / 3.0;
    A[4] = K12 / 3.0;
    A[8] = K13 / 3.0;
    A[12] = K14 / 3.0;
    A[1] = K12 / 3.0;
    A[5] = ((R[4] - R[0]) - R[8]) / 3.0;
    A[9] = K23 / 3.0;
    A[13] = K24 / 3.0;
    A[2] = K13 / 3.0;
    A[6] = K23 / 3.0;
    A[10] = ((R[8] - R[0]) - R[4]) / 3.0;
    A[14] = K34 / 3.0;
    A[3] = K14 / 3.0;
    A[7] = K24 / 3.0;
    A[11] = K34 / 3.0;
    A[15] = ((R[0] + R[4]) + R[8]) / 3.0;
    iscale = true;
    for (k = 0; k < 16; k++) {
      if (iscale) {
        K12 = A[k];
        if (std::isinf(K12) || std::isnan(K12)) {
          iscale = false;
        }
      } else {
        iscale = false;
      }
    }

    if (!iscale) {
      for (int i{0}; i < 16; i++) {
        eigVec[i].re = rtNaN;
        eigVec[i].im = 0.0;
      }

      eigVal[0].re = rtNaN;
      eigVal[1].re = rtNaN;
      eigVal[2].re = rtNaN;
      eigVal[3].re = rtNaN;
    } else {
      int b_i;
      int exitg1;
      int j;
      bool exitg2;
      iscale = true;
      j = 0;
      exitg2 = false;
      while ((!exitg2) && (j < 4)) {
        b_i = 0;
        do {
          exitg1 = 0;
          if (b_i <= j) {
            if (!(A[b_i + (j << 2)] == A[j + (b_i << 2)])) {
              iscale = false;
              exitg1 = 1;
            } else {
              b_i++;
            }
          } else {
            j++;
            exitg1 = 2;
          }
        } while (exitg1 == 0);

        if (exitg1 == 1) {
          exitg2 = true;
        }
      }

      if (iscale) {
        int i;
        K24 = 0.0;
        j = 0;
        exitg2 = false;
        while ((!exitg2) && (j < 4)) {
          b_i = 0;
          do {
            exitg1 = 0;
            if (b_i <= j) {
              K12 = std::abs(A[b_i + (j << 2)]);
              if (std::isnan(K12)) {
                K24 = rtNaN;
                exitg1 = 1;
              } else {
                if (K12 > K24) {
                  K24 = K12;
                }

                b_i++;
              }
            } else {
              j++;
              exitg1 = 2;
            }
          } while (exitg1 == 0);

          if (exitg1 == 1) {
            exitg2 = true;
          }
        }

        if (std::isinf(K24) || std::isnan(K24)) {
          a__4[0] = rtNaN;
          a__4[1] = rtNaN;
          a__4[2] = rtNaN;
          a__4[3] = rtNaN;
          for (i = 0; i < 16; i++) {
            A[i] = rtNaN;
          }
        } else {
          double work[4];
          double e[3];
          double tau[3];
          int iaii;
          iscale = false;
          if ((K24 > 0.0) && (K24 < 1.0010415475915505E-146)) {
            iscale = true;
            K24 = 1.0010415475915505E-146 / K24;
            internal::reflapack::xzlascl(1.0, K24, A);
          } else if (K24 > 9.9895953610111751E+145) {
            iscale = true;
            K24 = 9.9895953610111751E+145 / K24;
            internal::reflapack::xzlascl(1.0, K24, A);
          }

          for (b_i = 0; b_i < 3; b_i++) {
            int e_tmp_tmp;
            int ia0_tmp_tmp;
            ia0_tmp_tmp = b_i << 2;
            e_tmp_tmp = b_i + ia0_tmp_tmp;
            e[b_i] = A[e_tmp_tmp + 1];
            sgn = b_i + 3;
            if (sgn > 4) {
              sgn = 4;
            }

            K23 = internal::reflapack::xzlarfg(3 - b_i, e[b_i], A, ia0_tmp_tmp +
              sgn);
            if (K23 != 0.0) {
              int i1;
              int i2;
              A[e_tmp_tmp + 1] = 1.0;
              for (sgn = b_i + 1; sgn < 4; sgn++) {
                tau[sgn - 1] = 0.0;
              }

              i = 2 - b_i;
              i1 = 4 - b_i;
              for (int jj{0}; jj <= i; jj++) {
                j = b_i + jj;
                K14 = K23 * A[(j + ia0_tmp_tmp) + 1];
                K13 = 0.0;
                iaii = (j + 1) << 2;
                tau[j] += K14 * A[(j + iaii) + 1];
                i2 = jj + 2;
                for (int ii{i2}; ii < i1; ii++) {
                  sgn = b_i + ii;
                  K12 = A[sgn + iaii];
                  tau[sgn - 1] += K14 * K12;
                  K13 += K12 * A[sgn + ia0_tmp_tmp];
                }

                tau[j] += K23 * K13;
              }

              K13 = 0.0;
              for (k = 0; k <= i; k++) {
                K13 += tau[b_i + k] * A[(e_tmp_tmp + k) + 1];
              }

              K13 *= -0.5 * K23;
              if (!(K13 == 0.0)) {
                i2 = 3 - b_i;
                for (k = 0; k < i2; k++) {
                  iaii = b_i + k;
                  tau[iaii] += K13 * A[(e_tmp_tmp + k) + 1];
                }
              }

              for (int jj{0}; jj <= i; jj++) {
                j = b_i + jj;
                K14 = A[(j + ia0_tmp_tmp) + 1];
                K12 = tau[j];
                K13 = K12 * K14;
                iaii = (j + 1) << 2;
                k = (j + iaii) + 1;
                A[k] = (A[k] - K13) - K13;
                i2 = jj + 2;
                for (int ii{i2}; ii < i1; ii++) {
                  k = b_i + ii;
                  sgn = k + iaii;
                  A[sgn] = (A[sgn] - tau[k - 1] * K14) - A[k + ia0_tmp_tmp] *
                    K12;
                }
              }
            }

            A[e_tmp_tmp + 1] = e[b_i];
            a__4[b_i] = A[e_tmp_tmp];
            tau[b_i] = K23;
          }

          a__4[3] = A[15];
          for (j = 2; j >= 0; j--) {
            k = (j + 1) << 2;
            A[k] = 0.0;
            i = j + 3;
            for (b_i = i; b_i < 5; b_i++) {
              A[(b_i + k) - 1] = A[(b_i + (j << 2)) - 1];
            }
          }

          A[0] = 1.0;
          A[1] = 0.0;
          A[2] = 0.0;
          A[3] = 0.0;
          sgn = 2;
          work[0] = 0.0;
          work[1] = 0.0;
          work[2] = 0.0;
          work[3] = 0.0;
          for (b_i = 2; b_i >= 0; b_i--) {
            iaii = (b_i + (b_i << 2)) + 5;
            if (b_i + 1 < 3) {
              A[iaii] = 1.0;
              internal::reflapack::xzlarf(3 - b_i, 2 - b_i, iaii + 1, tau[sgn],
                A, iaii + 5, work);
              j = iaii + 2;
              i = (iaii - b_i) + 3;
              for (k = j; k <= i; k++) {
                A[k - 1] *= -tau[sgn];
              }
            }

            A[iaii] = 1.0 - tau[sgn];
            for (j = 0; j < b_i; j++) {
              A[(iaii - j) - 1] = 0.0;
            }

            sgn = b_i - 1;
          }

          sgn = internal::reflapack::xzsteqr(a__4, e, A);
          if (sgn != 0) {
            a__4[0] = rtNaN;
            a__4[1] = rtNaN;
            a__4[2] = rtNaN;
            a__4[3] = rtNaN;
            for (i = 0; i < 16; i++) {
              A[i] = rtNaN;
            }
          } else if (iscale) {
            K13 = 1.0 / K24;
            a__4[0] *= K13;
            a__4[1] *= K13;
            a__4[2] *= K13;
            a__4[3] *= K13;
          }
        }

        eigVal[0].re = a__4[0];
        eigVal[1].re = a__4[1];
        eigVal[2].re = a__4[2];
        eigVal[3].re = a__4[3];
        for (i = 0; i < 16; i++) {
          eigVec[i].re = A[i];
          eigVec[i].im = 0.0;
        }
      } else {
        iscale = true;
        j = 0;
        exitg2 = false;
        while ((!exitg2) && (j < 4)) {
          b_i = 0;
          do {
            exitg1 = 0;
            if (b_i <= j) {
              if (!(A[b_i + (j << 2)] == -A[j + (b_i << 2)])) {
                iscale = false;
                exitg1 = 1;
              } else {
                b_i++;
              }
            } else {
              j++;
              exitg1 = 2;
            }
          } while (exitg1 == 0);

          if (exitg1 == 1) {
            exitg2 = true;
          }
        }

        if (iscale) {
          double work[4];
          double tau[3];
          int i;
          internal::reflapack::xzgehrd(A, 1, 4, tau);
          ::std::copy(&A[0], &A[16], &Q[0]);
          internal::reflapack::xzunghr(1, 4, Q, tau);
          sgn = internal::reflapack::xdlahqr(1, 4, A, 1, 4, Q, a__4, work);
          i = static_cast<unsigned char>(sgn);
          for (b_i = 0; b_i < i; b_i++) {
            eigVal[b_i].re = rtNaN;
            eigVal[b_i].im = 0.0;
          }

          i = sgn + 1;
          for (b_i = i; b_i < 5; b_i++) {
            eigVal[b_i - 1].re = 0.0;
            eigVal[b_i - 1].im = work[b_i - 1];
          }

          if (sgn == 0) {
            for (i = 0; i < 16; i++) {
              eigVec[i].re = Q[i];
              eigVec[i].im = 0.0;
            }

            j = 1;
            do {
              exitg1 = 0;
              if (j <= 4) {
                if (j != 4) {
                  i = (j - 1) << 2;
                  K12 = A[j + i];
                  if (K12 != 0.0) {
                    int i1;
                    if (K12 < 0.0) {
                      sgn = 1;
                    } else {
                      sgn = -1;
                    }

                    K12 = eigVec[i].re;
                    i1 = j << 2;
                    K13 = static_cast<double>(sgn) * eigVec[i1].re;
                    if (K13 == 0.0) {
                      eigVec[i].re = K12 / 1.4142135623730951;
                      eigVec[i].im = 0.0;
                    } else if (K12 == 0.0) {
                      eigVec[i].re = 0.0;
                      eigVec[i].im = K13 / 1.4142135623730951;
                    } else {
                      eigVec[i].re = K12 / 1.4142135623730951;
                      eigVec[i].im = K13 / 1.4142135623730951;
                    }

                    eigVec[i1].re = eigVec[i].re;
                    eigVec[i1].im = -eigVec[i].im;
                    K12 = eigVec[i + 1].re;
                    K13 = static_cast<double>(sgn) * eigVec[i1 + 1].re;
                    if (K13 == 0.0) {
                      eigVec[i + 1].re = K12 / 1.4142135623730951;
                      eigVec[i + 1].im = 0.0;
                    } else if (K12 == 0.0) {
                      eigVec[i + 1].re = 0.0;
                      eigVec[i + 1].im = K13 / 1.4142135623730951;
                    } else {
                      eigVec[i + 1].re = K12 / 1.4142135623730951;
                      eigVec[i + 1].im = K13 / 1.4142135623730951;
                    }

                    eigVec[i1 + 1].re = eigVec[i + 1].re;
                    eigVec[i1 + 1].im = -eigVec[i + 1].im;
                    K12 = eigVec[i + 2].re;
                    K13 = static_cast<double>(sgn) * eigVec[i1 + 2].re;
                    if (K13 == 0.0) {
                      eigVec[i + 2].re = K12 / 1.4142135623730951;
                      eigVec[i + 2].im = 0.0;
                    } else if (K12 == 0.0) {
                      eigVec[i + 2].re = 0.0;
                      eigVec[i + 2].im = K13 / 1.4142135623730951;
                    } else {
                      eigVec[i + 2].re = K12 / 1.4142135623730951;
                      eigVec[i + 2].im = K13 / 1.4142135623730951;
                    }

                    eigVec[i1 + 2].re = eigVec[i + 2].re;
                    eigVec[i1 + 2].im = -eigVec[i + 2].im;
                    K12 = eigVec[i + 3].re;
                    K13 = static_cast<double>(sgn) * eigVec[i1 + 3].re;
                    if (K13 == 0.0) {
                      eigVec[i + 3].re = K12 / 1.4142135623730951;
                      eigVec[i + 3].im = 0.0;
                    } else if (K12 == 0.0) {
                      eigVec[i + 3].re = 0.0;
                      eigVec[i + 3].im = K13 / 1.4142135623730951;
                    } else {
                      eigVec[i + 3].re = K12 / 1.4142135623730951;
                      eigVec[i + 3].im = K13 / 1.4142135623730951;
                    }

                    eigVec[i1 + 3].re = eigVec[i + 3].re;
                    eigVec[i1 + 3].im = -eigVec[i + 3].im;
                    j += 2;
                  } else {
                    j++;
                  }
                } else {
                  j++;
                }
              } else {
                exitg1 = 1;
              }
            } while (exitg1 == 0);
          } else {
            for (i = 0; i < 16; i++) {
              eigVec[i].re = rtNaN;
              eigVec[i].im = 0.0;
            }
          }
        } else {
          eigStandard(A, eigVec, eigVal);
        }
      }
    }

    a__4[0] = eigVal[0].re;
    a__4[1] = eigVal[1].re;
    a__4[2] = eigVal[2].re;
    a__4[3] = eigVal[3].re;
    internal::maximum(a__4, sgn);
    sgn = (sgn - 1) << 2;
    quat[0] = eigVec[sgn + 3].re;
    quat[1] = eigVec[sgn].re;
    quat[2] = eigVec[sgn + 1].re;
    quat[3] = eigVec[sgn + 2].re;
    if (quat[0] < 0.0) {
      quat[0] = -quat[0];
      quat[1] = -quat[1];
      quat[2] = -quat[2];
      quat[3] = -quat[3];
    }
  }

  //
  // Arguments    : const array<double, 2U> &x
  //                array<double, 1U> &y
  // Return Type  : void
  //
  static void sum(const array<double, 2U> &x, array<double, 1U> &y)
  {
    if (x.size(0) == 0) {
      y.set_size(0);
    } else {
      int vstride_tmp;
      vstride_tmp = x.size(0);
      y.set_size(x.size(0));
      for (int xj{0}; xj < vstride_tmp; xj++) {
        y[xj] = x[xj];
      }

      for (int k{0}; k < 2; k++) {
        int xoffset;
        xoffset = (k + 1) * vstride_tmp;
        for (int xj{0}; xj < vstride_tmp; xj++) {
          y[xj] = y[xj] + x[xoffset + xj];
        }
      }
    }
  }

  //
  // Arguments    : double &tstart_tv_nsec
  // Return Type  : double
  //
  static double tic(double &tstart_tv_nsec)
  {
    coderTimespec b_timespec;
    double tstart_tv_sec;
    if (!freq_not_empty) {
      freq_not_empty = true;
      coderInitTimeFunctions(&freq);
    }

    coderTimeClockGettimeMonotonic(&b_timespec, freq);
    tstart_tv_sec = b_timespec.tv_sec;
    tstart_tv_nsec = b_timespec.tv_nsec;
    return tstart_tv_sec;
  }

  //
  // Arguments    : double tstart_tv_sec
  //                double tstart_tv_nsec
  // Return Type  : double
  //
  static double toc(double tstart_tv_sec, double tstart_tv_nsec)
  {
    coderTimespec b_timespec;
    if (!freq_not_empty) {
      freq_not_empty = true;
      coderInitTimeFunctions(&freq);
    }

    coderTimeClockGettimeMonotonic(&b_timespec, freq);
    return (b_timespec.tv_sec - tstart_tv_sec) + (b_timespec.tv_nsec -
      tstart_tv_nsec) / 1.0E+9;
  }

  //
  // Arguments    : const char str_data[]
  //                const int str_size[2]
  //                char out_data[]
  //                int out_size[2]
  // Return Type  : void
  //
  static void validatestring(const char str_data[], const int str_size[2], char
    out_data[], int out_size[2])
  {
    static const char b_cv[8]{ 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };

    static const char b_cv2[8]{ 'f', 'l', 'o', 'a', 't', 'i', 'n', 'g' };

    static const char c_vstr[8]{ 'f', 'l', 'o', 'a', 't', 'i', 'n', 'g' };

    static const char vstr[8]{ 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };

    static const char b_cv1[5]{ 'f', 'i', 'x', 'e', 'd' };

    static const char b_vstr[5]{ 'f', 'i', 'x', 'e', 'd' };

    int exitg1;
    int nmatched;
    int partial_match_size_idx_1;
    int u0;
    int u1;
    char partial_match_data[9];
    bool b_bool;
    bool guard1;
    bool guard2;
    bool guard3;
    bool guard4;
    bool matched;
    partial_match_size_idx_1 = 8;
    for (u0 = 0; u0 < 8; u0++) {
      partial_match_data[u0] = ' ';
    }

    nmatched = 0;
    matched = false;
    guard1 = false;
    guard2 = false;
    guard3 = false;
    guard4 = false;
    if (str_size[1] <= 8) {
      b_bool = false;
      u1 = str_size[1];
      u0 = 0;
      do {
        exitg1 = 0;
        if (u0 <= u1 - 1) {
          if (cv2[static_cast<int>(static_cast<unsigned char>(str_data[u0]) &
               127U)] != cv2[static_cast<int>(b_cv[u0])]) {
            exitg1 = 1;
          } else {
            u0++;
          }
        } else {
          b_bool = true;
          exitg1 = 1;
        }
      } while (exitg1 == 0);

      if (b_bool) {
        if (str_size[1] == 8) {
          nmatched = 1;
          for (u0 = 0; u0 < 8; u0++) {
            partial_match_data[u0] = vstr[u0];
          }
        } else {
          for (u0 = 0; u0 < 8; u0++) {
            partial_match_data[u0] = vstr[u0];
          }

          matched = true;
          nmatched = 1;
          guard4 = true;
        }
      } else {
        guard4 = true;
      }
    } else {
      guard4 = true;
    }

    if (guard4) {
      if (str_size[1] <= 9) {
        b_bool = false;
        u1 = str_size[1];
        u0 = 0;
        do {
          exitg1 = 0;
          if (u0 <= u1 - 1) {
            if (cv2[static_cast<int>(static_cast<unsigned char>(str_data[u0]) &
                 127U)] != cv2[static_cast<int>(cv1[u0])]) {
              exitg1 = 1;
            } else {
              u0++;
            }
          } else {
            b_bool = true;
            exitg1 = 1;
          }
        } while (exitg1 == 0);

        if (b_bool) {
          if (str_size[1] == 9) {
            nmatched = 1;
            partial_match_size_idx_1 = 9;
            for (u0 = 0; u0 < 9; u0++) {
              partial_match_data[u0] = cv1[u0];
            }
          } else {
            if (!matched) {
              partial_match_size_idx_1 = 9;
              for (u0 = 0; u0 < 9; u0++) {
                partial_match_data[u0] = cv1[u0];
              }
            }

            matched = true;
            nmatched++;
            guard3 = true;
          }
        } else {
          guard3 = true;
        }
      } else {
        guard3 = true;
      }
    }

    if (guard3) {
      if (str_size[1] <= 5) {
        b_bool = false;
        u1 = str_size[1];
        u0 = 0;
        do {
          exitg1 = 0;
          if (u0 <= u1 - 1) {
            if (cv2[static_cast<int>(static_cast<unsigned char>(str_data[u0]) &
                 127U)] != cv2[static_cast<int>(b_cv1[u0])]) {
              exitg1 = 1;
            } else {
              u0++;
            }
          } else {
            b_bool = true;
            exitg1 = 1;
          }
        } while (exitg1 == 0);

        if (b_bool) {
          if (str_size[1] == 5) {
            nmatched = 1;
            partial_match_size_idx_1 = 5;
            for (u0 = 0; u0 < 5; u0++) {
              partial_match_data[u0] = b_vstr[u0];
            }
          } else {
            if (!matched) {
              partial_match_size_idx_1 = 5;
              for (u0 = 0; u0 < 5; u0++) {
                partial_match_data[u0] = b_vstr[u0];
              }
            }

            matched = true;
            nmatched++;
            guard2 = true;
          }
        } else {
          guard2 = true;
        }
      } else {
        guard2 = true;
      }
    }

    if (guard2) {
      if (str_size[1] <= 8) {
        b_bool = false;
        u1 = str_size[1];
        u0 = 0;
        do {
          exitg1 = 0;
          if (u0 <= u1 - 1) {
            if (cv2[static_cast<int>(static_cast<unsigned char>(str_data[u0]) &
                 127U)] != cv2[static_cast<int>(b_cv2[u0])]) {
              exitg1 = 1;
            } else {
              u0++;
            }
          } else {
            b_bool = true;
            exitg1 = 1;
          }
        } while (exitg1 == 0);

        if (b_bool) {
          if (str_size[1] == 8) {
            nmatched = 1;
            partial_match_size_idx_1 = 8;
            for (u0 = 0; u0 < 8; u0++) {
              partial_match_data[u0] = c_vstr[u0];
            }
          } else {
            if (!matched) {
              partial_match_size_idx_1 = 8;
              for (u0 = 0; u0 < 8; u0++) {
                partial_match_data[u0] = c_vstr[u0];
              }
            }

            nmatched++;
            guard1 = true;
          }
        } else {
          guard1 = true;
        }
      } else {
        guard1 = true;
      }
    }

    if (guard1 && (nmatched == 0)) {
      partial_match_size_idx_1 = 8;
      for (u0 = 0; u0 < 8; u0++) {
        partial_match_data[u0] = ' ';
      }
    }

    if ((nmatched == 0) || (str_size[1] == 0)) {
      out_size[0] = 1;
      out_size[1] = 8;
      for (u0 = 0; u0 < 8; u0++) {
        out_data[u0] = ' ';
      }
    } else if (nmatched <= 1) {
      out_size[0] = 1;
      out_size[1] = partial_match_size_idx_1;
      ::std::copy(&partial_match_data[0],
                  &partial_match_data[partial_match_size_idx_1], &out_data[0]);
    }
  }

  //
  // Arguments    : const char str[3]
  //                char out_data[]
  //                int out_size[2]
  // Return Type  : void
  //
  static void validatestring(const char str[3], char out_data[], int out_size[2])
  {
    static const char b_cv[3]{ 'o', 'f', 'f' };

    int kstr;
    bool b_bool;
    b_bool = false;
    kstr = 0;
    int exitg1;
    do {
      exitg1 = 0;
      if (kstr < 3) {
        if (cv2[static_cast<int>(static_cast<unsigned char>(str[kstr]) & 127U)]
            != cv2[static_cast<int>(b_cv[kstr])]) {
          exitg1 = 1;
        } else {
          kstr++;
        }
      } else {
        b_bool = true;
        exitg1 = 1;
      }
    } while (exitg1 == 0);

    if (b_bool) {
      char partial_match_data[3];
      partial_match_data[0] = 'o';
      partial_match_data[1] = 'f';
      partial_match_data[2] = 'f';
      out_size[0] = 1;
      out_size[1] = 3;
      for (kstr = 0; kstr < 3; kstr++) {
        out_data[kstr] = partial_match_data[kstr];
      }
    }
  }

  //
  // Arguments    : int numerator
  //                int denominator
  // Return Type  : int
  //
}

static int div_s32(int numerator, int denominator)
{
  int quotient;
  if (denominator == 0) {
    if (numerator >= 0) {
      quotient = MAX_int32_T;
    } else {
      quotient = MIN_int32_T;
    }
  } else {
    unsigned int u;
    unsigned int u1;
    if (numerator < 0) {
      u = ~static_cast<unsigned int>(numerator) + 1U;
    } else {
      u = static_cast<unsigned int>(numerator);
    }

    if (denominator < 0) {
      u1 = ~static_cast<unsigned int>(denominator) + 1U;
    } else {
      u1 = static_cast<unsigned int>(denominator);
    }

    u /= u1;
    if ((numerator < 0) != (denominator < 0)) {
      quotient = -static_cast<int>(u);
    } else {
      quotient = static_cast<int>(u);
    }
  }

  return quotient;
}

//
// Arguments    : void
// Return Type  : void
//
static void eml_rand_mt19937ar_stateful_init()
{
  coder::internal::randfun::eml_rand_mt19937ar(state);
}

//
// Arguments    : coder::array<double, 2U> &in1
//                const coder::array<double, 2U> &in2
// Return Type  : void
//
static void minus(coder::array<double, 2U> &in1, const coder::array<double, 2U>
                  &in2)
{
  coder::array<double, 2U> b_in1;
  int aux_0_1;
  int aux_1_1;
  int b_loop_ub;
  int loop_ub;
  int stride_0_0;
  int stride_0_1;
  int stride_1_0;
  int stride_1_1;
  if (in2.size(0) == 1) {
    loop_ub = in1.size(0);
  } else {
    loop_ub = in2.size(0);
  }

  if (in2.size(1) == 1) {
    b_loop_ub = in1.size(1);
  } else {
    b_loop_ub = in2.size(1);
  }

  b_in1.set_size(loop_ub, b_loop_ub);
  stride_0_0 = (in1.size(0) != 1);
  stride_0_1 = (in1.size(1) != 1);
  stride_1_0 = (in2.size(0) != 1);
  stride_1_1 = (in2.size(1) != 1);
  aux_0_1 = 0;
  aux_1_1 = 0;
  for (int i{0}; i < b_loop_ub; i++) {
    for (int i1{0}; i1 < loop_ub; i1++) {
      b_in1[i1 + b_in1.size(0) * i] = in1[i1 * stride_0_0 + in1.size(0) *
        aux_0_1] - in2[i1 * stride_1_0 + in2.size(0) * aux_1_1];
    }

    aux_1_1 += stride_1_1;
    aux_0_1 += stride_0_1;
  }

  in1.set_size(loop_ub, b_loop_ub);
  for (int i{0}; i < b_loop_ub; i++) {
    for (int i1{0}; i1 < loop_ub; i1++) {
      in1[i1 + in1.size(0) * i] = b_in1[i1 + b_in1.size(0) * i];
    }
  }
}

//
// Arguments    : coder::array<double, 1U> &in1
//                const coder::array<double, 1U> &in2
// Return Type  : void
//
static void minus(coder::array<double, 1U> &in1, const coder::array<double, 1U>
                  &in2)
{
  coder::array<double, 1U> b_in2;
  int loop_ub;
  int stride_0_0;
  int stride_1_0;
  if (in1.size(0) == 1) {
    loop_ub = in2.size(0);
  } else {
    loop_ub = in1.size(0);
  }

  b_in2.set_size(loop_ub);
  stride_0_0 = (in2.size(0) != 1);
  stride_1_0 = (in1.size(0) != 1);
  for (int i{0}; i < loop_ub; i++) {
    b_in2[i] = in2[i * stride_0_0] - in1[i * stride_1_0];
  }

  in1.set_size(loop_ub);
  for (int i{0}; i < loop_ub; i++) {
    in1[i] = b_in2[i];
  }
}

//
// Arguments    : coder::array<double, 2U> &in1
//                const coder::array<double, 2U> &in2
// Return Type  : void
//
static void plus(coder::array<double, 2U> &in1, const coder::array<double, 2U>
                 &in2)
{
  coder::array<double, 2U> b_in1;
  int aux_0_1;
  int aux_1_1;
  int b_loop_ub;
  int loop_ub;
  int stride_0_0;
  int stride_0_1;
  int stride_1_0;
  int stride_1_1;
  if (in2.size(0) == 1) {
    loop_ub = in1.size(0);
  } else {
    loop_ub = in2.size(0);
  }

  if (in2.size(1) == 1) {
    b_loop_ub = in1.size(1);
  } else {
    b_loop_ub = in2.size(1);
  }

  b_in1.set_size(loop_ub, b_loop_ub);
  stride_0_0 = (in1.size(0) != 1);
  stride_0_1 = (in1.size(1) != 1);
  stride_1_0 = (in2.size(0) != 1);
  stride_1_1 = (in2.size(1) != 1);
  aux_0_1 = 0;
  aux_1_1 = 0;
  for (int i{0}; i < b_loop_ub; i++) {
    for (int i1{0}; i1 < loop_ub; i1++) {
      b_in1[i1 + b_in1.size(0) * i] = in1[i1 * stride_0_0 + in1.size(0) *
        aux_0_1] + in2[i1 * stride_1_0 + in2.size(0) * aux_1_1];
    }

    aux_1_1 += stride_1_1;
    aux_0_1 += stride_0_1;
  }

  in1.set_size(loop_ub, b_loop_ub);
  for (int i{0}; i < b_loop_ub; i++) {
    for (int i1{0}; i1 < loop_ub; i1++) {
      in1[i1 + in1.size(0) * i] = b_in1[i1 + b_in1.size(0) * i];
    }
  }
}

//
// rbtForCodegen Create rigidBodyTree for the robot model
//    ROBOT = rbtForCodegen(DATAFORMAT) constructs a rigidBodyTree, ROBOT, and sets the
//    data format to DATAFORMAT. The possible values of DATAFORMAT are
//    'struct', 'column' and 'row'. The default value is 'row', which
//    matches the data format of the rigidbodytree object used to generate
//    this function.
//
// Arguments    : coder::robotics::manip::internal::CollisionSet &iobj_0
//                coder::rigidBodyJoint &iobj_1
//                coder::robotics::manip::internal::RigidBody &iobj_2
//                coder::rigidBodyTree &iobj_3
// Return Type  : coder::rigidBodyTree *
//
static coder::rigidBodyTree *rbtForCodegen(coder::robotics::manip::internal::
  CollisionSet &iobj_0, coder::rigidBodyJoint &iobj_1, coder::robotics::manip::
  internal::RigidBody &iobj_2, coder::rigidBodyTree &iobj_3)
{
  coder::collisionCapsule lobj_20[5];
  coder::rigidBody b_body;
  coder::rigidBody body;
  coder::rigidBody c_body;
  coder::rigidBody d_body;
  coder::rigidBody e_body;
  coder::rigidBody f_body;
  coder::rigidBody g_body;
  coder::rigidBody h_body;
  coder::rigidBody i_body;
  coder::rigidBody j_body;
  coder::rigidBodyJoint lobj_23[20];
  coder::rigidBodyJoint b_joint;
  coder::rigidBodyJoint c_joint;
  coder::rigidBodyJoint d_joint;
  coder::rigidBodyJoint e_joint;
  coder::rigidBodyJoint f_joint;
  coder::rigidBodyJoint g_joint;
  coder::rigidBodyJoint h_joint;
  coder::rigidBodyJoint i_joint;
  coder::rigidBodyJoint j_joint;
  coder::rigidBodyJoint joint;
  coder::rigidBodyTree *c_robot;
  coder::robotics::manip::internal::CollisionSet lobj_22[15];
  coder::robotics::manip::internal::RigidBody lobj_24[10];
  coder::robotics::manip::internal::RigidBodyTree lobj_21[10];
  coder::robotics::manip::internal::b_RigidBodyTree *obj;
  for (int i{0}; i < 10; i++) {
    lobj_24[i]._pobj0.matlabCodegenIsDeleted = true;
  }

  for (int i{0}; i < 15; i++) {
    lobj_22[i].matlabCodegenIsDeleted = true;
  }

  for (int i{0}; i < 10; i++) {
    lobj_21[i]._pobj0.CollisionsInternal.matlabCodegenIsDeleted = true;
  }

  for (int i{0}; i < 10; i++) {
    lobj_21[i].Base.CollisionsInternal.matlabCodegenIsDeleted = true;
  }

  for (int i{0}; i < 10; i++) {
    lobj_24[i].matlabCodegenIsDeleted = true;
  }

  for (int i{0}; i < 10; i++) {
    lobj_21[i]._pobj0.matlabCodegenIsDeleted = true;
    lobj_21[i].Base.matlabCodegenIsDeleted = true;
    lobj_21[i].matlabCodegenIsDeleted = true;
  }

  body.matlabCodegenIsDeleted = true;
  b_body.matlabCodegenIsDeleted = true;
  c_body.matlabCodegenIsDeleted = true;
  d_body.matlabCodegenIsDeleted = true;
  e_body.matlabCodegenIsDeleted = true;
  f_body.matlabCodegenIsDeleted = true;
  g_body.matlabCodegenIsDeleted = true;
  h_body.matlabCodegenIsDeleted = true;
  i_body.matlabCodegenIsDeleted = true;
  j_body.matlabCodegenIsDeleted = true;
  for (int i{0}; i < 5; i++) {
    lobj_20[i].matlabCodegenIsDeleted = true;
  }

  //    Auto-generated by MATLAB on 13-Mar-2025 12:06:22
  c_robot = iobj_3.init();
  obj = c_robot->TreeInternal;
  obj->Gravity[0] = 0.0;
  obj->Gravity[1] = 0.0;
  obj->Gravity[2] = 0.0;
  c_robot->set_BaseName();

  //  Add body, 'bodyBase', and joint, 'jntBase'
  joint.b_init();
  joint.setFixedTransform();
  j_body.init(lobj_21[0], lobj_22[0], lobj_23[0], lobj_24[0]);
  j_body.BodyInternal->JointInternal = joint.copy(lobj_23[1]);
  j_body.set_Mass();
  j_body.set_CenterOfMass();
  j_body.set_Inertia();
  j_body.addCollision(lobj_20[0].init());
  c_robot->addBody(j_body, (&iobj_0)[0], (&iobj_1)[0], (&iobj_2)[0]);

  //  Add body, 'bodyA1', and joint, 'jntA1'
  b_joint.c_init();
  b_joint.b_setFixedTransform();
  b_joint.set_PositionLimits();
  b_joint.set_JointAxis();
  b_joint.set_HomePosition();
  i_body.b_init(lobj_21[1], lobj_22[2], lobj_23[2], lobj_24[1]);
  i_body.BodyInternal->JointInternal = b_joint.copy(lobj_23[3]);
  i_body.set_Mass();
  i_body.set_CenterOfMass();
  i_body.set_Inertia();
  i_body.b_addCollision(lobj_20[1].b_init());
  c_robot->b_addBody(i_body, (&iobj_0)[2], (&iobj_1)[2], (&iobj_2)[1]);

  //  Add body, 'bodyA2', and joint, 'jntA2'
  c_joint.d_init();
  c_joint.c_setFixedTransform();
  c_joint.b_set_PositionLimits();
  c_joint.b_set_JointAxis();
  c_joint.b_set_HomePosition();
  h_body.c_init(lobj_21[2], lobj_22[4], lobj_23[4], lobj_24[2]);
  h_body.BodyInternal->JointInternal = c_joint.copy(lobj_23[5]);
  h_body.set_Mass();
  h_body.set_CenterOfMass();
  h_body.set_Inertia();
  h_body.c_addCollision(lobj_20[2].c_init());
  c_robot->c_addBody(h_body, (&iobj_0)[4], (&iobj_1)[4], (&iobj_2)[2]);

  //  Add body, 'bodyA3', and joint, 'jntA3'
  d_joint.e_init();
  d_joint.d_setFixedTransform();
  d_joint.c_set_PositionLimits();
  d_joint.b_set_JointAxis();
  d_joint.set_HomePosition();
  g_body.d_init(lobj_21[3], lobj_22[6], lobj_23[6], lobj_24[3]);
  g_body.BodyInternal->JointInternal = d_joint.copy(lobj_23[7]);
  g_body.set_Mass();
  g_body.set_CenterOfMass();
  g_body.set_Inertia();
  c_robot->d_addBody(g_body, (&iobj_0)[6], (&iobj_1)[6], (&iobj_2)[3]);

  //  Add body, 'bodyA4', and joint, 'jntA4'
  e_joint.f_init();
  e_joint.e_setFixedTransform();
  e_joint.d_set_PositionLimits();
  e_joint.c_set_JointAxis();
  e_joint.set_HomePosition();
  f_body.e_init(lobj_21[4], lobj_22[7], lobj_23[8], lobj_24[4]);
  f_body.BodyInternal->JointInternal = e_joint.copy(lobj_23[9]);
  f_body.set_Mass();
  f_body.set_CenterOfMass();
  f_body.set_Inertia();
  f_body.d_addCollision(lobj_20[3].d_init());
  c_robot->e_addBody(f_body, (&iobj_0)[8], (&iobj_1)[8], (&iobj_2)[4]);

  //  Add body, 'bodyA5', and joint, 'jntA5'
  f_joint.g_init();
  f_joint.f_setFixedTransform();
  f_joint.e_set_PositionLimits();
  f_joint.b_set_JointAxis();
  f_joint.set_HomePosition();
  e_body.f_init(lobj_21[5], lobj_22[9], lobj_23[10], lobj_24[5]);
  e_body.BodyInternal->JointInternal = f_joint.copy(lobj_23[11]);
  e_body.set_Mass();
  e_body.set_CenterOfMass();
  e_body.set_Inertia();
  c_robot->f_addBody(e_body, (&iobj_0)[10], (&iobj_1)[10], (&iobj_2)[5]);

  //  Add body, 'bodyA6', and joint, 'jntA6'
  g_joint.h_init();
  g_joint.g_setFixedTransform();
  g_joint.f_set_PositionLimits();
  g_joint.set_JointAxis();
  g_joint.set_HomePosition();
  d_body.g_init(lobj_21[6], lobj_22[10], lobj_23[12], lobj_24[6]);
  d_body.BodyInternal->JointInternal = g_joint.copy(lobj_23[13]);
  d_body.set_Mass();
  d_body.set_CenterOfMass();
  d_body.set_Inertia();
  c_robot->g_addBody(d_body, (&iobj_0)[12], (&iobj_1)[12], (&iobj_2)[6]);

  //  Add body, 'bodyEE', and joint, 'jntEE'
  h_joint.i_init();
  h_joint.h_setFixedTransform();
  c_body.h_init(lobj_21[7], lobj_22[11], lobj_23[14], lobj_24[7]);
  c_body.BodyInternal->JointInternal = h_joint.copy(lobj_23[15]);
  c_body.set_Mass();
  c_body.set_CenterOfMass();
  c_body.set_Inertia();
  c_robot->h_addBody(c_body, (&iobj_0)[14], (&iobj_1)[14], (&iobj_2)[7]);

  //  Add body, 'bodyTool', and joint, 'jntTool'
  i_joint.j_init();
  i_joint.h_setFixedTransform();
  b_body.i_init(lobj_21[8], lobj_22[12], lobj_23[16], lobj_24[8]);
  b_body.BodyInternal->JointInternal = i_joint.copy(lobj_23[17]);
  b_body.set_Mass();
  b_body.set_CenterOfMass();
  b_body.set_Inertia();
  b_body.e_addCollision(lobj_20[4].e_init());
  c_robot->h_addBody(b_body, (&iobj_0)[16], (&iobj_1)[16], (&iobj_2)[8]);

  //  Add body, 'bodyToolEE', and joint, 'jntToolEE'
  j_joint.k_init();
  j_joint.i_setFixedTransform();
  body.j_init(lobj_21[9], lobj_22[14], lobj_23[18], lobj_24[9]);
  body.BodyInternal->JointInternal = j_joint.copy(lobj_23[19]);
  body.set_Mass();
  body.set_CenterOfMass();
  body.set_Inertia();
  c_robot->i_addBody(body, (&iobj_0)[18], (&iobj_1)[18], (&iobj_2)[9]);
  for (int i{0}; i < 5; i++) {
    lobj_20[i].matlabCodegenDestructor();
  }

  j_body.matlabCodegenDestructor();
  i_body.matlabCodegenDestructor();
  h_body.matlabCodegenDestructor();
  g_body.matlabCodegenDestructor();
  f_body.matlabCodegenDestructor();
  e_body.matlabCodegenDestructor();
  d_body.matlabCodegenDestructor();
  c_body.matlabCodegenDestructor();
  b_body.matlabCodegenDestructor();
  body.matlabCodegenDestructor();
  for (int i{0}; i < 10; i++) {
    lobj_21[i].matlabCodegenDestructor();
  }

  for (int i{0}; i < 10; i++) {
    lobj_21[i].Base.matlabCodegenDestructor();
  }

  for (int i{0}; i < 10; i++) {
    lobj_21[i]._pobj0.matlabCodegenDestructor();
  }

  for (int i{0}; i < 10; i++) {
    lobj_24[i].matlabCodegenDestructor();
  }

  for (int i{0}; i < 10; i++) {
    lobj_21[i].Base.CollisionsInternal.matlabCodegenDestructor();
  }

  for (int i{0}; i < 10; i++) {
    lobj_21[i]._pobj0.CollisionsInternal.matlabCodegenDestructor();
  }

  for (int i{0}; i < 15; i++) {
    lobj_22[i].matlabCodegenDestructor();
  }

  for (int i{0}; i < 10; i++) {
    lobj_24[i]._pobj0.matlabCodegenDestructor();
  }

  return c_robot;
}

//
// Arguments    : void
// Return Type  : rigidBody
//
namespace coder
{
  rigidBody::rigidBody()
  {
    matlabCodegenIsDeleted = true;
  }

  //
  // Arguments    : void
  // Return Type  : collisionCapsule
  //
  collisionCapsule::collisionCapsule()
  {
    matlabCodegenIsDeleted = true;
  }

  //
  // Arguments    : void
  // Return Type  : rigidBodyTree
  //
  rigidBodyTree::rigidBodyTree()
  {
    matlabCodegenIsDeleted = true;
  }

  //
  // Arguments    : void
  // Return Type  : generalizedInverseKinematics
  //
  generalizedInverseKinematics::generalizedInverseKinematics()
  {
    matlabCodegenIsDeleted = true;
  }

  //
  // Arguments    : void
  // Return Type  : void
  //
  collisionCapsule::~collisionCapsule()
  {
    matlabCodegenDestructor();
  }

  //
  // Arguments    : void
  // Return Type  : void
  //
  rigidBodyTree::~rigidBodyTree()
  {
    matlabCodegenDestructor();
  }

  //
  // Arguments    : void
  // Return Type  : void
  //
  rigidBody::~rigidBody()
  {
    matlabCodegenDestructor();
  }

  //
  // Arguments    : void
  // Return Type  : void
  //
  generalizedInverseKinematics::~generalizedInverseKinematics()
  {
    matlabCodegenDestructor();
  }

  //
  // Arguments    : void
  // Return Type  : DampedBFGSwGradientProjection
  //
  namespace robotics
  {
    namespace core
    {
      namespace internal
      {
        DampedBFGSwGradientProjection::DampedBFGSwGradientProjection()
        {
          matlabCodegenIsDeleted = true;
        }

        //
        // Arguments    : void
        // Return Type  : void
        //
        DampedBFGSwGradientProjection::~DampedBFGSwGradientProjection()
        {
          matlabCodegenDestructor();
        }

        //
        // Arguments    : void
        // Return Type  : b_RigidBody
        //
      }
    }

    namespace manip
    {
      namespace internal
      {
        b_RigidBody::b_RigidBody()
        {
          matlabCodegenIsDeleted = true;
        }

        //
        // Arguments    : void
        // Return Type  : RigidBodyTree
        //
        RigidBodyTree::RigidBodyTree()
        {
          matlabCodegenIsDeleted = true;
        }

        //
        // Arguments    : void
        // Return Type  : b_RigidBodyTree
        //
        b_RigidBodyTree::b_RigidBodyTree()
        {
          matlabCodegenIsDeleted = true;
        }

        //
        // Arguments    : void
        // Return Type  : CollisionSet
        //
        CollisionSet::CollisionSet()
        {
          matlabCodegenIsDeleted = true;
        }

        //
        // Arguments    : void
        // Return Type  : GIKProblem
        //
        GIKProblem::GIKProblem()
        {
          matlabCodegenIsDeleted = true;
        }

        //
        // Arguments    : void
        // Return Type  : RigidBody
        //
        RigidBody::RigidBody()
        {
          matlabCodegenIsDeleted = true;
        }

        //
        // Arguments    : void
        // Return Type  : PositionTarget
        //
        PositionTarget::PositionTarget()
        {
          matlabCodegenIsDeleted = true;
        }

        //
        // Arguments    : void
        // Return Type  : OrientationTarget
        //
        OrientationTarget::OrientationTarget()
        {
          matlabCodegenIsDeleted = true;
        }

        //
        // Arguments    : void
        // Return Type  : void
        //
        GIKProblem::~GIKProblem()
        {
          matlabCodegenDestructor();
        }

        //
        // Arguments    : void
        // Return Type  : void
        //
        OrientationTarget::~OrientationTarget()
        {
          matlabCodegenDestructor();
        }

        //
        // Arguments    : void
        // Return Type  : void
        //
        PositionTarget::~PositionTarget()
        {
          matlabCodegenDestructor();
        }

        //
        // Arguments    : void
        // Return Type  : void
        //
        CollisionSet::~CollisionSet()
        {
          matlabCodegenDestructor();
        }

        //
        // Arguments    : void
        // Return Type  : void
        //
        b_RigidBodyTree::~b_RigidBodyTree()
        {
          matlabCodegenDestructor();
        }

        //
        // Arguments    : void
        // Return Type  : void
        //
        b_RigidBody::~b_RigidBody()
        {
          matlabCodegenDestructor();
        }

        //
        // Arguments    : void
        // Return Type  : void
        //
        RigidBodyTree::~RigidBodyTree()
        {
          matlabCodegenDestructor();
        }

        //
        // Arguments    : void
        // Return Type  : void
        //
        RigidBody::~RigidBody()
        {
          matlabCodegenDestructor();
        }

        //
        // Import Agrobot rbt model available for codegen
        //
        // Arguments    : const double currentConfig[6]
        //                bool *isSelfColliding
        //                double collPairs[2]
        // Return Type  : void
        //
      }
    }
  }
}

void Matlab_checkCollision(const double currentConfig[6], bool *isSelfColliding,
  double collPairs[2])
{
  coder::array<double, 2U> selfSeparationDist;
  coder::array<int, 1U> ii;
  coder::array<int, 1U> jj;
  coder::array<bool, 2U> r;
  int loop_ub_tmp;
  if (!isInitialized_Matlab_ik) {
    Matlab_ik_initialize();
  }

  //  Checks if robot is in self-collision and if true outputs collision pair numbers.
  //  Input:
  //  currentConfig - 1x6 array of robot configuration (axis angles in radians)
  //  Output:
  //  isSelfColliding   - bool representing if robot is in self-collision
  //  collPairs         - 1x2 array of robot body indexes that are in
  //                      collision. If no collision its value is [0,0]
  //  0 - means no collision found
  //  1 - bodyBase
  //  2 - bodyA1
  //  3 - bodyA2
  //  4 - bodyA3
  //  5 - bodyA4
  //  6 - bodyA5
  //  7 - bodyA6
  //  8 - bodyEE
  //  9 - bodyTool
  //  10 - bodyToolEE
  //  11 - base
  if (!robot_not_empty) {
    rbtForCodegen(gobj_4[0], gobj_5[0], gobj_6[0], robot);
    robot_not_empty = true;
  }

  //  Add additional body pairs to skip collision check
  //  adjacent bodies
  //  Ignore bodyA2 and bodyA4 collisions (limited by axis limits)
  //  Ignore bodyA4 and bodyTool collisions (limited by A5 axis limit)
  *isSelfColliding = robot.checkCollision(currentConfig, selfSeparationDist);

  //  Find NaN values in the matrix
  //  Reads collision table, finds collision pairs and outputs their indexes
  r.set_size(selfSeparationDist.size(0), selfSeparationDist.size(1));
  loop_ub_tmp = selfSeparationDist.size(0) * selfSeparationDist.size(1);
  for (int i{0}; i < loop_ub_tmp; i++) {
    r[i] = std::isnan(selfSeparationDist[i]);
  }

  coder::eml_find(r, ii, jj);

  //  Combine into output array
  if (ii.size(0) == 0) {
    collPairs[0] = 0.0;
    collPairs[1] = 0.0;
  } else {
    collPairs[0] = ii[0];
    collPairs[1] = jj[0];
  }

  //  0 - means no collision found
  //  1 - bodyBase
  //  2 - bodyA1
  //  3 - bodyA2
  //  4 - bodyA3
  //  5 - bodyA4
  //  6 - bodyA5
  //  7 - bodyA6
  //  8 - bodyEE
  //  9 - bodyTool
  //  10 - bodyToolEE
  //  11 - base
  //  ax=show(robot,currentConfig,"Collisions","on",PreservePlot=false,FastUpdate=true);
  //  rbtpatches=findobj(ax.Children,'Type','patch','-regexp','DisplayName','_mesh');
  //  set(rbtpatches,'FaceAlpha',0.2);
  //  hold on
  //  show(robot,currentConfig, "Collisions","off");
}

//
// Import Agrobot rbt model available for codegen
//
// Arguments    : const double currentConfig[6]
//                int whichEE
//                double robotSE3[16]
//                double pos[3]
//                double ori[3]
// Return Type  : void
//
void Matlab_getForwardKinematics(const double currentConfig[6], int whichEE,
  double robotSE3[16], double pos[3], double ori[3])
{
  double b_robotSE3[9];
  if (!isInitialized_Matlab_ik) {
    Matlab_ik_initialize();
  }

  //  Calculates bodyEE position and orientation in bodyBase frame for current robot configuration.
  //  Input:
  //  currentConfig - 1x6 array of robot configuration (axis angles in radians)
  //  whichEE       - integer (enum) representing what robot body to solve
  //                  FK for: 0 - bodyEE, 1 - bodyToolEE
  //  Output:
  //  se3   - 4x4 array representing homogeneous transformation matrix (SE3)
  //          between bodyEE and bodyBase
  //  pos   - 1x3 array representing x,y,z position of bodyEE in bodyBase
  //          frame
  //  ori   - 1x3 array [X Y Z] representing orientation of
  //          bodyEE in bodyBase frame in form of Euler angles (in radians)
  //          using ZYX intrinsic convention
  if (!b_robot_not_empty) {
    b_robot = rbtForCodegen(gobj_4[20], gobj_5[20], gobj_6[10], gobj_3[0]);
    b_robot_not_empty = true;
  }

  //  Choose between bodyEE and bodyToolEE
  if (whichEE == 0) {
    b_robot->getTransform(currentConfig, robotSE3);

    //  disp("bodyEE");
  } else {
    b_robot->b_getTransform(currentConfig, robotSE3);

    //  disp("bodyToolEE");
  }

  //  Get pos and ori
  //  first angle is around Z, then around Y and X - oriZYX = [Z Y X]
  for (int i{0}; i < 3; i++) {
    int robotSE3_tmp;
    pos[i] = robotSE3[i + 12];
    robotSE3_tmp = i << 2;
    b_robotSE3[3 * i] = robotSE3[robotSE3_tmp];
    b_robotSE3[3 * i + 1] = robotSE3[robotSE3_tmp + 1];
    b_robotSE3[3 * i + 2] = robotSE3[robotSE3_tmp + 2];
  }

  double oriZYX[3];
  coder::rotm2eul(b_robotSE3, oriZYX);

  //  To be consistent throughout the program, we rearrange [Z Y X] array into
  //  [X Y Z] array, but leaving ZYX Euler convention
  //  define variable for codegen
  ori[0] = oriZYX[2];
  ori[1] = oriZYX[1];
  ori[2] = oriZYX[0];

  //  ax=show(robot,currentConfig,"Collisions","on",PreservePlot=false,FastUpdate=true);
  //  rbtpatches=findobj(ax.Children,'Type','patch','-regexp','DisplayName','_mesh');
  //  set(rbtpatches,'FaceAlpha',0.2);
  //  hold on
  //  show(robot,currentConfig, "Collisions","off");
}

//
// Import Agrobot rbt model available for codegen
//
// Arguments    : const double currentConfig[6]
//                const double targetPos_Fin[3]
//                const struct0_T *solverParameters
//                double *exitCode
//                struct1_T *solutionInfoFin
//                double qWaypoint[6]
// Return Type  : void
//
void Matlab_getGikCut(const double currentConfig[6], const double targetPos_Fin
                      [3], const struct0_T *solverParameters, double *exitCode,
                      struct1_T *solutionInfoFin, double qWaypoint[6])
{
  static coder::generalizedInverseKinematics gik;
  static coder::rigidBodyJoint lobj_6[27];
  coder::constraintOrientationTarget orientToTarget;
  coder::constraintPositionTarget distanceFromTarget;
  coder::rigidBody targetFin;
  coder::rigidBodyJoint *b_value;
  coder::rigidBodyTree c_robot;
  coder::robotics::manip::internal::CollisionSet lobj_8[28];
  coder::robotics::manip::internal::RigidBody lobj_7[14];
  coder::robotics::manip::internal::RigidBodyTree lobj_5;
  coder::robotics::manip::internal::b_RigidBodyTree lobj_9;
  coder::se3 targetFin_SE3;
  double robotSE3[16];
  double targetFin_Rotm[9];
  double t5_GradientTolerance;
  double t5_MaxTime;
  double t5_SolutionTolerance;
  double t5_StepTolerance;
  int targetFin_Rotm_tmp;
  bool t5_AllowRandomRestart;
  bool t5_EnforceJointLimits;
  if (!isInitialized_Matlab_ik) {
    Matlab_ik_initialize();
  }

  for (int i{0}; i < 12; i++) {
    lobj_9._pobj2[i]._pobj0.matlabCodegenIsDeleted = true;
  }

  lobj_9._pobj0[0].matlabCodegenIsDeleted = true;
  lobj_9._pobj0[1].matlabCodegenIsDeleted = true;
  lobj_9._pobj0[2].matlabCodegenIsDeleted = true;
  lobj_9.Base._pobj0.matlabCodegenIsDeleted = true;
  for (int i{0}; i < 28; i++) {
    lobj_8[i].matlabCodegenIsDeleted = true;
  }

  for (int i{0}; i < 14; i++) {
    lobj_7[i]._pobj0.matlabCodegenIsDeleted = true;
  }

  lobj_5._pobj0.CollisionsInternal.matlabCodegenIsDeleted = true;
  lobj_5.Base.CollisionsInternal.matlabCodegenIsDeleted = true;
  for (int i{0}; i < 12; i++) {
    gik._pobj3._pobj2[i]._pobj0.matlabCodegenIsDeleted = true;
  }

  gik._pobj3._pobj0[0].matlabCodegenIsDeleted = true;
  gik._pobj3._pobj0[1].matlabCodegenIsDeleted = true;
  gik._pobj3._pobj0[2].matlabCodegenIsDeleted = true;
  gik._pobj3.Base._pobj0.matlabCodegenIsDeleted = true;
  for (int i{0}; i < 25; i++) {
    gik._pobj2[i].matlabCodegenIsDeleted = true;
  }

  for (int i{0}; i < 12; i++) {
    gik._pobj1[i]._pobj0.matlabCodegenIsDeleted = true;
  }

  for (int i{0}; i < 12; i++) {
    c_robot._pobj1._pobj2[i]._pobj0.matlabCodegenIsDeleted = true;
  }

  c_robot._pobj1._pobj0[0].matlabCodegenIsDeleted = true;
  c_robot._pobj1._pobj0[1].matlabCodegenIsDeleted = true;
  c_robot._pobj1._pobj0[2].matlabCodegenIsDeleted = true;
  c_robot._pobj1.Base._pobj0.matlabCodegenIsDeleted = true;
  c_robot._pobj0.matlabCodegenIsDeleted = true;
  for (int i{0}; i < 12; i++) {
    lobj_9._pobj2[i].matlabCodegenIsDeleted = true;
  }

  lobj_9.Base.matlabCodegenIsDeleted = true;
  for (int i{0}; i < 14; i++) {
    lobj_7[i].matlabCodegenIsDeleted = true;
  }

  for (int i{0}; i < 12; i++) {
    gik._pobj3._pobj2[i].matlabCodegenIsDeleted = true;
  }

  gik._pobj3.Base.matlabCodegenIsDeleted = true;
  for (int i{0}; i < 12; i++) {
    gik._pobj1[i].matlabCodegenIsDeleted = true;
  }

  for (int i{0}; i < 12; i++) {
    c_robot._pobj1._pobj2[i].matlabCodegenIsDeleted = true;
  }

  c_robot._pobj1.Base.matlabCodegenIsDeleted = true;
  lobj_9.matlabCodegenIsDeleted = true;
  gik._pobj3.matlabCodegenIsDeleted = true;
  c_robot._pobj1.matlabCodegenIsDeleted = true;
  c_robot.matlabCodegenIsDeleted = true;
  lobj_5._pobj0.matlabCodegenIsDeleted = true;
  lobj_5.Base.matlabCodegenIsDeleted = true;
  lobj_5.matlabCodegenIsDeleted = true;
  targetFin.matlabCodegenIsDeleted = true;
  gik.Problem._pobj1.matlabCodegenIsDeleted = true;
  gik.Problem._pobj0.matlabCodegenIsDeleted = true;
  gik.Problem.matlabCodegenIsDeleted = true;
  gik._pobj4.matlabCodegenIsDeleted = true;
  gik.matlabCodegenIsDeleted = true;

  //  Finds robot configuration only for Final Approach sequence.
  //  Input:
  //  currentConfig     - 1x6 array of robot configuration (axis angles in radians)
  //  target_Apr        - 1x8 array representing approach target xyz
  //                      position(1:3), orientation(4:7) as wxyz quaternion,
  //                      distance(8).
  //  targetPos_Fin     - 1x3 array representing final approach target xyz
  //                      position
  //  solverParameters  - struct, holds solver parameters
  //  Output:
  //  qWaypoint       - 1x6 array of robot configuration (axis angles in
  //                    radians) for Final Approach target.
  //  solutionInfoFin - struct that holds GIKsolver info about Final
  //                    Approach waypoint
  //  exitCode:
  //  0 - GIK fail
  //  1 - GIK success
  if (!robot_rbt_not_empty) {
    rbtForCodegen(gobj_4[60], gobj_5[60], gobj_6[30], robot_rbt);
    robot_rbt_not_empty = true;
  }

  robot_rbt.copy(lobj_6[0], lobj_7[0], lobj_8[0], lobj_9, c_robot);

  //  copy is non-persistent and can be modified to add target body to rbt
  //  Define waypoint array
  // qWaypoint = currentConfig;
  //  Define parameters of target bodies
  //  targetApr_Quat = target_Apr(4:7);
  //  %targetApr_Pos = target_Apr(1:3);
  //  targetApr_Rotm = quat2rotm(targetApr_Quat);
  //  %targetApr_SE3 = se3(targetApr_Rotm, targetApr_Pos);
  //  Import Agrobot rbt model available for codegen
  //  Calculates bodyEE position and orientation in bodyBase frame for current robot configuration.
  //  Input:
  //  currentConfig - 1x6 array of robot configuration (axis angles in radians)
  //  whichEE       - integer (enum) representing what robot body to solve
  //                  FK for: 0 - bodyEE, 1 - bodyToolEE
  //  Output:
  //  se3   - 4x4 array representing homogeneous transformation matrix (SE3)
  //          between bodyEE and bodyBase
  //  pos   - 1x3 array representing x,y,z position of bodyEE in bodyBase
  //          frame
  //  ori   - 1x3 array [X Y Z] representing orientation of
  //          bodyEE in bodyBase frame in form of Euler angles (in radians)
  //          using ZYX intrinsic convention
  if (!b_robot_not_empty) {
    b_robot = rbtForCodegen(gobj_4[40], gobj_5[40], gobj_6[20], gobj_3[1]);
    b_robot_not_empty = true;
  }

  //  Choose between bodyEE and bodyToolEE
  b_robot->b_getTransform(currentConfig, robotSE3);

  //  disp("bodyToolEE");
  //  Get pos and ori
  //  first angle is around Z, then around Y and X - oriZYX = [Z Y X]
  //  To be consistent throughout the program, we rearrange [Z Y X] array into
  //  [X Y Z] array, but leaving ZYX Euler convention
  //  define variable for codegen
  //  ax=show(robot,currentConfig,"Collisions","on",PreservePlot=false,FastUpdate=true);
  //  rbtpatches=findobj(ax.Children,'Type','patch','-regexp','DisplayName','_mesh');
  //  set(rbtpatches,'FaceAlpha',0.2);
  //  hold on
  //  show(robot,currentConfig, "Collisions","off");
  for (int i{0}; i < 3; i++) {
    targetFin_Rotm_tmp = i << 2;
    targetFin_Rotm[3 * i] = robotSE3[targetFin_Rotm_tmp];
    targetFin_Rotm[3 * i + 1] = robotSE3[targetFin_Rotm_tmp + 1];
    targetFin_Rotm[3 * i + 2] = robotSE3[targetFin_Rotm_tmp + 2];
  }

  double t5_MaxIterations;
  targetFin_SE3.init(targetFin_Rotm, targetPos_Fin);
  targetFin.k_init(lobj_5, lobj_8[25], lobj_6[24], lobj_7[12]);
  b_value = targetFin.BodyInternal->JointInternal;
  b_value->setFixedTransform(targetFin_SE3.M);
  c_robot.b_addBody(targetFin, lobj_8[26], lobj_6[25], lobj_7[13]);

  //     %% Solve GIK for Final Approach
  gik.init(c_robot);

  //  Define solver parameters
  gik.get_SolverParameters(t5_MaxTime, t5_GradientTolerance,
    t5_SolutionTolerance, t5_EnforceJointLimits, t5_AllowRandomRestart,
    t5_StepTolerance);
  gik.set_SolverParameters(solverParameters->maxIterations, t5_MaxTime,
    t5_GradientTolerance, t5_SolutionTolerance, t5_EnforceJointLimits,
    t5_AllowRandomRestart, t5_StepTolerance);
  t5_MaxIterations = gik.get_SolverParameters(t5_MaxTime, t5_GradientTolerance,
    t5_SolutionTolerance, t5_EnforceJointLimits, t5_AllowRandomRestart,
    t5_StepTolerance);
  gik.set_SolverParameters(t5_MaxIterations, solverParameters->maxTime,
    t5_GradientTolerance, t5_SolutionTolerance, t5_EnforceJointLimits,
    t5_AllowRandomRestart, t5_StepTolerance);
  t5_MaxIterations = gik.get_SolverParameters(t5_MaxTime, t5_GradientTolerance,
    t5_SolutionTolerance, t5_EnforceJointLimits, t5_AllowRandomRestart,
    t5_StepTolerance);
  gik.set_SolverParameters(t5_MaxIterations, t5_MaxTime, t5_GradientTolerance,
    t5_SolutionTolerance, solverParameters->enforceJointLimits,
    t5_AllowRandomRestart, t5_StepTolerance);
  t5_MaxIterations = gik.get_SolverParameters(t5_MaxTime, t5_GradientTolerance,
    t5_SolutionTolerance, t5_EnforceJointLimits, t5_AllowRandomRestart,
    t5_StepTolerance);
  gik.set_SolverParameters(t5_MaxIterations, t5_MaxTime, t5_GradientTolerance,
    t5_SolutionTolerance, t5_EnforceJointLimits, t5_AllowRandomRestart,
    t5_StepTolerance);
  t5_MaxIterations = gik.get_SolverParameters(t5_MaxTime, t5_GradientTolerance,
    t5_SolutionTolerance, t5_EnforceJointLimits, t5_AllowRandomRestart,
    t5_StepTolerance);
  gik.set_SolverParameters(t5_MaxIterations, t5_MaxTime, t5_GradientTolerance,
    t5_SolutionTolerance, t5_EnforceJointLimits, t5_AllowRandomRestart,
    solverParameters->stepTolerance);

  //  Distance constraint (position of the target relative to ee)
  distanceFromTarget.init();
  distanceFromTarget.TargetPosition[0] = 0.0;
  distanceFromTarget.TargetPosition[1] = 0.0;
  distanceFromTarget.TargetPosition[2] = 0.0;
  distanceFromTarget.ReferenceBody.set_size(1, 10);
  for (int i{0}; i < 10; i++) {
    distanceFromTarget.ReferenceBody[i] = cv3[i];
  }

  double dv[4];
  distanceFromTarget.PositionTolerance = 0.02;
  distanceFromTarget.Weights = 1.0;

  //  Orientation constraint (ee is oriented perpendicular to the branch)
  orientToTarget.init();
  orientToTarget.ReferenceBody.set_size(1, 0);
  coder::rotm2quat(targetFin_Rotm, dv);
  orientToTarget.set_TargetOrientation(dv);
  orientToTarget.OrientationTolerance = 0.1;
  orientToTarget.Weights = 1.0;

  //  Find configuration for Approach
  solutionInfoFin->Iterations = gik.step(currentConfig, distanceFromTarget,
    orientToTarget, qWaypoint, solutionInfoFin->ConstraintViolations,
    solutionInfoFin->Status.data, solutionInfoFin->Status.size,
    solutionInfoFin->NumRandomRestarts, solutionInfoFin->ExitFlag);
  if (coder::string::eq(solutionInfoFin->Status.data,
                        solutionInfoFin->Status.size)) {
    targetFin_Rotm_tmp = 1;
  } else {
    targetFin_Rotm_tmp = 0;
    for (int i{0}; i < 6; i++) {
      qWaypoint[i] = currentConfig[i];
    }
  }

  gik.matlabCodegenDestructor();
  gik._pobj4.matlabCodegenDestructor();
  gik.Problem.matlabCodegenDestructor();
  gik.Problem._pobj0.matlabCodegenDestructor();
  gik.Problem._pobj1.matlabCodegenDestructor();
  targetFin.matlabCodegenDestructor();
  lobj_5.matlabCodegenDestructor();
  lobj_5.Base.matlabCodegenDestructor();
  lobj_5._pobj0.matlabCodegenDestructor();
  c_robot.matlabCodegenDestructor();
  c_robot._pobj1.matlabCodegenDestructor();
  gik._pobj3.matlabCodegenDestructor();
  lobj_9.matlabCodegenDestructor();
  c_robot._pobj1.Base.matlabCodegenDestructor();
  for (int i{0}; i < 12; i++) {
    c_robot._pobj1._pobj2[i].matlabCodegenDestructor();
  }

  for (int i{0}; i < 12; i++) {
    gik._pobj1[i].matlabCodegenDestructor();
  }

  gik._pobj3.Base.matlabCodegenDestructor();
  for (int i{0}; i < 12; i++) {
    gik._pobj3._pobj2[i].matlabCodegenDestructor();
  }

  for (int i{0}; i < 14; i++) {
    lobj_7[i].matlabCodegenDestructor();
  }

  lobj_9.Base.matlabCodegenDestructor();
  for (int i{0}; i < 12; i++) {
    lobj_9._pobj2[i].matlabCodegenDestructor();
  }

  c_robot._pobj0.matlabCodegenDestructor();
  c_robot._pobj1.Base._pobj0.matlabCodegenDestructor();
  c_robot._pobj1._pobj0[0].matlabCodegenDestructor();
  c_robot._pobj1._pobj0[1].matlabCodegenDestructor();
  c_robot._pobj1._pobj0[2].matlabCodegenDestructor();
  for (int i{0}; i < 12; i++) {
    c_robot._pobj1._pobj2[i]._pobj0.matlabCodegenDestructor();
  }

  for (int i{0}; i < 12; i++) {
    gik._pobj1[i]._pobj0.matlabCodegenDestructor();
  }

  for (int i{0}; i < 25; i++) {
    gik._pobj2[i].matlabCodegenDestructor();
  }

  gik._pobj3.Base._pobj0.matlabCodegenDestructor();
  gik._pobj3._pobj0[0].matlabCodegenDestructor();
  gik._pobj3._pobj0[1].matlabCodegenDestructor();
  gik._pobj3._pobj0[2].matlabCodegenDestructor();
  for (int i{0}; i < 12; i++) {
    gik._pobj3._pobj2[i]._pobj0.matlabCodegenDestructor();
  }

  lobj_5.Base.CollisionsInternal.matlabCodegenDestructor();
  lobj_5._pobj0.CollisionsInternal.matlabCodegenDestructor();
  for (int i{0}; i < 14; i++) {
    lobj_7[i]._pobj0.matlabCodegenDestructor();
  }

  for (int i{0}; i < 28; i++) {
    lobj_8[i].matlabCodegenDestructor();
  }

  lobj_9.Base._pobj0.matlabCodegenDestructor();
  lobj_9._pobj0[0].matlabCodegenDestructor();
  lobj_9._pobj0[1].matlabCodegenDestructor();
  lobj_9._pobj0[2].matlabCodegenDestructor();
  for (int i{0}; i < 12; i++) {
    lobj_9._pobj2[i]._pobj0.matlabCodegenDestructor();
  }

  *exitCode = targetFin_Rotm_tmp;
}

//
// Import Agrobot rbt model available for codegen
//
// Arguments    : const double currentConfig[6]
//                const double target_Apr[8]
//                const double targetPos_Fin[3]
//                const struct0_T *solverParameters
//                double *exitCode
//                struct1_T *solutionInfoApr
//                double qWaypoints[18]
// Return Type  : void
//
void Matlab_getGikFull(const double currentConfig[6], const double target_Apr[8],
  const double targetPos_Fin[3], const struct0_T *solverParameters, double
  *exitCode, struct1_T *solutionInfoApr, double qWaypoints[18])
{
  static coder::generalizedInverseKinematics gik;
  static coder::rigidBodyJoint lobj_9[30];
  coder::constraintOrientationTarget b_orientToTarget;
  coder::constraintOrientationTarget orientToTarget;
  coder::constraintPositionTarget b_distanceFromTarget;
  coder::constraintPositionTarget distanceFromTarget;
  coder::rigidBody targetApr;
  coder::rigidBody targetFin;
  coder::rigidBodyJoint *b_value;
  coder::rigidBodyTree c_robot;
  coder::robotics::manip::internal::CollisionSet lobj_11[31];
  coder::robotics::manip::internal::RigidBody lobj_10[16];
  coder::robotics::manip::internal::RigidBodyTree lobj_8[2];
  coder::robotics::manip::internal::b_RigidBodyTree lobj_12;
  coder::se3 targetApr_SE3;
  coder::se3 targetFin_SE3;
  struct1_T varargout_2;
  double qWaypoints_tmp[18];
  double targetApr_Rotm[9];
  double varargout_1[6];
  double t2_GradientTolerance;
  double t2_MaxIterations;
  double t2_MaxTime;
  double t2_SolutionTolerance;
  double t2_StepTolerance;
  int b_exitCode;
  bool t2_AllowRandomRestart;
  bool t2_EnforceJointLimits;
  if (!isInitialized_Matlab_ik) {
    Matlab_ik_initialize();
  }

  for (int i{0}; i < 12; i++) {
    lobj_12._pobj2[i]._pobj0.matlabCodegenIsDeleted = true;
  }

  lobj_12._pobj0[0].matlabCodegenIsDeleted = true;
  lobj_12._pobj0[1].matlabCodegenIsDeleted = true;
  lobj_12._pobj0[2].matlabCodegenIsDeleted = true;
  lobj_12.Base._pobj0.matlabCodegenIsDeleted = true;
  for (int i{0}; i < 31; i++) {
    lobj_11[i].matlabCodegenIsDeleted = true;
  }

  for (int i{0}; i < 16; i++) {
    lobj_10[i]._pobj0.matlabCodegenIsDeleted = true;
  }

  lobj_8[0]._pobj0.CollisionsInternal.matlabCodegenIsDeleted = true;
  lobj_8[1]._pobj0.CollisionsInternal.matlabCodegenIsDeleted = true;
  lobj_8[0].Base.CollisionsInternal.matlabCodegenIsDeleted = true;
  lobj_8[1].Base.CollisionsInternal.matlabCodegenIsDeleted = true;
  for (int i{0}; i < 12; i++) {
    gik._pobj3._pobj2[i]._pobj0.matlabCodegenIsDeleted = true;
  }

  gik._pobj3._pobj0[0].matlabCodegenIsDeleted = true;
  gik._pobj3._pobj0[1].matlabCodegenIsDeleted = true;
  gik._pobj3._pobj0[2].matlabCodegenIsDeleted = true;
  gik._pobj3.Base._pobj0.matlabCodegenIsDeleted = true;
  for (int i{0}; i < 25; i++) {
    gik._pobj2[i].matlabCodegenIsDeleted = true;
  }

  for (int i{0}; i < 12; i++) {
    gik._pobj1[i]._pobj0.matlabCodegenIsDeleted = true;
  }

  for (int i{0}; i < 12; i++) {
    c_robot._pobj1._pobj2[i]._pobj0.matlabCodegenIsDeleted = true;
  }

  c_robot._pobj1._pobj0[0].matlabCodegenIsDeleted = true;
  c_robot._pobj1._pobj0[1].matlabCodegenIsDeleted = true;
  c_robot._pobj1._pobj0[2].matlabCodegenIsDeleted = true;
  c_robot._pobj1.Base._pobj0.matlabCodegenIsDeleted = true;
  c_robot._pobj0.matlabCodegenIsDeleted = true;
  for (int i{0}; i < 12; i++) {
    lobj_12._pobj2[i].matlabCodegenIsDeleted = true;
  }

  lobj_12.Base.matlabCodegenIsDeleted = true;
  for (int i{0}; i < 16; i++) {
    lobj_10[i].matlabCodegenIsDeleted = true;
  }

  for (int i{0}; i < 12; i++) {
    gik._pobj3._pobj2[i].matlabCodegenIsDeleted = true;
  }

  gik._pobj3.Base.matlabCodegenIsDeleted = true;
  for (int i{0}; i < 12; i++) {
    gik._pobj1[i].matlabCodegenIsDeleted = true;
  }

  for (int i{0}; i < 12; i++) {
    c_robot._pobj1._pobj2[i].matlabCodegenIsDeleted = true;
  }

  c_robot._pobj1.Base.matlabCodegenIsDeleted = true;
  lobj_12.matlabCodegenIsDeleted = true;
  gik._pobj3.matlabCodegenIsDeleted = true;
  c_robot._pobj1.matlabCodegenIsDeleted = true;
  c_robot.matlabCodegenIsDeleted = true;
  lobj_8[0]._pobj0.matlabCodegenIsDeleted = true;
  lobj_8[1]._pobj0.matlabCodegenIsDeleted = true;
  lobj_8[0].Base.matlabCodegenIsDeleted = true;
  lobj_8[1].Base.matlabCodegenIsDeleted = true;
  lobj_8[0].matlabCodegenIsDeleted = true;
  lobj_8[1].matlabCodegenIsDeleted = true;
  targetFin.matlabCodegenIsDeleted = true;
  targetApr.matlabCodegenIsDeleted = true;
  gik.Problem._pobj1.matlabCodegenIsDeleted = true;
  gik.Problem._pobj0.matlabCodegenIsDeleted = true;
  gik.Problem.matlabCodegenIsDeleted = true;
  gik._pobj4.matlabCodegenIsDeleted = true;
  gik.matlabCodegenIsDeleted = true;

  //  Finds robot configurations for Approach and Final Approach sequence.
  //  Input:
  //  currentConfig     - 1x6 array of robot configuration (axis angles in radians)
  //  target_Apr        - 1x8 array representing approach target xyz
  //                      position(1:3), orientation(4:7) as wxyz quaternion,
  //                      distance(8).
  //  targetPos_Fin     - 1x3 array representing final approach target xyz
  //                      position
  //  solverParameters  - struct, holds solver parameters
  //  Output:
  //  qWaypoints      - 3x6 array of robot configurations (axis angles in
  //                    radians). 1st row - current config, 2nd - approach
  //                    target, 3rd - final approach target.
  //  solutionInfoApr - struct that holds GIKsolver info about second
  //                    waypoint (Approach sequence)
  //  exitCode:
  //  0 - GIK fail
  //  1 - GIK success
  //  2 - GIK final approach fail
  if (!b_robot_rbt_not_empty) {
    rbtForCodegen(gobj_4[80], gobj_5[80], gobj_6[40], b_robot_rbt);
    b_robot_rbt_not_empty = true;
  }

  b_robot_rbt.copy(lobj_9[0], lobj_10[0], lobj_11[0], lobj_12, c_robot);

  //  copy is non-persistent and can be modified to add target body to rbt
  //  Define waypoint array
  coder::repmat(currentConfig, qWaypoints_tmp);
  std::copy(&qWaypoints_tmp[0], &qWaypoints_tmp[18], &qWaypoints[0]);

  //  Define parameters of target bodies
  coder::robotics::internal::quat2rotm(&target_Apr[3], targetApr_Rotm);
  targetApr_SE3.init(targetApr_Rotm, &target_Apr[0]);
  targetFin_SE3.init(targetApr_Rotm, targetPos_Fin);

  //  Add target bodies to rbt
  targetApr.l_init(lobj_8[0], lobj_11[25], lobj_9[24], lobj_10[12]);
  b_value = targetApr.BodyInternal->JointInternal;
  b_value->setFixedTransform(targetApr_SE3.M);
  c_robot.b_addBody(targetApr, lobj_11[26], lobj_9[25], lobj_10[13]);
  targetFin.k_init(lobj_8[1], lobj_11[28], lobj_9[27], lobj_10[14]);
  b_value = targetFin.BodyInternal->JointInternal;
  b_value->setFixedTransform(targetFin_SE3.M);
  c_robot.b_addBody(targetFin, lobj_11[29], lobj_9[28], lobj_10[15]);

  //     %% Solve GIK for Approach
  gik.init(c_robot);

  //  Define solver parameters
  gik.get_SolverParameters(t2_MaxTime, t2_GradientTolerance,
    t2_SolutionTolerance, t2_EnforceJointLimits, t2_AllowRandomRestart,
    t2_StepTolerance);
  gik.set_SolverParameters(solverParameters->maxIterations, t2_MaxTime,
    t2_GradientTolerance, t2_SolutionTolerance, t2_EnforceJointLimits,
    t2_AllowRandomRestart, t2_StepTolerance);
  t2_MaxIterations = gik.get_SolverParameters(t2_MaxTime, t2_GradientTolerance,
    t2_SolutionTolerance, t2_EnforceJointLimits, t2_AllowRandomRestart,
    t2_StepTolerance);
  gik.set_SolverParameters(t2_MaxIterations, solverParameters->maxTime,
    t2_GradientTolerance, t2_SolutionTolerance, t2_EnforceJointLimits,
    t2_AllowRandomRestart, t2_StepTolerance);
  t2_MaxIterations = gik.get_SolverParameters(t2_MaxTime, t2_GradientTolerance,
    t2_SolutionTolerance, t2_EnforceJointLimits, t2_AllowRandomRestart,
    t2_StepTolerance);
  gik.set_SolverParameters(t2_MaxIterations, t2_MaxTime, t2_GradientTolerance,
    t2_SolutionTolerance, solverParameters->enforceJointLimits,
    t2_AllowRandomRestart, t2_StepTolerance);
  t2_MaxIterations = gik.get_SolverParameters(t2_MaxTime, t2_GradientTolerance,
    t2_SolutionTolerance, t2_EnforceJointLimits, t2_AllowRandomRestart,
    t2_StepTolerance);
  gik.set_SolverParameters(t2_MaxIterations, t2_MaxTime, t2_GradientTolerance,
    t2_SolutionTolerance, t2_EnforceJointLimits, t2_AllowRandomRestart,
    t2_StepTolerance);
  t2_MaxIterations = gik.get_SolverParameters(t2_MaxTime, t2_GradientTolerance,
    t2_SolutionTolerance, t2_EnforceJointLimits, t2_AllowRandomRestart,
    t2_StepTolerance);
  gik.set_SolverParameters(t2_MaxIterations, t2_MaxTime, t2_GradientTolerance,
    t2_SolutionTolerance, t2_EnforceJointLimits, t2_AllowRandomRestart,
    solverParameters->stepTolerance);

  //  Distance constraint (position of the target relative to ee)
  distanceFromTarget.b_init();
  distanceFromTarget.TargetPosition[0] = 0.0;
  distanceFromTarget.TargetPosition[1] = 0.0;
  distanceFromTarget.TargetPosition[2] = 0.0;
  distanceFromTarget.ReferenceBody.set_size(1, 10);
  for (int i{0}; i < 10; i++) {
    distanceFromTarget.ReferenceBody[i] = cv3[i];
  }

  distanceFromTarget.PositionTolerance = solverParameters->positionTolerance;
  distanceFromTarget.Weights = 1.0;

  //  Orientation constraint (ee is oriented perpendicular to the branch)
  orientToTarget.init();
  orientToTarget.ReferenceBody.set_size(1, 0);
  orientToTarget.set_TargetOrientation(&target_Apr[3]);
  orientToTarget.OrientationTolerance = solverParameters->orientationTolerance;
  orientToTarget.Weights = 1.0;

  //  Find configuration for Approach
  solutionInfoApr->Iterations = gik.step(currentConfig, distanceFromTarget,
    orientToTarget, varargout_1, solutionInfoApr->ConstraintViolations,
    solutionInfoApr->Status.data, solutionInfoApr->Status.size,
    solutionInfoApr->NumRandomRestarts, solutionInfoApr->ExitFlag);
  for (int i{0}; i < 6; i++) {
    qWaypoints[3 * i + 1] = varargout_1[i];
  }

  //     %% Solve GIK for Final Approach
  if (coder::string::eq(solutionInfoApr->Status.data,
                        solutionInfoApr->Status.size)) {
    double b_qWaypoints[6];

    //  Distance constraint (position of the target relative to ee)
    b_distanceFromTarget.init();
    b_distanceFromTarget.TargetPosition[0] = 0.0;
    b_distanceFromTarget.TargetPosition[1] = 0.0;
    b_distanceFromTarget.TargetPosition[2] = 0.0;
    b_distanceFromTarget.ReferenceBody.set_size(1, 10);
    for (int i{0}; i < 10; i++) {
      b_distanceFromTarget.ReferenceBody[i] = cv3[i];
    }

    b_distanceFromTarget.PositionTolerance = 0.02;
    b_distanceFromTarget.Weights = 1.0;

    //  Orientation constraint (ee is oriented perpendicular to the branch)
    b_orientToTarget.init();
    b_orientToTarget.ReferenceBody.set_size(1, 0);
    b_orientToTarget.set_TargetOrientation(&target_Apr[3]);
    b_orientToTarget.OrientationTolerance = 0.1;
    b_orientToTarget.Weights = 1.0;

    //  Find configuration for Approach
    for (int i{0}; i < 6; i++) {
      b_qWaypoints[i] = qWaypoints[3 * i + 1];
    }

    gik.step(b_qWaypoints, b_distanceFromTarget, b_orientToTarget, varargout_1,
             varargout_2.ConstraintViolations, varargout_2.Status.data,
             varargout_2.Status.size, varargout_2.NumRandomRestarts,
             varargout_2.ExitFlag);
    for (int i{0}; i < 6; i++) {
      qWaypoints[3 * i + 2] = varargout_1[i];
    }

    b_exitCode = 1;

    //  GIK success
    if (!coder::string::eq(varargout_2.Status.data, varargout_2.Status.size)) {
      b_exitCode = 2;

      //  GIK final fail
      //  null the output waypoints to start pos for safety reasons
      std::copy(&qWaypoints_tmp[0], &qWaypoints_tmp[18], &qWaypoints[0]);
    }
  } else {
    b_exitCode = 0;

    //  GIK fail
    //  null the output waypoints to start pos for safety reasons
    std::copy(&qWaypoints_tmp[0], &qWaypoints_tmp[18], &qWaypoints[0]);
  }

  //  Generate exitCode for getGikFull function
  //  show(robot, [0.557980695364034	1.25045256408617	-0.398801085092071	-0.394195354277417	-0.731201976630953	-1.63818517500080], "Collisions","on")
  //  hold on
  //  show(robot, [0.370296910018495	0.724787192733428	-0.295877929183845	-0.537837423981621	-0.382103087250922	-1.65130973041897],"Collisions","on")
  //  hold on
  //  show(robot, [0.424798922464564	0.668030966401696	-0.314323446757137	2.14887925715986	0.326676403915757	0.915171616691025],"Collisions","on")
  gik.matlabCodegenDestructor();
  gik._pobj4.matlabCodegenDestructor();
  gik.Problem.matlabCodegenDestructor();
  gik.Problem._pobj0.matlabCodegenDestructor();
  gik.Problem._pobj1.matlabCodegenDestructor();
  targetApr.matlabCodegenDestructor();
  targetFin.matlabCodegenDestructor();
  lobj_8[0].matlabCodegenDestructor();
  lobj_8[1].matlabCodegenDestructor();
  lobj_8[0].Base.matlabCodegenDestructor();
  lobj_8[1].Base.matlabCodegenDestructor();
  lobj_8[0]._pobj0.matlabCodegenDestructor();
  lobj_8[1]._pobj0.matlabCodegenDestructor();
  c_robot.matlabCodegenDestructor();
  c_robot._pobj1.matlabCodegenDestructor();
  gik._pobj3.matlabCodegenDestructor();
  lobj_12.matlabCodegenDestructor();
  c_robot._pobj1.Base.matlabCodegenDestructor();
  for (int i{0}; i < 12; i++) {
    c_robot._pobj1._pobj2[i].matlabCodegenDestructor();
  }

  for (int i{0}; i < 12; i++) {
    gik._pobj1[i].matlabCodegenDestructor();
  }

  gik._pobj3.Base.matlabCodegenDestructor();
  for (int i{0}; i < 12; i++) {
    gik._pobj3._pobj2[i].matlabCodegenDestructor();
  }

  for (int i{0}; i < 16; i++) {
    lobj_10[i].matlabCodegenDestructor();
  }

  lobj_12.Base.matlabCodegenDestructor();
  for (int i{0}; i < 12; i++) {
    lobj_12._pobj2[i].matlabCodegenDestructor();
  }

  c_robot._pobj0.matlabCodegenDestructor();
  c_robot._pobj1.Base._pobj0.matlabCodegenDestructor();
  c_robot._pobj1._pobj0[0].matlabCodegenDestructor();
  c_robot._pobj1._pobj0[1].matlabCodegenDestructor();
  c_robot._pobj1._pobj0[2].matlabCodegenDestructor();
  for (int i{0}; i < 12; i++) {
    c_robot._pobj1._pobj2[i]._pobj0.matlabCodegenDestructor();
  }

  for (int i{0}; i < 12; i++) {
    gik._pobj1[i]._pobj0.matlabCodegenDestructor();
  }

  for (int i{0}; i < 25; i++) {
    gik._pobj2[i].matlabCodegenDestructor();
  }

  gik._pobj3.Base._pobj0.matlabCodegenDestructor();
  gik._pobj3._pobj0[0].matlabCodegenDestructor();
  gik._pobj3._pobj0[1].matlabCodegenDestructor();
  gik._pobj3._pobj0[2].matlabCodegenDestructor();
  for (int i{0}; i < 12; i++) {
    gik._pobj3._pobj2[i]._pobj0.matlabCodegenDestructor();
  }

  lobj_8[0].Base.CollisionsInternal.matlabCodegenDestructor();
  lobj_8[1].Base.CollisionsInternal.matlabCodegenDestructor();
  lobj_8[0]._pobj0.CollisionsInternal.matlabCodegenDestructor();
  lobj_8[1]._pobj0.CollisionsInternal.matlabCodegenDestructor();
  for (int i{0}; i < 16; i++) {
    lobj_10[i]._pobj0.matlabCodegenDestructor();
  }

  for (int i{0}; i < 31; i++) {
    lobj_11[i].matlabCodegenDestructor();
  }

  lobj_12.Base._pobj0.matlabCodegenDestructor();
  lobj_12._pobj0[0].matlabCodegenDestructor();
  lobj_12._pobj0[1].matlabCodegenDestructor();
  lobj_12._pobj0[2].matlabCodegenDestructor();
  for (int i{0}; i < 12; i++) {
    lobj_12._pobj2[i]._pobj0.matlabCodegenDestructor();
  }

  *exitCode = b_exitCode;
}

//
// Arguments    : double R
//                const double branchStart[3]
//                const double branchEnd[3]
//                double numCirclePoints
//                const double pos_toolEE[3]
//                coder::array<double, 2U> &sortedList
//                double *listLength
// Return Type  : void
//
void Matlab_getSortedCirclePointList(double R, const double branchStart[3],
  const double branchEnd[3], double numCirclePoints, const double pos_toolEE[3],
  coder::array<double, 2U> &sortedList, double *listLength)
{
  coder::array<double, 2U> b_result;
  coder::array<double, 2U> f;
  coder::array<double, 2U> pointList;
  coder::array<double, 2U> quats;
  coder::array<double, 2U> r;
  coder::array<double, 2U> t2;
  coder::array<double, 2U> targets_with_distances;
  coder::array<double, 2U> x2;
  coder::array<double, 2U> y2;
  coder::array<double, 2U> z2;
  coder::array<double, 1U> distances;
  coder::array<int, 1U> iidx;
  double X_dir[3];
  double vdir[3];
  double vn[3];
  double Z_dir_idx_0;
  double d;
  double phi;
  double theta;
  int i;
  int k;
  int loop_ub;
  int nx;
  int result;
  signed char input_sizes_idx_1;
  signed char sizes_idx_1;
  bool b;
  bool empty_non_axis_sizes;
  if (!isInitialized_Matlab_ik) {
    Matlab_ik_initialize();
  }

  //  Draws a circle around target branch, calculates points on that circle
  //  and sorts them based on distance from the robot's bodyToolEE
  //  Input:
  //  R                 - double, radius of the circle (in meters)
  //  branchStart       - 1x3 array representing [x y z] position of the
  //                      cutting point
  //  branchEnd         - 1x3 array representing [x y z] position of the
  //                      target branch end or any point on the branch in
  //                      the direction of the branch growth
  //  numCirclePoints   - double, defines how many evenly spaced points on
  //                      the circle to output
  //  pos_toolEE        - 1x3 array representing [x y z] position of the
  //                      robot's bodyToolEE (scissor's end effector)
  //  Output:
  //  sortedList        - Nx8 array of points on the circle with orientation
  //                      (Z toward center, Y inverted normal). Each point
  //                      represented by xyz position (col1:3), quaternion
  //                      (col4:7-wxyz) and distance to bodyToolEE (col8).
  //                      N is defined with numCirclePoints.
  //  listLength        - double, represents the number of rows in
  //                      sortedList. Should be the same as numCirclePoints
  vdir[0] = branchEnd[0] - branchStart[0];
  vdir[1] = branchEnd[1] - branchStart[1];
  vdir[2] = branchEnd[2] - branchStart[2];
  d = coder::b_norm(vdir);
  vn[0] = vdir[0] / d;
  vn[1] = vdir[1] / d;
  vn[2] = vdir[2] / d;
  phi = coder::internal::scalar::b_atan2(vn[1], vn[0]);

  // azimuth angle, in [-pi, pi]
  theta = coder::internal::scalar::b_atan2(std::sqrt(vn[0] * vn[0] + vn[1] * vn
    [1]), vn[2]);

  //  zenith angle, in [0,pi]
  //  Compute points for robot configurations
  d = 6.2831853071795862 / numCirclePoints;
  if (std::isnan(d)) {
    t2.set_size(1, 1);
    t2[0] = rtNaN;
  } else if ((d == 0.0) || (d < 0.0)) {
    t2.set_size(1, 0);
  } else if (std::isinf(d)) {
    t2.set_size(1, 1);
    t2[0] = 0.0;
  } else if (std::floor(d) == d) {
    loop_ub = static_cast<int>(6.2731853071795864 / d);
    t2.set_size(1, loop_ub + 1);
    for (i = 0; i <= loop_ub; i++) {
      t2[i] = d * static_cast<double>(i);
    }
  } else {
    coder::eml_float_colon(d, t2);
  }

  // exclude double point because 0 = 2pi
  Z_dir_idx_0 = std::sin(phi);
  loop_ub = t2.size(1);
  y2.set_size(1, t2.size(1));
  d = std::cos(phi);
  z2.set_size(1, t2.size(1));
  for (i = 0; i < loop_ub; i++) {
    y2[i] = t2[i];
    z2[i] = t2[i];
  }

  nx = y2.size(1);
  for (k = 0; k < nx; k++) {
    y2[k] = std::cos(y2[k]);
  }

  nx = z2.size(1);
  for (k = 0; k < nx; k++) {
    z2[k] = std::sin(z2[k]);
  }

  phi = std::cos(theta);
  k = y2.size(1);
  x2.set_size(1, y2.size(1));
  for (i = 0; i < k; i++) {
    x2[i] = branchStart[0] - R * (y2[i] * Z_dir_idx_0 + z2[i] * phi * d);
  }

  y2.set_size(1, y2.size(1));
  nx = y2.size(1) - 1;
  for (i = 0; i <= nx; i++) {
    y2[i] = branchStart[1] + R * (y2[i] * d - z2[i] * phi * Z_dir_idx_0);
  }

  Z_dir_idx_0 = std::sin(theta);
  z2.set_size(1, z2.size(1));
  nx = z2.size(1) - 1;
  for (i = 0; i <= nx; i++) {
    z2[i] = branchStart[2] + R * z2[i] * Z_dir_idx_0;
  }

  //  Save a set of positions
  f.set_size(y2.size(1), 3);
  for (i = 0; i < k; i++) {
    f[i] = x2[i];
    f[i + f.size(0)] = y2[i];
  }

  k = z2.size(1);
  for (i = 0; i < k; i++) {
    f[i + f.size(0) * 2] = z2[i];
  }

  //  Compute orientation in every position (as quaternions)
  quats.set_size(t2.size(1), 4);
  for (nx = 0; nx < loop_ub; nx++) {
    double b_X_dir[9];
    double dv[4];
    double Z_dir_idx_2;

    //  Z-axis: towards the circle center (vstart)
    vdir[0] = branchStart[0] - x2[nx];
    vdir[1] = branchStart[1] - y2[nx];
    vdir[2] = branchStart[2] - z2[nx];
    d = coder::b_norm(vdir);

    //  Normalized
    //  Y-axis: opposite to the normal vector vn
    phi = coder::b_norm(vn);
    Z_dir_idx_0 = vdir[0] / d;
    vdir[0] = -vn[0] / phi;
    theta = vdir[1] / d;
    vdir[1] = -vn[1] / phi;
    Z_dir_idx_2 = vdir[2] / d;
    vdir[2] = -vn[2] / phi;

    //  Ensure it's normalized and flipped
    //  X-axis: ensuring right-handed coordinate system
    X_dir[0] = vdir[1] * Z_dir_idx_2 - theta * vdir[2];
    X_dir[1] = Z_dir_idx_0 * vdir[2] - vdir[0] * Z_dir_idx_2;
    X_dir[2] = vdir[0] * theta - Z_dir_idx_0 * vdir[1];
    d = coder::b_norm(X_dir);

    //  Normalize
    //  Construct rotation matrix [X, Y, Z]
    //  Convert to quaternion
    b_X_dir[0] = X_dir[0] / d;
    b_X_dir[3] = vdir[0];
    b_X_dir[6] = Z_dir_idx_0;
    b_X_dir[1] = X_dir[1] / d;
    b_X_dir[4] = vdir[1];
    b_X_dir[7] = theta;
    b_X_dir[2] = X_dir[2] / d;
    b_X_dir[5] = vdir[2];
    b_X_dir[8] = Z_dir_idx_2;
    coder::rotm2quat(b_X_dir, dv);
    quats[nx] = dv[0];
    quats[nx + quats.size(0)] = dv[1];
    quats[nx + quats.size(0) * 2] = dv[2];
    quats[nx + quats.size(0) * 3] = dv[3];
  }

  if (f.size(0) != 0) {
    result = y2.size(1);
  } else if (quats.size(0) != 0) {
    result = t2.size(1);
  } else {
    result = 0;
  }

  empty_non_axis_sizes = (result == 0);
  if (empty_non_axis_sizes || (f.size(0) != 0)) {
    input_sizes_idx_1 = 3;
  } else {
    input_sizes_idx_1 = 0;
  }

  if (empty_non_axis_sizes || (quats.size(0) != 0)) {
    sizes_idx_1 = 4;
  } else {
    sizes_idx_1 = 0;
  }

  i = input_sizes_idx_1 + sizes_idx_1;
  b_result.set_size(result, i);
  nx = input_sizes_idx_1;
  for (int i1{0}; i1 < nx; i1++) {
    for (loop_ub = 0; loop_ub < result; loop_ub++) {
      b_result[loop_ub + b_result.size(0) * i1] = f[loop_ub + result * i1];
    }
  }

  k = sizes_idx_1;
  for (int i1{0}; i1 < k; i1++) {
    for (loop_ub = 0; loop_ub < result; loop_ub++) {
      b_result[loop_ub + b_result.size(0) * (i1 + input_sizes_idx_1)] =
        quats[loop_ub + result * i1];
    }
  }

  pointList.set_size(result, i);
  for (i = 0; i < nx; i++) {
    for (int i1{0}; i1 < result; i1++) {
      pointList[i1 + pointList.size(0) * i] = f[i1 + result * i];
    }
  }

  for (i = 0; i < k; i++) {
    for (int i1{0}; i1 < result; i1++) {
      pointList[i1 + pointList.size(0) * (i + input_sizes_idx_1)] = quats[i1 +
        result * i];
    }
  }

  //  Calculate the Euclidean distance from each target to the reference point
  //  Extract x, y, z from targets
  //  Subtract reference position from each target
  loop_ub = pointList.size(0);
  f.set_size(pointList.size(0), 3);
  for (i = 0; i < 3; i++) {
    for (int i1{0}; i1 < loop_ub; i1++) {
      f[i1 + f.size(0) * i] = pointList[i1 + pointList.size(0) * i] -
        pos_toolEE[i];
    }
  }

  r.set_size(pointList.size(0), 3);
  nx = f.size(0) * 3;
  for (i = 0; i < nx; i++) {
    d = f[i];
    r[i] = d * d;
  }

  coder::sum(r, distances);
  nx = distances.size(0);
  for (k = 0; k < nx; k++) {
    distances[k] = std::sqrt(distances[k]);
  }

  //  Compute Euclidean norm for each row
  //  Append distances as the 8th column to the original targets array
  b = ((b_result.size(0) != 0) && (b_result.size(1) != 0));
  if (b) {
    result = pointList.size(0);
  } else if (distances.size(0) != 0) {
    result = distances.size(0);
  } else {
    result = pointList.size(0);
  }

  empty_non_axis_sizes = (result == 0);
  if (empty_non_axis_sizes || b) {
    input_sizes_idx_1 = static_cast<signed char>(b_result.size(1));
  } else {
    input_sizes_idx_1 = 0;
  }

  if (empty_non_axis_sizes || (distances.size(0) != 0)) {
    sizes_idx_1 = 1;
  } else {
    sizes_idx_1 = 0;
  }

  loop_ub = input_sizes_idx_1 + sizes_idx_1;
  targets_with_distances.set_size(result, loop_ub);
  k = input_sizes_idx_1;
  for (i = 0; i < k; i++) {
    for (int i1{0}; i1 < result; i1++) {
      targets_with_distances[i1 + targets_with_distances.size(0) * i] =
        b_result[i1 + result * i];
    }
  }

  k = sizes_idx_1;
  for (i = 0; i < k; i++) {
    for (int i1{0}; i1 < result; i1++) {
      targets_with_distances[i1 + targets_with_distances.size(0) *
        input_sizes_idx_1] = distances[i1];
    }
  }

  //  Sort rows based on the distance column (8th column)
  coder::internal::sort(distances, iidx);
  k = iidx.size(0);
  sortedList.set_size(iidx.size(0), loop_ub);
  for (i = 0; i < loop_ub; i++) {
    for (int i1{0}; i1 < k; i1++) {
      sortedList[i1 + sortedList.size(0) * i] = targets_with_distances[(iidx[i1]
        + targets_with_distances.size(0) * i) - 1];
    }
  }

  nx = iidx.size(0);
  *listLength = nx;
}

//
// Arguments    : void
// Return Type  : void
//
void Matlab_ik_initialize()
{
  Matlab_checkCollision_new();
  Matlab_getForwardKinematics_new();
  Matlab_getGikCut_new();
  Matlab_getGikFull_new();
  Matlab_checkCollision_init();
  eml_rand_mt19937ar_stateful_init();
  Matlab_getForwardKinematics_init();
  Matlab_getGikCut_init();
  CoderTimeAPI::callCoderClockGettime_init();
  Matlab_getGikFull_init();
  isInitialized_Matlab_ik = true;
}

//
// Arguments    : void
// Return Type  : void
//
void Matlab_ik_terminate()
{
  Matlab_checkCollision_delete();
  Matlab_getForwardKinematics_delete();
  Matlab_getGikCut_delete();
  Matlab_getGikFull_delete();
  isInitialized_Matlab_ik = false;
}

//
// File trailer for Matlab_ik.cpp
//
// [EOF]
//
